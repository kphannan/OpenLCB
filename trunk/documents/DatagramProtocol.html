<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title>Note: Datagram Support</title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="824.48">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 16.0px 0.0px; font: 24.0px Times}
    p.p2 {margin: 0.0px 0.0px 12.0px 0.0px; font: 12.0px Times}
    p.p3 {margin: 0.0px 0.0px 14.0px 0.0px; font: 18.0px Times}
    p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times}
    p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; min-height: 14.0px}
    p.p6 {margin: 0.0px 0.0px 15.0px 0.0px; font: 12.0px Times}
    p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Symbol; min-height: 12.0px}
    p.p8 {margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times}
    p.p9 {margin: 0.0px 0.0px 6.0px 0.0px; font: 12.0px Times; min-height: 14.0px}
    span.s1 {font: 12.0px Symbol}
    span.s2 {text-decoration: underline}
  </style>
</head>
<body>
<h1 style="margin: 0.0px 0.0px 16.0px 0.0px; font: 24.0px Times"><b>Datagram Protocol</b></h1>
<p class="p2">Some wire protocols can support only very short packets/frames, e.g. CAN with a limited header and data payload. As OpenLCB evolves, it will inevitably need messages larger than that. Streaming provides a very large payload, at some cost in setup time and complexity. "Datagram Support" is in between "small enough to always be atomic" and "large enough to justify streaming overhead".</p>
<p class="p2">This note is a working draft of a proposal.</p>
<h2 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 18.0px Times"><b>Use Cases</b></h2>
<p class="p2">Configuration: Simple one-value reads and writes of configuration data are one-to-one operations that need to exchange 4-8-16 bytes of data.</p>
<p class="p2">External-network control: If the OpenLCB net is attached to single external networks, e.g. a DCC or LocoNet system, one-to-one transmission can be used to exchange native commands. E.g. “Send the following LocoNet message” may need to be up to 18 bytes long with current LocoNet definitions. Communcation to LocoNet/DCC/etc can be one-to-one to insure communications; return messages can be many one-to-one to listeners, but there's also a need for one-to-many or broadcast which is not addressed here.</p>
<p class="p2">RFID tags carry 40 (vs 64, and need to plan for future growth) bits of payload. Adding in some status and location information, reporting a RFID tag requires a 8-16 byte payload. RFID tags as broadcast might be valuable, but given payload size might not be easy (but consider N smaller events carrying part of it?). In that case, a datagram report might be the best approach.</p>
<h2 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 18.0px Times"><b>Discussion</b></h2>
<p class="p2">Datagrams are a one-to-one connection between nodes. They have a source address and a single destination address, and only have to be delivered to that single destination. Delivery is guaranteed if the destination node is active, initialized and reachable, but it's not possible to guarantee in advance that a buffer is available in the destination to receive and assemble the datagram.</p>
<p class="p2">At the high end, what's the maximum size for a datagram, beyond which it makes sense to move to a stream? Depends a little on the overhead for establishing the stream, not yet decided, but 64 bytes seems a reasonable cross-over point. The maximum datagram size must be short enough that nodes can afford to have a fixed receive-and-process buffer for datagrams allocated, unlike streams that can be too large to buffer.</p>
<p class="p2">At the low end, datagrams should go all the way down to zero bytes, because they are distinct from Events.</p>
<p class="p2">The datagram protocol doesn't need error correction, because OpenLCB is based only on reliable links. CAN, TCP/IP, etc, handle their own error conditions. The datagram protocol needs flow control and synchronization, however, as a small node might not have resources to accumulate a large number of datagrams that are arriving in an interleaved order. Perhaps a “retry immediately” response is the right way to handle that, but in order for the sending node to know it can free its buffer holding the transmitted message, there needs to be an “received OK, acknowledged” reply. In this case, 'reliable transport' just refers to a lack of content and order errors, not that messages always end up effective at the remote destination.</p>
<p class="p4">On CAN links, the datagram protocol is constrained by the need to limit space used for addresses. Datagrams must be broken into multiple frames, but there's just not enough space in a CAN frame to include the destination address in every frame. The protocol must allow for the possibility that datagrams to a particular node can be interleaved if several nodes are transmitting at the same time. Note that a node can control what it sends, so it is possible to ensure that only one datagram is being sent from a node at one time, just not that only one is being received.</p>
<p class="p5"><br></p>
<p class="p4">We're relying on CAN not reordering messages, even in the presence of error recovery. That's needed in any case for streams, which are so large that complete internal buffering cannot be assumed.</p>
<h2 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 18.0px Times"><b>Base Protocol Proposal</b></h2>
<p class="p2">In the base protocol a datagram is just a single short message containing the Datagram MTI and the data byte(s).</p>
<p class="p4">Once the datagram has been successfully received, the receiving node replies to the original source node with a “Datagram Acknowledged” message. Note that the node is not required to examine or process the datagram before replying; execution errors that happen later must be signaled using another protocol.</p>
<p class="p5"><br></p>
<p class="p4">Instead of “Datagram Acknowledged”, the receiving node may return a “Datagram Rejected” message tagged to represent exactly one of several conditions:</p>
<ul>
  <li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times">“Permanent error” - This node does not process datagrams, will not accept a datagram from this source, or for some other reason will not ever be able to accept this datagram. The datagram should not be retransmitted. Optionally, the node can mark the reply with one or more of several conditions:</li>
  <li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times">“Information Logged” - the node supports the logging protocol and information was logged for later retrieval.</li>
  <li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times">“Invalid Datagram” - something made the datagram improper, such as longer than the max permitted length. Proper datagrams might be acceptable.</li>
  <li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times">“Source not permitted” - datagrams from this source will never be accepted</li>
  <li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times">“Datagrams not accepted” - this node will not accept datagrams under any circumstance. A node can also reject the interaction instead of sending Datagram Rejected with this code.</li>
  <li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times">“Buffer shortage, resend” - The node wasn't able to receive the datagram because of a shortage of buffers. The sending node should resend at its convenience.</li>
</ul>
<p class="p5"><br></p>
<h2 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 18.0px Times"><b>CAN protocol proposal</b></h2>
<p class="p4">The datagram protocol on CAN links uses the same structure as the base protocol, except for the need to split the message into frames.</p>
<p class="p5"><br></p>
<p class="p4">Only one datagram may be sent from a specific source node ID to a specific destination ID at a time. The sender breaks the datagram content into one or more frames. The first frame contains the 2-byte destination NodeID alias in the data content, plus up to six data bytes. The source NodeID alias is contained in the header as usual.</p>
<p class="p5"><br></p>
<p class="p4">If there are more than six bytes to the datagram, the rest are send as consecutive frames. Because CAN transmission retains frame order, no order information is added to the frames to simplify packing and unpacking. The last frame is marked with a “datagram complete” bit. A ode may only send one datagram at a time to any given destination node. A node may interleave transmission of datagrams to separate nodes, but this is not recommended because it increases the probability of buffer collisions.</p>
<p class="p5"><br></p>
<p class="p4">The receiving node receives the frames into a buffer. The frames from more than one datagram may arrive in interleaved order, in which case the receiving node can tell them apart using their source NodeID alias and store them in separate buffers. Once the “datagram complete bit” is received for a datagram, the node replies to the original source node with a “Datagram Acknowledged” message.</p>
<p class="p5"><br></p>
<p class="p4">An interface or gateway onto a CAN link must do the datagram fragmentation locally. Buffer retries may be either done locally by the gateway, or by reflecting the response back to the original sender.</p>
<p class="p5"><br></p>
<p class="p4">In addition to the response codes in the base protocol, a CAN node can reply with “Datagram Rejected, Out of Order” if an improper sequence of CAN frames is observed. The interface or gateway charged with fragmentation may reattempt transmission. Since this is not ever supposed to happen, it is recommended that it be logged.</p>
<h2 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 18.0px Times"><b>CAN Examples</b></h2>
<h4 style="margin: 0.0px 0.0px 15.0px 0.0px; font: 12.0px Times"><b>Normal CAN case</b></h4>
<p class="p4">Start Datagram <span class="s1">→</span></p>
<p class="p4">Mid Datagram <span class="s1">→</span></p>
<p class="p4">Mid Datagram <span class="s1">→</span></p>
<p class="p4">End Datagram <span class="s1">→</span></p>
<p class="p7"><br></p>
<p class="p4"><span class="s1">←</span> Datagram Acknowledged</p>
<h4 style="margin: 0.0px 0.0px 15.0px 0.0px; font: 12.0px Times"><b>Short CAN datagram case</b></h4>
<p class="p4">Start&amp;End Datagram <span class="s1">→</span></p>
<p class="p4"><span class="s1">←</span> Datagram Acknowledged</p>
<p class="p5"><br></p>
<h4 style="margin: 0.0px 0.0px 15.0px 0.0px; font: 12.0px Times"><b>Rejected short CAN datagram case</b></h4>
<p class="p4">Even a short datagram can be rejected with a “Temporarily unable to receive” if there's e.g. a shortage of buffers:</p>
<p class="p5"><br></p>
<p class="p4">Start&amp;End Datagram <span class="s1">→</span></p>
<p class="p4"><span class="s1">←</span> Datagram Rejected, Buffer shortage, Resend</p>
<p class="p5"><br></p>
<h4 style="margin: 0.0px 0.0px 15.0px 0.0px; font: 12.0px Times"><b>Rejected interleaved CAN datagram case:</b></h4>
<p class="p4">Accidental interleave, at a node that can't handle that:</p>
<p class="p5"><br></p>
<p class="p4">Start Datagram from A <span class="s1">→</span></p>
<p class="p4">Start Datagram from B <span class="s1">→</span></p>
<p class="p4"><span class="s1">←</span> Datagram Rejected, Buffer shortage, Resend to B</p>
<p class="p4">Mid Datagram from A <span class="s1">→</span></p>
<p class="p4">End Datagram from A-&gt;</p>
<p class="p4"><span class="s1">←</span> Datagram Acknowledged to A</p>
<p class="p4">Start Datagram from B <span class="s1">→</span></p>
<p class="p4">End Datagram from B-&gt;</p>
<p class="p4"><span class="s1">←</span> Datagram Acknowledged to B</p>
<h4 style="margin: 0.0px 0.0px 15.0px 0.0px; font: 12.0px Times"><b>Invalid CAN protocol case:</b></h4>
<p class="p4">End Datagram <span class="s1">→</span> (without start datagram from this source)</p>
<p class="p4"><span class="s1">←</span> Datagram Rejected, Out of Order</p>
<h2 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 18.0px Times"><b>Datagram Content</b></h2>
<p class="p2">There needs to be a method for identifying the content of a general datagram. Although it's possible to for two nodes to negotiate a particular use of datagrams, but more often then will be used to exchange commands and responses between general nodes.</p>
<p class="p2">We also want those “datagram content IDs” to be unique, unambiguous, easily assigned, etc. To do that, there are two basic approaches:</p>
<ul>
  <li style="margin: 0.0px 0.0px 12.0px 0.0px; font: 12.0px Times">Have a one-byte or two-byte ID field, and have some central sequential method of assignment. This is small, so doesn't use much space on CAN, but is a pain to maintain. Pretty soon we'll have collisions, undecodable values, etc.</li>
  <li style="margin: 0.0px 0.0px 12.0px 0.0px; font: 12.0px Times">Use a 6 byte field assigned the same way that node unique identifiers are. The NMRA-reserved space could be used for common formats, and the manufacturer space can be used for custom formats. This takes significantly more space, particularly on CAN, but is simple to maintain.</li>
</ul>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 14.0px Times"><b>Numerology</b></h3>
<p class="p2">If one byte is used for the datagram format field, the first CAN-link datagram contains 5 payload bytes (the following datagrams can contain 8). That counts as part of the information that the datagram is transporting, though. Perhaps we should make the maximum datagram size (9*8-2) = 70 bytes, to ensure that even with a little bit of higher protocol, say up to 6 bytes, 64 bytes of actual data can be delivered at a shot?</p>
<p class="p4">If we use a few codes in the first data byte to select various configuration operations, the remaining 5 bytes could do 16 bit writes in a 24 bit space in a single-frame datagram, or similarly read back a full-word (four bytes). For configuration writes, maybe it's just an address followed by N bytes for the value. Is a 3-byte address too short if e.g. sound data appears in the configuration space (3 bytes = 2^24 = 16*10^6 locations)? The maximum write is just limited by the maximum length. On read, that leaves two bytes for length, which is enough over a CAN link. Multiple formats are a pain to implement, but so are segmentation registers, etc. How to make the data from large reads show up in a stream instead of a too-long datagram?</p>
<p class="p5"><br></p>
<p class="p4">For external protocols, e.g. support for LocoNet, XpressNet, DCC, etc, it's a great simplification if the datagrams can carry <span class="s2">any</span> basic message of the external protocol in a single datagram. Is 64 bytes then enough? NMRA DCC is up to 5 bytes, including addressing, so it's clearly OK. Others?</p>
<p class="p5"><br></p>
<p class="p4">On the other hand, even with the long format IDs, most operations would fit in two CAN frames, and would be much simpler to code and decode.</p>
<h2 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 18.0px Times"><b>Extensions</b></h2>
<p class="p4">In this version of the datagram protocol, there is no provision for multiple recipients of a single message. Transmission is strictly one-to-one. This isn't because of addressing (making them globally visible isn't hard), but rather the need for guaranteed buffering at the receiving node. In the future, we may want to provide one-to-many datagrams.</p>
<p class="p5"><br></p>
<p class="p4">The recipient needs to have a buffer into which any datagram in flight can be received. On a tiny node, those might be a scarce resource. But, without any protocol support, e.g. if datagrams were "fire and forget" like event notifications, you might need to have a very large number of those buffers. There's nothing in the protocol that prevents nodes A, B, C <span class="s2">and</span> D from firing off a datagram at node X at the same time, and having their CAN frames be interleaved when they arrive at X.(The stream protocol negotiates this in advance, but that requires time and resources only appropriate to large transfers) To properly receive them, X needs N=4 buffers to reassemble them in this case. But how big an N is really required? It's not possible to know, so instead we add protocol support: X can tell nodes sending it datagrams to repeat them. That way X can accept as many datagrams as it has buffers (at least one), while telling the others to "say that again, please, I wasn't paying attention the first time".</p>
<p class="p5"><br></p>
<p class="p4">A sending node knows that it has to hang onto the datagram until it gets a "acknowledged" message, because if it gets a "say that again" it needs to still have the content to resend it. The "acknowledged" and "say that again" are not about data loss on a link, but about buffer management in tiny nodes. A one-to-many protocol could also do something like that, because the transmitter still knows how many "many" is. Global broadcast, like events, is hard because the <span class="s2">transmitters</span> buffer management gets complicated unless it knows how many nodes are listening for it's reply. Perhaps the solution is a "not available on CAN links" protocol for "global datagrams". This would allow broadcast to non-CAN nodes, but not directly to nodes on CAN links.</p>
<p class="p5"><br></p>
<p class="p9"><br></p>
<p class="p2">This is SVN $Revision: 71 $</p>
</body>
</html>
