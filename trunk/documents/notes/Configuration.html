<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE>NMRAnet Note: Node Configuration</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 3.1  (Unix)">
	<META NAME="CREATED" CONTENT="0;0">
	<META NAME="CHANGEDBY" CONTENT="Bob Jacobsen">
	<META NAME="CHANGED" CONTENT="20090821;10341700">
	<META NAME="Info 1" CONTENT="">
	<META NAME="Info 2" CONTENT="">
	<META NAME="Info 3" CONTENT="">
	<META NAME="Info 4" CONTENT="">
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<H1>Note: Node Configuration</H1>
<P>For now, just a place to put stuff.</P>
<H2>Environment of Proposal</H2>
<H3>Requirements</H3>
<UL>
	<LI><P>Nodes must carry enough context that a stand-alone
	configuration tool can provide a useful human interface without
	getting any data from an external source, e.g. needing an Internet
	download to handle a new node type.</P>
	<LI><P>It must be possible to configure a node entirely over the
	NMRAnet, without physical interactions, e.g. pushing buttons.</P>
	<LI><P>It must be possible to configure one node while the rest of
	the NMRAnet is operating normally.</P>
	<LI><P>It must be possible to read, store, and reload the
	configuration of a node.</P>
</UL>
<H3>Preferences</H3>
<UL>
	<LI><P>Small nodes shouldn't need a lot of processing power, e.g. to
	compress or decompress data in real time. Memory usage should also
	be limited, but is a second priority.</P>
</UL>
<H3>Design Points</H3>
<P>Basically done with datagrams.  Want to pack an atomic read or
write into a short CAN datagram, which we can do if we reserve a few
datagram types so we can use the next five bytes for a 24-bit address
and 16bit of write data or a 16-bit read count.</P>
<P>Byte addressing or CV equivalents?  Picking one makes datagram
formats easy.</P>
<P>For larger transfers, want to go over to streams.  But not all
nodes support those; need a reliable way to ask about that via a
datagram.</P>
<P>Some datagram op code possibilities:</P>
<UL>
	<LI><P>Read N bytes</P>
	<LI><P>Write 1 byte</P>
	<LI><P>Write 2 bytes</P>
	<LI><P>Enquire status e.g. stream available, memory size (for
	dump/restore), etc</P>
</UL>
<P>And don't forget to reserve a few!</P>
<P><BR><BR>
</P>
<H2>Discussion</H2>
<P>Text from initial report to NMRAn<FONT FACE="Times New Roman, serif">et
WG (</FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif"><FONT SIZE=3>TN-9-6-NMRANET-Overview-Draft)</FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="LucidaGrande"><FONT SIZE=3>:</FONT></FONT></FONT></P>
<P STYLE="margin-bottom: 0cm">“All NMRAnet nodes will contain a
compressed XML document that contains all the relevant information
for an external Configuration Tool (CT) to be able to to use to know
how to configure the node. It is expected that the CT will use the
data in the XML file to render some form of suitable Graphical User
Interface to allow the user to easily and intuitively configure all
aspects of the node's capabilities. An important design choice was to
embed this XML document into each node so that the system has all it
needs to configure the node without having to source the XML file
externally to the NMRAnet from the manufacturer or some other on-line
repository via the Internet or a CD/DVD etc. While the CT is likely
to be a program running on a PC, it could be a hand-held device like
mobile phone or PDA or even a custom built CT.”</P>
<P><BR><BR>
</P>
<P>Use of DataGram protocol for initiation of process?</P>
<P><BR><BR>
</P>
<P>Background</P>
<P>Bob's note to the NMRAnet WG on configuration information:</P>
<PRE>This is the third step in defining &quot;Configuration definition information&quot; (CDI).  
The part at the front remains the same, except for some clarification in item 1B and 4F.  
This is followed by new material describing a proposed structure for the CDI.  
After discussion and modification, this will be used to create a recommendation for 
the specific format.  That will in turn be followed by discussion and definition of
compression/decompression method(s), etc.




1) &quot;Configuration definition information&quot; in this context refers to _fixed_ information available from a NMRAnet device, via NMRAnet, so that other devices can properly and correctly configure it.

1A) The information is fixed, so that it can be pre-compressed, stored in the device, and just supplied when needed with minimal work on the part of the device and the device's developers.

1B) This means that e.g. the actual current configuration contents are not available as part of the CDI, as that is variable information. Similarly, the CDI cannot contain e.g. a serial number as that would require different CDI contents in each node of a single type.

1C) Other information may be available via e.g. manuals or the Internet, and there may be pointers to that information in the CDI, but the format of that information is not under specification here.


2) The primary design constraints are complexity and size in the NMRAnet device providing CDI, and complexity and size in the device consuming the CDI.

2A) Size and complexity in the providing device is the more important constraint.  There are more of those devices, they are cost sensitive, and they may not be upgradable once delivered.

2B) Size and complexity in the CDI-consuming device should also be considered. In particular, code complexity is an issue which must be addressed.


3) Secondary constraints are testability of the provided information,  scalability of the format, and the convenience and availability of a suitable toolchain.


4) There is a physical/logical structure to the configuration which the CDI can and should reflect:

4A) The basic NMRAnet unit is a &quot;Node&quot;. Nodes provide CDI for their needed configuration information. The protocol for that will be defined elsewhere/elsewhen.

4B) A Node can contain zero or more &quot;Producers&quot;.  Each Producer is independently configured. There is no ordering between separate Producers.

4C) A Node can contain zero or more &quot;Consumers&quot;.  Each Consumer is independently configured. There is no ordering between separate Consumers, or between individual Consumers and Producers.

4D) Each Producer or Consumer can be configured with zero or more Events.

4E) Each Event has an Identifier which uniquely defines it. An event may optionally carry additional data.

4F) To ensure future growth, there is no required &quot;device&quot;, &quot;channel&quot; or other grouping within a node. Those may be present in some node types, and CDI must be able to represent them, but may not require any specific organization.



The configuration definition is stored in a hierarchical manner.

I) In what follows:

A &quot;String&quot; must be present; an &quot;Optional String&quot; does not have to be.  Strings can be either in ASCII (8-bit) or, to allow international use, UTF-8 or UTF-16.

An &quot;Integer&quot; may be signed; if no sign, it's taken as positive.


I) At the top, root level is the information for a &quot;node&quot;.  This includes:

  Manufacturer: String
  ManufacturerID: Integer
  Model:  String
  ModelNumber: Integer
  Version: String
  Description: Optional String
  URL: Optional String

The ManufacturerID and ModelNumber are assigned unique numeric values. The process for assigning those, ensuring them unique, and making those assignments available to the community are beyond the scope of the CDI specification.

No specific content is expected at the URL. If desired, that can be dealt with in a different specification.

Additional descriptive information can be grouped below this node as desired; see below.

II) Within the node information is zero or more &quot;groups&quot;. Each group contains:

   Name: String, required to be unique within enclosing group or node
   Description: Optional String
   Replication count: Integer &gt;= 1 (number of times this group is replicated within the parent item)

A group with a replication count &gt; 1 (called a replicated group) can be used to represent a type of replicated device.  For example, a node with 4 identical input devices and 6 identical output devices can be compactly described by two groups, with replication counts of 4 and 6 respectively.

Individual groups within replicated groups are numbered from 1 to the replication count. If more than one replicated group is present, the numbering for each starts again with 1.

Groups may contain one or more inner groups, with the same representation. This may continue to any desired level.

III) Groups may contain &quot;variable&quot;, &quot;map&quot;, &quot;producer&quot; and/or &quot;consumer&quot; descriptions.

III-a) A &quot;variable&quot; description contains:

   Name: String, required to be unique within enclosing group or node
   Type: Exactly one of &quot;boolean&quot;, &quot;digit&quot; (an unsigned binary-coded-decimal value), &quot;signed&quot; (a binary value with a sign), &quot;unsigned&quot; (a binary value without a sign), &quot;string&quot; (an ASCII string, not-null terminated), or &quot;blob&quot; (arbitrary byte vector).
   Max: Integer - For string and blob variables, the maximum number of bytes that can be stored. For digit, signed and unsigned types, the maximum value allowed.
   Min: Integer - For digit, signed and unsigned values, the minimum value allowed.
   Description: Optional String
   Default: value of this Type, required

A variable may contain one or more map descriptions.  Each map represents a mapping between possible values (the &quot;Key&quot; part of the map's pairs) and convenient names for them (the &quot;Value&quot; part of the map's pairs). If more than one map is present, their Name and/or Description fields can be used to distinguish which is to be used.

Note that the current value of a variable is not considered configuration definition information (see item 1A and 1B in the introduction).

Configuration information must not be packed into variables; each variable must represent one type of information. In particular, the use of individual bits within larger values to pack multiple pieces of information is forbidden; those must be represented as individual variables.  (How the information is stored internally is up to the designer of the specific device, and is not restricted)

III-b) A &quot;map&quot; description contains:

   Name: String, required to be unique within enclosing group or node
   Description: Optional String
   1  or more &quot;Key&quot;, &quot;Value&quot; pairs.  Each element of the pair can be of
            any supported type, depending only on how it is to be used.
            
Map elements provide a mapping between the pairs they contain.  For example, a map can relate numeric values for a variable to description strings.

III-c) A &quot;producer&quot; description contains:

   Name: String, required to be unique within enclosing group or node
   Number of Events: Integer - the number of event ties that can be associated with this producer
   Container: yes/no - whether the emitted events can carry content beyond the configured value
   Description: Optional String

A producer description may contain zero or more variable descriptions for any variables that configure details of the producer's function. If Container == yes, there must be specific variables (TBD) for configuring and/or obtaining information about the content in the emitted events.


III-d) A &quot;consumer&quot; description contains:

   Name: String, required to be unique within enclosing group or node
   Number of Events: Integer - the number of event ties that can be associated with this consumer
   Description: Optional String

A consumer description may contain zero or more variable descriptions for any variables that configure details of the consumer function. This may include e.g. variables that define how any content in incoming messages will be used.





-----
The following is not meant to show _how_ configuration definition information would be stored, but _what_ kinds of information would be stored.  It's a description of a complex accessory decoder, the Digitrax DS54, modified for use in a Producer-Consumer model.

Hopefully the syntax will be self-explanatory.  In any case, it's just for this example, not a proposal of any kind.

Manufacturer (String): Digitrax
Model (String): DS54
Version (String): 2.33
Description (Optional String): For more information, see 
http://digitrax.com/asdf/123

Group start:
Name (String): Decoder
Description (Optional String): These variables describe the entire board
Replication count (integer): 1

Variable:
    Name: Address
    Type: Integer
    Max:  2044
    Min: 0
    Description: This is the board address, in DCC space originally


Group start: (Note this is nested in &quot;Decoder&quot;)
    Name (String): Channel
    Description (Optional String): Each Channel is one pair of output wires and contains two inputs
    Replication count (integer): 4

Group start: (Note this is nested in &quot;Channel&quot;)
    Name (String): Input
    Description (Optional String): Each Channel has two inputs, called &quot;Switch&quot; and &quot;Aux&quot;
    Replication count (integer): 2

Producer start:
   Name: Switch Input
   Number of Events: 9
   Container: Yes
   Description: Driven by the 1st input wire for this channel.  Messages carry a single bit of data, the state of the input. The variables control ....

   Variable:
       Name: Input Type
       Type: Integer
       Max: 10
       Min: 0
       Default: 0
       Description: Specify the type of signal expected on this input
        
       Map:
          Name: Values
          &quot;0&quot;, &quot;0.125sec retriggerable pulse&quot;
          &quot;1&quot;, &quot;0.25sec retriggerable pulse&quot;
          &quot;2&quot;, &quot;0.35sec retriggerable pulse&quot;
          ...
       Map End
 
      
   Variable:
 Name:  Input Task
       Type: Integer
 Max: 8
       Min: 0
 Default: 0
       Description: Specify the local action when this input is active

       Map:
 Name: Values
          &quot;0&quot;, &quot;Output toggle&quot;
 &quot;1&quot;, &quot;No output change&quot;
          &quot;2&quot;, &quot;Output thrown&quot;
 ...
       Map End
 
Producer end:

Group end: (This is the end of the input group)

   Variable:
 Name: Output Type
        Type: Integer
 Max: 40
        Min: 0
 Default: 0
        Description: Determines what the output leads do in response to events ....

Consumer start:
 Name: Turnout Active Thrown
   Number of Events: 1
 Description: Set the thrown output lead active and closed lead inactive.
Consumer end:

Consumer start:
 Name: Turnout Active Closed
   Number of Events: 1
 Description: Set the closed output lead active and thrown lead inactive.
Consumer end:

Consumer start:
 Name: Turnout Active Both
   Number of Events: 1
 Description: Sets both output leads active.
Consumer end:

Consumer start:
 Name: Turnout Inactive
   Number of Events: 1
 Description: Sets both output leads inactive.
Consumer end:

Group end: (This is end of the &quot;Channel&quot; group)

Group end: (This is end of the &quot;Decoder&quot; group)


Some thoughts based on putting this together:

1) In a real DS54, there's are subtle differences between the Switch 
and Aux configuration choices. I blurred those here by documenting 
them identically via replication. For a real device, they could 
either be separately specified or (more likley) the differences 
wouldn't matter in a P/C-based device.

2) A DS54 can receive messages that put it's output into four states: 
One side on, the other side on, both sides on, and neither side on. 
These four interacts with the &quot;Output Type&quot; setting in weird and 
wonderful ways.  Rather than have this be one consumer with data, I 
specified four consumers without data.  These seems a much more 
logical way to configure the device, as it gives more flexibility to 
the _rest_ of the layout that's originating the requests.

The DS54 inputs also generate messages. They could either be 
specified as two producers (for the active and inactive messages) or 
one with data.  To be fully consistent and interoperable, those 
should probably be two separately configurable producers per input, 
but for the purposes of the example I made it just a single one that 
puts data in the message.

============================

This proposal is for fully structured data, while allowing the structure to adapt to the structure of future devices. 

Don Voss has proposed an alternative:

 I see a Node supporting from 0 to 255 devices. A device's address is Node_Address:Device_Offset where the device_offset is 8 bits. The compressed XML file carries the needed information on the organization:
    1. Device Group 1 offsets; 1-16
 2. Device Group 2 offsets; 17-37
    3. Device Group 3 offsets; 28-45
 4. Group 1 definitions:
    5. Group 2 definitions:
 6. Group 3 definitions:

This results in simpler parsing, but builds in a very specific structure without nesting, etc.

...

For the modules I have programmed, I would require the following:
1. A Device is the operational element and is addressed with a Device_Offset:8
2. The definition of a capability is defined for a group of devices; 1st device_Offset:last device_Offset of the group. Note 1st and last may be the same.
3. There may be multiple groups with different capabilities within the module.
4. Variables within the Device are addressed as Var_Offset:8. Each variable is defined by the XML file as to function and Length(bit, nibble,1-4 bytes) within the Device Group.
5. A functional description of an Event Tie Table which supports all Consumer devices within the module. The ability to read this table ( transfer through file-str! eaming). Erase Table entry. Insert Table Entry. I see this Event_Tie_ Table as a part of the minimum required set.
</PRE><P>
<BR><BR>
</P>
<P><BR><BR>
</P>
<HR>
<P>This is SVN $Revision: 52 $ 
</P>
</BODY>
</HTML>