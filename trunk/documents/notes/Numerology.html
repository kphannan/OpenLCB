<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title>Numerology</title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="824.48">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 16.0px 0.0px; font: 24.0px Times}
    p.p2 {margin: 0.0px 0.0px 12.0px 0.0px; font: 12.0px Times}
    p.p3 {margin: 0.0px 0.0px 14.0px 0.0px; font: 18.0px Times}
    p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times}
    p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; min-height: 14.0px}
    p.p6 {margin: 0.0px 0.0px 6.0px 0.0px; font: 12.0px Times; min-height: 14.0px}
  </style>
</head>
<body>
<h1 style="margin: 0.0px 0.0px 16.0px 0.0px; font: 24.0px Times"><b>Note: Numerology</b></h1>
<p class="p2">A brief note on the selection of size for various fields.</p>
<h2 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 18.0px Times"><b>Node Sequence Number</b></h2>
<p class="p2">Why 48 bits for a node sequence number?</p>
<p class="p2">That's large enough to make assignment easy, while still fitting in a CAN frame.</p>
<p class="p2">Larger is better for assignment, but is a load on hardware and bandwidth. CAN networks have limited packet contents: 8 bytes plus header. The Event ID size is NID size + 16 bits, so an increase in the NID to e.g. 64 bits, unless the Event ID changed, would make CAN packets difficult to form.</p>
<p class="p2">48-bits for NID plus 16 more to code node-specific events makes an 8-byte event ID, which CAN segments can handle (if we drop event sequence numbers, which don't yet have a strong justification) once we put the rest of the info into the extended header.</p>
<p class="p2">Ethernet MAC addresses (also known as EUI-48 addresses) are already 48-bits long. They could be used, but we'd have to make a node ID even longer than 48 bits to flag which are MAC addresses and which are assigned by other means. So they're not particularly useful.</p>
<h2 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 18.0px Times"><b>Event ID</b></h2>
<p class="p2">Why 64 bits for Event ID?</p>
<p class="p2">Event IDs are unique IDs with no internal structure, but defining them large enough for an NID plus a 16-bit sequence number makes unique allocation easy by piggy-backing on the NID allocation scheme. Whoever first defines a particular event need only use a node ID under their control (this could be the node ID of a specific piece of hardware, but it doesn't have to be, so long as it's owned by the person or board defining the event), plus a lower 16 bits that they know is unique. This is then guaranteed to be unique across any combination of OpenLCB nodes, gateways, etc, without the person/board doing the definition having to communicate with anybody else. This works even it parts of the OpenLCB are powered off, not yet installed, unreachable due to a missing link, or not even built yet.</p>
<p class="p2">16 bits for event number within each NID is perhaps a little large, but 8 bits (256 events per node) is clearly not enough. Since a byte is a very convenient unit, we go with two bytes.</p>
<p class="p2">6-byte EventIDs do take up memory. A board with 8 outputs might need 8*2*2 events, for a total of 200 bytes; large on the scale of current low-cost PIC microcomputers. But this restriction is rapidly being relaxed as new components are introduced.</p>
<h2 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 18.0px Times"><b>CAN ID</b></h2>
<p class="p2">The source CAN NID alias needs to fit completely within the header for arbitration, along with whatever other bits are required.</p>
<p class="p2">The headers are 11 and 29 bits, depending on standard vs. extended format.</p>
<p class="p2">The other bits that need to be included:</p>
<ul>
  <li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times">Priority - at least one bit needed to simplify bridging.</li>
  <li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times">Bits for ID disambiguation - the default algorithm uses 8 for data plus 3 to label byte 1-6. A total of 48 bits (NID length) need to be checked, so fewer bits is possible, but it takes more messages at startup. More in header for this would be better.</li>
  <li style="margin: 0.0px 0.0px 12.0px 0.0px; font: 12.0px Times">Command code - not all needed in header, but it has to go somewhere and having at least part of it in the header allows filtering. Having a bit or two to code "simple boards need to watch these" would be particularly useful.</li>
</ul>
<p class="p2">The longest defined payload (assuming 48 bit NID , 64 bit EventID and 1 byte MTI on CAN) is the PCER, MTI+EventID &gt; 8 bytes, so MTI for at least this MTI value has to be in extended header.</p>
<p class="p2">The use of 11-bit CAN ID (in the absense of priority bits) would allow standard headers, but only 2047 unique nodes in the reachable OpenLCB installation. (Routing tables would map the external NIDs to the available CAN ID codes; the algorithm to do this would be complex if more than one gateway was allowed to attach to a CAN segment) More are clearly needed, and 16-bits is the next logical break point.</p>
<p class="p4">All this leads to an 16-bit CAN ID.</p>
<p class="p5"><br></p>
<h2 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 18.0px Times"><b>CAN Rate</b></h2>
<p class="p4">Higher bit rates move more data and reduce latency. But they reduce segment capability in terms of length, node count and robustness against marginal wiring.</p>
<p class="p5"><br></p>
<p class="p4">OpenLCB CAN frames tend to be large. Eight-byte EventIDs and extended CAN headers combine to roughly 120 bits. (Check that!) 125kbps CAN is then about 1000 frames per second, just a few milliseconds typical latency, and typical inter-frame time of a millisecond.</p>
<p class="p5"><br></p>
<p class="p4">Raising the rate to e.g. 500kbps raises capacity to 4000 frames per second, and reduces latency by a little more than a factor of four. But it only leaves 250 nsec inter-frame time, which is a tougher constraint for small-processor nodes to meet. They'll need faster processors, more advanced buffering software, and/or more complex/expensive CAN interfaces.</p>
<p class="p5"><br></p>
<p class="p4">The faster rate also reduces the reliable length of a CAN segment. 125kbps is meant to operate to a limit of 50 to 80 meters, while 500kbps should operate to 30 to 40 meters, roughly 100 feet. That still seems pretty long, but because wiring tends to snake around layouts, it might not be adequate for even a 25x25 foot layout.</p>
<h2 style="margin: 0.0px 0.0px 14.0px 0.0px; font: 18.0px Times"><b>CAN Segment Size</b></h2>
<p class="p4">What should the recommended maximum number of nodes on a OpenLCB CAN segment? Of course, people will always connect more, but what recommended size properly balances reliability and robustness against the need to build large layouts?</p>
<p class="p5"><br></p>
<p class="p4">This depends on what rate is specified, and also on the maximum length recommended.</p>
<p class="p5"><br></p>
<p class="p5"><br></p>
<p class="p5"><br></p>
<p class="p5"><br></p>
<p class="p6"><br></p>
<p class="p2">This is SVN $Revision: 74 $</p>
</body>
</html>
