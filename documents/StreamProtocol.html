<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE>OpenLCB Note: Streaming</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 3.2  (Unix)">
	<META NAME="CREATED" CONTENT="0;0">
	<META NAME="CHANGEDBY" CONTENT="Bob Jacobsen">
	<META NAME="CHANGED" CONTENT="20100615;16061400">
	<META NAME="Info 1" CONTENT="">
	<META NAME="Info 2" CONTENT="">
	<META NAME="Info 3" CONTENT="">
	<META NAME="Info 4" CONTENT="">
	<META NAME="CHANGEDBY" CONTENT="Bob Jacobsen">
	<META NAME="CHANGEDBY" CONTENT="Bob Jacobsen">
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<H1>Streaming Protocol</H1>
<P>Streaming is used to move large amounts of data (kilobytes and up)
across a OpenLCB implementation. 
</P>
<P>This documents describes the streaming protocol(s) in OpenLCB. 
</P>
<H2>Environment of Proposal</H2>
<H3>Requirements</H3>
<UL>
	<LI><P STYLE="margin-bottom: 0cm">Must work within OpenLCB
	architecture of a flat address space and unique identifiers 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">Receiving end must be able to
	throttle rate of arrival. 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">Multiple transfers at the same
	time over a single OpenLCB segment, so that transfers between
	disjoint nodes don't need to be coordinated. 
	</P>
	<LI><P>Needs to be effective over CAN, with acceptable bit
	efficiency.</P>
</UL>
<H3>Preferences</H3>
<UL>
	<LI><P STYLE="margin-bottom: 0cm">It should be possible to have
	multiple streams active at the same time to or from a single node.
	Nodes can choose not to support this.</P>
	<LI><P STYLE="margin-bottom: 0cm; font-style: normal">Different
	buffers sizes can be used. High capability nodes can use large
	buffers for efficiency, low capability nodes can still function with
	small buffers.</P>
	<LI><P>Streams should have a way of identifying their content &amp;
	purpose within themselves, in addition to through other protocols.</P>
</UL>
<H3>Design Points</H3>
<UL>
	<LI><P STYLE="margin-bottom: 0cm">Data integrity is handled by
	transport level, and need not be ensured in the streaming protocol. 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">A stream has a beginning and an
	end, and some number of bytes transferred in between. All other
	structures are implemented by higher-level protocols outside the
	streaming protocol or data fields within the streamed data itself.
	For example, the streaming protocol doesn't have tools for telling
	what type of data is involved, or define a format for sound files
	send over streams, etc. The stream has no intrinsic block, or record
	structure.</P>
	<LI><P STYLE="margin-bottom: 0cm">Streaming is not needed for short
	transfers, so a certain amount of overhead is acceptable<SPAN STYLE="font-style: normal">.
	(This implies a Datagram protocol to cover the gap between Events
	and Streams in size, see separate document)</SPAN></P>
	<LI><P>We assume that routes don't change dynamically in ways that
	effect e.g. buffer allocation.</P>
</UL>
<H2>Protocol</H2>
<UL>
	<LI><P STYLE="margin-bottom: 0cm">Optionally, the destination can
	request that the source start a transfer. This uses some mechanism
	not discussed here, e.g. Datagram messages.</P>
	<LI><P STYLE="margin-bottom: 0cm">The source sends an &quot;Stream
	Initiate Request (Addressed)&quot; to the destination. It carries a
	&quot;Max Buffer Size&quot; value (2 bytes), a “Tagged” boolean
	flag (1 bit in a byte) and a &quot;Source Stream ID&quot; (1 byte)
	in the data section. The combination of source, destination, and
	Source Stream ID must uniquely identify this stream transmission.
	The Source Stream ID has no meaning to the destination. 
	</P>
	<LI><P>If the destination node does not wish to receive the stream,
	it returns a &quot;Stream Initiate Reply (Addressed)&quot; marked
	“reject” and tagged to represent exactly one of several
	conditions:</P>
	<UL>
	<LI><P STYLE="margin-bottom: 0cm">“Permanent error” - This node
	does not process streams, will not accept a stream from this
	source, or for some other reason will not ever be able to accept
	this stream. The Stream Initiate Request should not be retransmitted.
	Optionally,
	the node can mark the reply with one or more of several conditions:</P>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm">“Information Logged” - the
		node supports the logging protocol and information was logged for
		later retrieval.</P>
		<LI><P STYLE="margin-bottom: 0cm">“Invalid Stream Request” -
		something made the stream request improper, such as longer than the max
		permitted length. Proper requests might be acceptable.</P>
		<LI><P STYLE="margin-bottom: 0cm">“Source not permitted” -
		streams from this source will never be accepted</P>
		<LI><P STYLE="margin-bottom: 0cm">“Streams not accepted” -
		this node will not accept stream requests under any circumstance. A node
		can also <A HREF="tandardInteractions.html">reject the interaction</A>
		instead of sending Stream Initiate Reply with this code.</P>
	</UL>
	<LI><P STYLE="margin-bottom: 0cm">“Buffer shortage, resend” -
	The node isn't able to receive the stream because of a shortage
	of buffers. The sending node should resend at its convenience.</P>
	<LI><P>“Stream rejected, out of order” - Should not happen,
	but an internal inconsistency was found in the CAN frames making up
	a stream. Sender can try again if desired.</P>
	</UL>
	<LI><P>If the destination node wishes to receive the stream, it
	returns a &quot;Stream Initiate Reply (Addressed)&quot; marked
	“accept”, with a &quot;Max Buffer Size&quot; value (2 bytes),
	the “Tagged” boolean flag (1 bit in a byte), &quot;Source Stream
	ID&quot; (1 byte) and &quot;Destination Stream ID&quot; (1 byte). 
	</P>
	<P>The &quot;Max Buffer Size&quot; is less than or equal to the
	value in the Initiate Stream Request, and is the negotiated buffer
	size for this transfer. If it's zero, the request to start the
	stream has been rejected, and the exchange is over. The source can
	try again later.</P>
	<P>The Source Stream ID is the same as the value in the Initiate
	Stream Request, and is returned for the convenience of the source.
	The destination doesn't do anything with it except return it. The
	source can use it to match up multiple operations, as a way of
	identifying buffers, or for any other purpose.</P>
	<P STYLE="margin-bottom: 0cm">The Destination Stream ID is used to
	tag the data sent to the destination. It has no meaning to the
	source. The destination can, but need not, use it to associate the
	stream data with a particular buffer or usage.</P>
	<LI><P STYLE="margin-bottom: 0cm">The source starts sending bytes
	using Stream Data Send (Addressed) messages, each carrying up to the
	message size limit on the particular wire protocol and the
	Destination Stream ID. After sending Max Buffer Size bytes in one or
	more messages, the source pauses. 
	</P>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm">If the “Tagged” flag was true
		during initialization, the first 6 bytes of the data are a unique
		data-type indicator. These are allocated the same way that Node
		IDs, etc, are allocated, but from a separate name space. If that
		“Tagged” flag is false, some higher-level protocol must
		identify the data-type of the stream data.</P>
	</UL>
	<LI><P STYLE="margin-bottom: 0cm">Upon receiving Max Buffer Size
	bytes via one or more messages, the destination sends a Stream Data
	Proceed (Addressed) message to the source, carrying the Source
	Stream ID and Destination Stream ID. This tells the source that
	there is enough buffer space available that another Max Buffer Size
	bytes can be sent.</P>
	<LI><P>When the last data has been sent, the source sends a Stream
	Data Complete message carrying the Source Stream ID and Destination
	Stream ID to indicate that all data has been sent. Optionally, this
	can carry a four-byte length of the stream data transferred for
	checking. A zero value, if present, means the length is unknown.
	When this message is received by the destination, the transfer is
	complete. 
	</P>
</UL>
<H3>CAN protocol</H3>
<P>On a CAN segment, the data limit is 8 bytes. This requires us to
use as little control information as possible, so that as many of
those eight bytes can be used for data as possible.</P>
<P>OpenLCB/S9.6 CAN frames can hold the source and destination
aliases in the header. A dedicated “stream data transfer” format
can also be coded entirely in the header. This then allows 8 bytes of
data per transfer if the Source Stream ID and Destination Stream ID
need not be carried. By specifying that only one stream can be
transferred on a CAN link between any two nodes, no Stream ID would
be needed. This is our chosen solution. Since a node knows that it's
originating the stream, this can be checked in advance for
point-to-point connections. Gateways might have to reject a stream
transfer in some cases, or use a virtual node ID.</P>
<P>If there's a need for more than two streams, another format could
be defined that puts a source or destination stream ID in the data
portion, transferring six bytes at a time. The sender could then use
that form if a 2<SUP>nd</SUP> stream is required.</P>
<H3>Implementation Notes</H3>
<P>The &quot;Stream Data Proceed&quot; from the destination is
clearance to send another buffer-size-worth of data. To achieve
better performance, the destination can send it before receiving the
entire buffer-size-worth of data, as soon as it has room to receive
what's already been OK'd plus one more buffer size. For example, a
destination with a 4kB buffer could reply with Max Buffer Size of 2K,
followed by an immediate Stream Data Proceed, to do single overlap of
the transfer. 
</P>
<P>Intermediate nodes need to be able to handle transfers, and
therefore need permission to lower the Max Buffer Size on the
outbound Stream Initiate Request message. The length in the returned
Stream Initiate Reply can't be changed, as the destination need to
know when to send clearance for another buffer's worth of data.</P>
<P STYLE="font-style: normal">A CAN ↔ Ethernet bridge might receive
several kilobytes of data from the Ethernet side at a time. It's then
responsible for breaking that up into CAN frames and forwarding it.
It can reduce the buffer size of transfers if need be to ensure
there's a place to store the data while this is done.</P>
<HR>
<P>This is SVN $Revision$ 
</P>
</BODY>
</HTML>