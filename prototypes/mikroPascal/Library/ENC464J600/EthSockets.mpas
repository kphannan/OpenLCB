unit EthSockets;

{.$DEFINE LOG_UART}

uses


NMRAnetDefinesShared,

  EthCommon,
  dspic_additional_string_library,
 // lib1_enc600_V3_5_b,
  definitions_ENC600;
  
const
  SOCKET_DISCONNECTED             = 0;
  SOCKET_WAITING_FOR_CONNECTION   = 1;
  SOCKET_CONNECTED                = 2;

  RESULT_OPEN_TCP_CONNECTION_OK = 0;
  RESULT_OPEN_TCP_CONNECTION_ARP_FAILED = 1;
  RESULT_OPEN_TCP_CONNECTION_NO_SOCKETS = 2;
  RESULT_OPEN_TCP_CONNECTION_SEND_FAILED = 3;
  
  MAX_SOCKET: byte                = 8;
  SOCKET_EXPIRE_TIME              = 120;   // In 100ms chuncks
  
  TCP: byte                       = 100;
  UDP: byte                       = 200;
  
type
  TSocket = record
    State_S         : word;        // 0 = Disconnected; 1 = Waiting for Connection; 2 = Connected
    source_port_S   : word;        // Port of the source (us)
    Dest_Ip         : TipHeader;    // Ip of the resource to send the data to
    Dest_Mac        : TmacHeader;   // MAC of the resource to send the data to
    dest_port_S     : word;        // Port of the resource to send the data to
    Seq_No_S        : dword;       // Sequence number for the TCP conversation with the other resource
    Ack_No_S        : dword;       // Ack sequence number for the TCP conversation with the other resource
    Wait_ACK        : word;        // Set to 1 if the socket is waiting for an ACK from the client (I think)
    Exp_Time        : word;        // Counter increments every 1s to allow auto destruction of socket after Exp_Time_Val has expired
    Exp_Time_Val    : word;        // Default set to 12 seconds, global set this value with the Set_TCP_TimeOut_Interval function
    Start_addr      : dword;       // The start of the valid data in the TCP_buf
    Stop_addr       : dword;       // The end of the valid data in the TCP_buf
    RAM_ROM         : word;
    Keep_Alive      : boolean;     // [DEFAULT] = True; Keeps the socket alive (until the Exp_Time_Val expires at least) when it is empty.  If false then once the data is sent the socket is released.
    TCP_buf         : string[1024];
  //  TxBuffer,
  //  RxBuffer        : array[1024] of Byte;
  end;

  TSocketManager = record
    TCP_Wait,
    UDP_Wait : word;                                                            // milliSeconds to wait for replies to TCP or UDP calls
    Socket : array[MAX_SOCKET] of TSocket;
    iLastOpenedSocked : word;                                                   // Last Socket index that was opened
  end;
  
// User functions
function Open_TCP_Connection(var DestIP : TipHeader; dest_port_S2, source_port_S2 : word) : Word;
function Close_TCP_Connection(var DestIP : TipHeader; dest_port_S2 : word) : boolean;
procedure EraseSockets;
function Search_Port(protocol : byte; port_ : word) : boolean;
function TCP_Find_Connection(var DestIP: TipHeader; DestPort: Word): Integer;
function TCP_Find_Any_Connection(var DestIP: TipHeader; DestPort: Word): Integer;
function TCP_Find_Free_Socket: Integer;
function UDP_Open_Port(port_u : word): boolean;
function TCP_Open_Port(port_t : word): boolean;
function UDP_Close_Port(port_u : word): boolean;
function TCP_Close_Port(port_t : word): boolean;
procedure Set_TCP_TimeOut_Interval(int_ : word);

// Internally used functions
procedure Sockets_Init_Internal;

// External functions
function ARP_Validate_IP(var ip_arp1 : TipHeader; var mac_arp : TmacHeader) : boolean; external;
function TCP_Send_Internal(TCP_Flag_T : byte; iSocket: Integer; Fragment : Boolean) : boolean; external;
procedure Do_EthernetProc(n : word); external;
procedure DisableInt; external;
procedure EnableInt; external;
  
var
  SocketManager: TSocketManager;
  TCP_Opened_Ports,
  UDP_Opened_Ports : array[MAX_SOCKET] of word;

implementation

procedure Sockets_Init_Internal;
begin
  Mem_Set(@TCP_Opened_Ports, 0, MAX_SOCKET*2); // clear ports word format
  Mem_Set(@UDP_Opened_Ports, 0, MAX_SOCKET*2); // clear ports word format
end;
  
//******************************************************************************
//* Name    : Open_TCP_Connection                                              *
//* Purpose : Open TCP Connection and Socket                                   *
//******************************************************************************
function Open_TCP_Connection(var DestIP : TipHeader; dest_port_S2, source_port_S2 : word) : Word;
var
  iSocket : Integer;
  dest_mac: TmacHeader;
begin
  {$IFDEF LOG_UART}UART1_Write_Text('Opening TCP Connection'+LF);{$ENDIF}
  Result := RESULT_OPEN_TCP_CONNECTION_OK;
  
  if not ARP_Validate_IP(DestIP, dest_mac) then
  begin
    Result := RESULT_OPEN_TCP_CONNECTION_ARP_FAILED;
    Exit;
  end;
  
  iSocket := TCP_Find_Connection(DestIP, dest_port_S2);

  if iSocket < 0 then
    iSocket := TCP_Find_Free_Socket;
  
  {$IFDEF LOG_UART}
  IntToStr(iSocket, s1);
  UART1_Write_Text('Socket = ' + s1 +LF);
  {$ENDIF}

  if iSocket < 0 then
  begin
    Result := RESULT_OPEN_TCP_CONNECTION_NO_SOCKETS;
    Exit;                                                // Out of sockets
  end;
  
  SocketManager.Socket[iSocket].State_S := SOCKET_WAITING_FOR_CONNECTION;   // Wait for Connection
  SocketManager.Socket[iSocket].SEQ_No_S := 12345;
  SocketManager.Socket[iSocket].ACK_No_S := 0;
  SocketManager.Socket[iSocket].dest_port_S := dest_port_S2;
  SocketManager.Socket[iSocket].source_port_S := source_port_S2;
  Mem_Cpy(@SocketManager.Socket[iSocket].Dest_Ip, @DestIP, 4);
  Mem_Cpy(@SocketManager.Socket[iSocket].Dest_Mac, @dest_mac, 6);
  SocketManager.Socket[iSocket].RAM_ROM := 0;
  SocketManager.Socket[iSocket].Exp_Time := 0;
  SocketManager.Socket[iSocket].Start_addr := 0;
  SocketManager.Socket[iSocket].Stop_addr := 0;
  SocketManager.Socket[iSocket].Keep_Alive := True;
  SocketManager.iLastOpenedSocked := iSocket;

  if not TCP_Send_Internal(SYN_S, iSocket, False) then
  begin
    Result := RESULT_OPEN_TCP_CONNECTION_SEND_FAILED;
    SocketManager.Socket[iSocket].State_S := SOCKET_DISCONNECTED;
    SocketManager.iLastOpenedSocked := 255;
  end;
end;

//******************************************************************************
//* Name    : Close_TCP_Connection                                             *
//* Purpose : Close TCP Connection and Socket                                  *
//******************************************************************************
function Close_TCP_Connection(var DestIP : TipHeader; dest_port_S2 : word) : boolean;
var
  CountBuf : word;
  iSocket : byte;
begin
  iSocket := TCP_Find_Connection(DestIP, dest_port_s2);
  if iSocket >= 0 then
  begin
    {$IFDEF LOG_UART}UART1_Write_Text('Closing TCP: Found Socket'+LF);{$ENDIF}
    if SocketManager.Socket[iSocket].State_S <> SOCKET_DISCONNECTED then
    begin
      {$IFDEF LOG_UART}UART1_Write_Text('Closing TCP: Found Open or Waiting Socket, sending termination FIN+ACK'+LF);{$ENDIF}
      SocketManager.Socket[iSocket].RAM_ROM := 0;
      SocketManager.Socket[iSocket].Start_addr := 0;
      SocketManager.Socket[iSocket].Stop_addr := 0;
      Result := TCP_Send_Internal(FIN_S + ACK_S, iSocket, False);      // Sets Wait_ACK = 1
    end else
    begin
      {$IFDEF LOG_UART}UART1_Write_Text('Closing TCP: Found Socket, it was already Closed we are out of here'+LF);{$ENDIF}
      Result := True;
      Exit;
    end;
  end else  // no sockets available
  begin
    {$IFDEF LOG_UART}UART1_Write_Text('Closing TCP: No matching Sockets found, we are out of here'+LF);{$ENDIF}
    Result := False;
    Exit;
  end;

  // Wait for the ACK
  TickCounter10 := 0;
  CountBuf := 0;
  while CountBuf < SocketManager.TCP_Wait do
  begin
    Do_EthernetProc(1);
    if SocketManager.Socket[iSocket].Wait_Ack = 0 then
  //  if SocketManager.Socket[i].State_S = SOCKET_DISCONNECTED then       // THIS WILL NEVER WORK AS THE RECEIVE SIDE HAS WAIT_ACK SET BUT IT HAS NOT FLAG TO UNDERSTAND THIS IS A REPONSE TO A SHUT DOWN>>>>>>>
    begin
      {$IFDEF LOG_UART}UART1_Write_Text('Closing TCP: ACK reply detected and Socket is Disconnected'+LF);{$ENDIF}
      Break;
    end;
    DisableInt;
    CountBuf := TickCounter10;
    EnableInt;
  end;
  
  {$IFDEF LOG_UART}
  if CountBuf >= SocketManager.TCP_Wait then
    UART1_Write_Text('Closing TCP: Did not detect ACK reply, closing Socket anyway'+LF);
  {$ENDIF}
  
  // Per the Spec we are suppose to wait 4 seconds before opening again....
  
  SocketManager.Socket[iSocket].State_S := SOCKET_DISCONNECTED;
  SocketManager.Socket[iSocket].Keep_Alive := False;
end;

  
procedure EraseSockets;
var j : byte;
begin
  j := 0;
  while j < MAX_SOCKET do
    begin
      SocketManager.Socket[j].State_S := SOCKET_DISCONNECTED;
      SocketManager.Socket[j].source_port_S := 0;
      Mem_Set(@SocketManager.Socket[j].Dest_Ip, 0, 4);
      Mem_Set(@SocketManager.Socket[j].Dest_Mac, 0, 6);
      SocketManager.Socket[j].dest_port_S := 0;
      SocketManager.Socket[j].SEQ_No_S := 0;
      SocketManager.Socket[j].ACK_No_S := 0;
      SocketManager.Socket[j].Wait_ACK := 0;
      SocketManager.Socket[j].Exp_Time := 0;
      SocketManager.Socket[j].Exp_Time_Val := SOCKET_EXPIRE_TIME;
      SocketManager.Socket[j].Start_addr := 0;
      SocketManager.Socket[j].Stop_addr := 0;
      SocketManager.Socket[j].RAM_ROM := 0;
      SocketManager.Socket[j].Keep_Alive := false;
      SocketManager.Socket[j].TCP_buf := '';
      inc(j);
    end;
end;

function TCP_Find_Free_Socket: Integer;
var
  i: Integer;
begin
  Result := -1;
  i := 0;
  while i < MAX_SOCKET do  // search for free socket
  begin
    if SocketManager.Socket[i].State_S = SOCKET_DISCONNECTED then
    begin
      Result := i;
      Break;
    end;
    inc(i);
  end;
end;

function TCP_Find_Connection(var DestIP: TipHeader; DestPort: Word): Integer;
var
  i: Integer;
begin
  Result := -1;
  i := 0;
  while i < MAX_SOCKET do  // search for opened socket
  begin
    if (SocketManager.Socket[i].State_S = SOCKET_CONNECTED) then
      if (SocketManager.Socket[i].dest_port_S = DestPort) then
        if (Mem_Cmp(@DestIP, @SocketManager.Socket[i].Dest_Ip, 4) = 0) then
        begin
          Result := i;
          Break; // if connected
        end;
    inc(i);
  end;
end;

function TCP_Find_Any_Connection(var DestIP: TipHeader; DestPort: Word): Integer;
var
  i: Integer;
begin
  Result := -1;
  i := 0;
  while i < MAX_SOCKET do  // search for opened socket
  begin
    if (SocketManager.Socket[i].State_S <> SOCKET_DISCONNECTED) then
      if (SocketManager.Socket[i].dest_port_S = DestPort) then
        if (Mem_Cmp(@DestIP, @SocketManager.Socket[i].Dest_Ip, 4) = 0) then
        begin
          Result := i;
          Break; // if connected
        end;
    inc(i);
  end;
end;

function Search_Port(protocol : byte; port_ : word) : boolean;
var
  i : byte;
  pt : ^word;
begin
  result := false;
  if port_ = 0 then exit;
  if protocol = TCP then
    pt := @TCP_Opened_Ports
  else
    pt := @UDP_Opened_Ports;
  i := 0;
  while i < MAX_SOCKET do
    begin
      if pt^ = port_ then
        begin
          result := true;
          exit;
        end;
      pt := pt + 1;
      inc(i);
    end;
end;

function Close_Port(protocol : byte; port_ : word) : boolean;
var i : byte;
    pt : ^word;
begin
  result := false;
  if port_ = 0 then exit;
  if protocol = TCP then pt := @TCP_Opened_Ports
  else pt := @UDP_Opened_Ports;
  i := 0;
  while i < MAX_SOCKET do
    begin
      if pt^ = port_ then
        begin
          pt^ := 0;
          result := true;
          exit;
        end;
      pt := pt + 1;
      inc(i);
    end;
end;

function Open_Port(protocol_ : byte; port__ : word) : boolean;
var i : byte;
    pt : ^word;
begin
  result := false;
  if port__ = 0 then exit;
  if Search_Port(protocol_, port__) <> 0 then
    begin
      result := true;
      exit;
    end;
  if protocol_ = TCP then pt := @TCP_Opened_Ports
  else pt := @UDP_Opened_Ports;
  i := 0;
  while i < MAX_SOCKET do
    begin
      if pt^ = 0 then
        begin
          pt^ := port__;
          result := true;
          exit;
        end;
      pt := pt + 1;
      inc(i);
    end;
end;

function UDP_Open_Port(port_u : word): boolean;
begin
  Result := Open_Port(UDP, port_u);
end;

function TCP_Open_Port(port_t : word): boolean;
begin
  Result := Open_Port(TCP, port_t);
end;

function UDP_Close_Port(port_u : word): boolean;
begin
  Result := Close_Port(UDP, port_u);
end;

function TCP_Close_Port(port_t : word): boolean;
begin
  Result := Close_Port(TCP, port_t);
end;
  
procedure Set_TCP_TimeOut_Interval(int_ : word);
var 
  j : byte;
begin
  j := 0;
  while j < MAX_SOCKET do
    begin
      SocketManager.Socket[j].Exp_Time_Val := int_;
      inc(j);
    end;
end;

end.