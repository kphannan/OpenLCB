unit EthSockets;

{.$DEFINE LOG_UART}

uses


NMRAnetDefinesShared,

  EthCommon,
  dspic_additional_string_library,
  lib1_enc600_V3_5_b,
 // lib1_enc600_V3_5_b,
  definitions_ENC600;
  
const

  RESULT_OPEN_TCP_CONNECTION_OK = 0;
  RESULT_OPEN_TCP_CONNECTION_ARP_FAILED = 1;
  RESULT_OPEN_TCP_CONNECTION_NO_SOCKETS = 2;
  RESULT_OPEN_TCP_CONNECTION_SEND_FAILED = 3;
  
  MAX_SOCKET: byte                = 4;
  MAX_DATA_BUFFER_LENGTH          = 1024;
  MAX_TCP_RETRANSMIT_COUNT        = 3;                                          // Number of times to try to retransmit the TCP packet waiting for an ACK
  
  SOCKET_EXPIRE_TIME              = $FFFF;   // In 100ms chunks
  
  PROTOCOL_ICMP                  = 1;
  PROTOCOL_IGMP                  = 2;
  PROTOCOL_TCP                   = 6;
  PROTOCOL_UDP                   = 17;
  
const
  SOCKET_STATE_DISCONNECTED           = 0;
  SOCKET_STATE_CONNECT                = 1;
  SOCKET_STATE_WAITING_FOR_SYN_ACK    = 2;
  SOCKET_STATE_WAITING_FOR_SYN        = 3;
  SOCKET_STATE_CONNECTED              = 4;
  SOCKET_STATE_DISCONNECT             = 5;
  SOCKET_STATE_WAITING_FOR_FIN_ACK    = 6;
  SOCKET_STATE_WAITING_FOR_FIN        = 7;
  SOCKET_STATE_RESET                  = 8;
  
  SOCKET_FLAG_RECEIVED_FIN            = 0;  // Order matters it maps to the TCP Flags
  SOCKET_FLAG_RECEIVED_SYN            = 1;
  SOCKET_FLAG_RECEIVED_RST            = 2;
  SOCKET_FLAG_RECEIVED_PSH            = 3;
  SOCKET_FLAG_RECEIVED_ACK            = 4;
  SOCKET_FLAG_RECEIVED_URG            = 5;
  
  SOCKET_FLAG_ALLOCATED               = 6;
  SOCKET_FLAG_CONNECTED               = 7;   // Bit 1
  SOCKET_FLAG_WAITING_FOR_ACK         = 8;   // Bit 2, 0 if not waiting for an ACK; 1 if Waiting for an ACK
  SOCKET_FLAG_FINISH                  = 9;   // Bit 3, Flagged to finish and disconnect
  SOCKET_FLAG_ACK_ERROR               = 10;   // Bit 4, Returned ACK had an invalid SEQ value
  
  
type
  TSocket = record
    iStateMachine   : Word;        // See SOCKET_STATE_xxxx constants
    Flags           : Word;        // See SOCKET_FLAG_xxxx contants
    SourcePort      : Word;        // Port of the source (us)
    DestIP          : TIPAddress;    // Ip of the resource to send the data to
    DestMAC         : TMACAddress;   // MAC of the resource to send the data to
    DestPort        : Word;        // Port of the resource to send the data to
    Seq_No_S        : DWord;       // Sequence number for the TCP conversation with the other resource
    Ack_No_S        : DWord;       // Ack sequence number for the TCP conversation with the other resource
    Wait_ACK        : Word;        // Set to 1 if the socket is waiting for an ACK from the client
    Exp_Time        : Word;        // Counter increments every 1s to allow auto destruction of socket after Exp_Time_Val has expired
    Exp_Time_Val    : Word;        // Default set to 12 seconds, global set this value with the Set_TCP_TimeOut_Interval function
    Start_addr      : DWord;       // The start of the valid data in the TCP_buf
    Stop_addr       : DWord;       // The end of the valid data in the TCP_buf
    RAM_ROM         : Word;
    Keep_Alive      : Boolean;     // [DEFAULT] = True; Keeps the socket alive (until the Exp_Time_Val expires at least) when it is empty.  If false then once the data is sent the socket is released.
    TCP_buf         : string[MAX_DATA_BUFFER_LENGTH];
  end;
  
const
  SOCKET_TX_FLAG_LOADED       = 0;                                              // Bit 0, 0 = transmitter has nothing to transmit; 1 = transmitter is loaded and ready (or already) transmitting
  SOCKET_TX_FLAG_TRANSMITTING = 1;                                              // Bit 1, 0 = not in the middle of a transmission; 1 = in the middle of a transmission

type
  TSocketTransmitter = record
    Flags: Word;                                                                // State of the TCP Transmitter see TX_FLAG_xxxx constants
    PhysicalLayerHeader: TPhysicalLayerHeader;                                  // Current info for the Physical Layer of the current transmission
    IPHeader: TIPHeader;                                                        // Current info for the IP Layer of the current transmission
    TCPHeader: TTCPHeader;                                                      // Current info for the TCP Layer of the current transmission
    DataLength: Word;                                                           // Length of the data Buffer
    DataBuffer: string[MAX_DATA_BUFFER_LENGTH];                                 // Raw data to send, note this does not have to be a string
    TimeOutCount: Word;                                                         // Timeout counter waiting for the TCP_Wait time to be met or an ACK to be received
    RetransmitCount: Word;                                                      // Number of times the Data has been retransmitted up to MAX_TCP_RETRANSMIT_COUNT
    Watchdog: Word;                                                             // Increments each time the Do Transmit function is called, detects if the ENC never signals the packet was sent.  Allows us to not get hungup if a glitch occurs in the ENC
  end;

  TSocketManager = record
    TCP_Wait,
    UDP_Wait : Word;                                                            // milliSeconds to wait for replies to TCP or UDP calls
    Socket : array[MAX_SOCKET] of TSocket;
    Transmitter: TSocketTransmitter;
    IdentificationCounter: Word;                                                // Unique ID for fragments
    iLastProcessedSocket: Integer;                                              // Last index of the Socket that was processed in the process loop
    iLastOpenedSocked : Word;                                                   // Last Socket index that was opened
    OpenedSockets: Word;                                                        // Number of Opened Sockets
  end;
  
// User functions
function TCP_Open_Connection(var DestIP : TIPAddress; DestPort, SourcePort : Word) : Word;
function TCP_Close_Connection(var DestIP : TIPAddress; DestPort : Word) : Boolean;
function TCP_Find_Connection(var DestIP: TIPAddress; DestPort: Word): Integer;
function TCP_Find_Any_Connection(var DestIP: TIPAddress; DestPort: Word): Integer;
function TCP_Find_Free_Socket: Integer;
procedure TCP_ClearTransmitter;
procedure TCP_Set_TimeOut_Interval_Global(NewTimeOut : Word);

function Port_Find(Protocol: Word; Port: Word) : Boolean;
function Port_Open_UDP(Port: Word): Boolean;
function Port_Open_TCP(Port: Word): Boolean;
function Port_Close_UDP(Port: Word): Boolean;
function Port_Close_TCP(Port: Word): Boolean;

procedure TCP_LoadPhysicalLayerHeader(var PhyBuffer: TPhysicalLayerHeader; var SourceMAC: TMACAddress; var DestMAC: TMACAddress);
procedure TCP_LoadIPLayerHeader(var IPBuffer: TIPHeader; var SourceIP: TIPAddress; var DestIP: TIPAddress; DataLen: Word; Protocol: Word);
procedure TCP_LoadTCPLayerHeader(var TCPBuffer: TTCPHeader; SourcePort, DestPort: Word; SequenceNumber, AckNumber: DWord; Flags: Word);
procedure TCP_LoadTransmitter(var Socket: TSocket; IPFlags: Word; DataLen: Word; SendData: ^Byte; Protocol: Word);

function TransmitterEmpty: Boolean;

procedure PrintTransmitterHeaders;

// Internally used functions
procedure Sockets_Init_Internal;

// External functions
function ARP_Validate_IP(var ip_arp1 : TIPAddress; var mac_arp : TMACAddress) : Boolean; external;
function TCP_Send_Internal(TCP_Flag_T : byte; iSocket: Integer) : Boolean; external;
procedure Do_EthernetProc(n : Word); external;
procedure DisableInt; external;
procedure EnableInt; external;
  
var
  SocketManager: TSocketManager;
  TCP_Opened_Ports,
  UDP_Opened_Ports : array[MAX_SOCKET] of Word;

implementation

procedure InitSocket(iSocket: Integer);
begin
  SocketManager.Socket[iSocket].Flags := 0;
  SocketManager.Socket[iSocket].iStateMachine := SOCKET_STATE_DISCONNECTED;
  SocketManager.Socket[iSocket].SourcePort := 0;
  Mem_Set(@SocketManager.Socket[iSocket].DestIP, 0, 4);
  Mem_Set(@SocketManager.Socket[iSocket].DestMAC, 0, 6);
  SocketManager.Socket[iSocket].DestPort := 0;
  SocketManager.Socket[iSocket].SEQ_No_S := 0;
  SocketManager.Socket[iSocket].ACK_No_S := 0;
  SocketManager.Socket[iSocket].Wait_ACK := 0;
  SocketManager.Socket[iSocket].Exp_Time := 0;
  SocketManager.Socket[iSocket].Exp_Time_Val := SOCKET_EXPIRE_TIME;
  SocketManager.Socket[iSocket].Start_addr := 0;
  SocketManager.Socket[iSocket].Stop_addr := 0;
  SocketManager.Socket[iSocket].RAM_ROM := 0;
  SocketManager.Socket[iSocket].Keep_Alive := false;
  SocketManager.Socket[iSocket].TCP_buf := '';
  SocketManager.OpenedSockets := 0;
end;

procedure PrintTransmitterHeaders;
begin
  Mac2Str(SocketManager.Transmitter.PhysicalLayerHeader.SourceMacAddress, s1);
  UART1_Write_Text('Source MAC Address: ' + s1);
  Mac2Str(SocketManager.Transmitter.PhysicalLayerHeader.DestMacAddress, s1);
  UART1_Write_Text('Destination MAC Address: ' + s1);
  WordToStr( SocketManager.Transmitter.PhysicalLayerHeader.Protocol, s1);
  UART1_Write_Text('Phy Protocol: ' + s1);
end;

function TransmitterEmpty: Boolean;
begin
  Result := SocketManager.Transmitter.Flags.SOCKET_TX_FLAG_LOADED = 0
end;

procedure Sockets_Init_Internal;
var
  iSocket: Integer;
begin
  Mem_Set(@TCP_Opened_Ports, 0, MAX_SOCKET*2); // clear ports Word format
  Mem_Set(@UDP_Opened_Ports, 0, MAX_SOCKET*2); // clear ports Word format
  SocketManager.iLastProcessedSocket := 0;
  SocketManager.Transmitter.Flags := 0;
  SocketManager.IdentificationCounter := 1000;
  iSocket := 0;
  while iSocket < MAX_SOCKET do
  begin
    InitSocket(iSocket);
    Inc(iSocket)
  end
end;

procedure TCP_ClearTransmitter;
begin
  SocketManager.Transmitter.Flags.SOCKET_TX_FLAG_TRANSMITTING := 0;       // Can't find a matching Socket
  SocketManager.Transmitter.Flags.SOCKET_TX_FLAG_LOADED := 0;
end;
  
//******************************************************************************
// Name    : TCP_Open_Connection
// Purpose : Start the opening process.  The caller must poll the Connection to find
//           when it actually becomes open
//******************************************************************************
function TCP_Open_Connection(var DestIP : TIPAddress; DestPort, SourcePort : Word) : Word;
var
  iSocket : Integer;
  DestMAC: TMACAddress;
begin
  {$IFDEF LOG_UART}UART1_Write_Text('Opening TCP Connection'+LF);{$ENDIF}
  Result := RESULT_OPEN_TCP_CONNECTION_OK;
  
  if ARP_Validate_IP(DestIP, DestMAC) then                                      // Does the node exist on the network?
  begin
    iSocket := TCP_Find_Connection(DestIP, DestPort);                           // Look for an open socket
    if iSocket < 0 then                                                         // Can't find one, so begin the open process
    begin
      iSocket := TCP_Find_Free_Socket;
      if iSocket >= 0 then
      begin
        InitSocket(iSocket);
        SocketManager.Socket[iSocket].Flags.SOCKET_FLAG_ALLOCATED := 1;
        SocketManager.Socket[iSocket].iStateMachine := SOCKET_STATE_CONNECT;
        SocketManager.Socket[iSocket].SEQ_No_S := 12345;
        SocketManager.Socket[iSocket].DestPort := DestPort;
        SocketManager.Socket[iSocket].SourcePort := SourcePort;
        Mem_Cpy(@SocketManager.Socket[iSocket].DestIP, @DestIP, 4);
        Mem_Cpy(@SocketManager.Socket[iSocket].DestMAC, @DestMAC, 6);
        SocketManager.Socket[iSocket].Keep_Alive := True;
        Inc(SocketManager.OpenedSockets);
      end else
        Result := RESULT_OPEN_TCP_CONNECTION_NO_SOCKETS;  // Out of sockets
    end
  end else
    Result := RESULT_OPEN_TCP_CONNECTION_ARP_FAILED;    // ARP Failed
end;

//******************************************************************************
// Name    : TCP_Close_Connection
// Purpose : Signals the TCP Connection and Socket to finish and close, note the
//            actual closing happens when it can
//******************************************************************************
function TCP_Close_Connection(var DestIP : TIPAddress; DestPort : Word) : Boolean;
var
  iSocket : Integer;
begin
  iSocket := TCP_Find_Any_Connection(DestIP, DestPort);
  if iSocket >= 0 then
  begin
    SocketManager.Socket[iSocket].Flags.SOCKET_FLAG_FINISH := 1;
    Result := True
  end
end;

//******************************************************************************
// Name    : TCP_Find_Free_Socket
// Purpose : Searches for a free socket, returns the index into the Socket Array
//           or -1 if none can be found
//******************************************************************************
function TCP_Find_Free_Socket: Integer;
var
  iSocket: Integer;
begin
  Result := -1;
  iSocket := 0;
  while iSocket < MAX_SOCKET do  // search for free socket
  begin
    if SocketManager.Socket[iSocket].Flags.SOCKET_FLAG_ALLOCATED = 0 then
    begin
      Result := iSocket;
      Break;
    end;
    Inc(iSocket);
  end;
end;

//******************************************************************************
// Name    : TCP_Find_Connection
// Purpose : Searches for a connected socket (does NOT include sockets in the
//           process of a SYN volley
//******************************************************************************
function TCP_Find_Connection(var DestIP: TIPAddress; DestPort: Word): Integer;
var
  iSocket: Integer;
begin
  Result := -1;
  iSocket := 0;
  while iSocket < MAX_SOCKET do  // search for opened socket
  begin
    if (SocketManager.Socket[iSocket].Flags.SOCKET_FLAG_CONNECTED = 1) then           // is the socket connected?
      if (SocketManager.Socket[iSocket].DestPort = DestPort) then                     // do the destination ports match
        if (Mem_Cmp(@DestIP, @SocketManager.Socket[iSocket].DestIP, 4) = 0) then      // does the destination IP addresses match?
        begin
          Result := iSocket;
          Break; // if connected
        end;
    Inc(iSocket);
  end;
end;

//******************************************************************************
// Name    : TCP_Find_Any_Connection
// Purpose : Searches for a socket that is in any state of connection and allocated
//******************************************************************************
function TCP_Find_Any_Connection(var DestIP: TIPAddress; DestPort: Word): Integer;
var
  iSocket: Integer;
begin
  Result := -1;
  iSocket := 0;
  while iSocket < MAX_SOCKET do  // search for opened socket
  begin
    if (SocketManager.Socket[iSocket].Flags.SOCKET_FLAG_ALLOCATED = 1) then
      if (SocketManager.Socket[iSocket].DestPort = DestPort) then
        if (Mem_Cmp(@DestIP, @SocketManager.Socket[iSocket].DestIP, 4) = 0) then
        begin
          Result := iSocket;
          Break; // if connected
        end;
    Inc(iSocket);
  end;
end;

//******************************************************************************
// Name    : TCP_Set_TimeOut_Interval_Global
// Purpose : Sets the timeout for all connections
//******************************************************************************
procedure TCP_Set_TimeOut_Interval_Global(NewTimeout : Word);
var
  iSocket: Integer;
begin
  iSocket := 0;
  while iSocket < MAX_SOCKET do
    begin
      SocketManager.Socket[iSocket].Exp_Time_Val := NewTimeout;
      Inc(iSocket)
    end;
end;

//******************************************************************************
// Name    : Port_Find
// Purpose : Searches for a Port that is allocated to a protocol (TCP or UDP)
//******************************************************************************
function Port_Find(Protocol: Word; Port: Word) : Boolean;
var
  iPort : Integer;
  PortPtr : ^Word;
begin
  Result := false;
  if Port > 0  then
  begin
    if Protocol = PROTOCOL_TCP then
      PortPtr := @TCP_Opened_Ports
    else
      PortPtr := @UDP_Opened_Ports;
    iPort := 0;
    while iPort < MAX_SOCKET do
    begin
      if PortPtr^ = Port then
      begin
        Result := true;
        Exit;
      end;
      PortPtr := PortPtr + 1;
      Inc(iPort);
    end
  end
end;

//******************************************************************************
// Name    : Port_Close
// Purpose : Closes a TCP or UDP Port
//******************************************************************************
function Port_Close(Protocol : byte; Port : Word) : Boolean;
var 
  iPort : Integer;
  PortPtr : ^Word;
begin
  Result := false;
  if Port > 0 then
  begin
    if Protocol = PROTOCOL_TCP then
      PortPtr := @TCP_Opened_Ports
    else
      PortPtr := @UDP_Opened_Ports;
    iPort := 0;
    while iPort < MAX_SOCKET do
    begin
      if PortPtr^ = Port then
      begin
        PortPtr^ := 0;
        Result := true;
        Exit;
      end;
      PortPtr := PortPtr + 1;
      Inc(iPort);
    end;
  end
end;

//******************************************************************************
// Name    : Port_Open
// Purpose : Opens a TCP or UDP Port
//******************************************************************************
function Port_Open(Protocol : Word; Port : Word) : Boolean;
var 
  iPort: Integer;
  PortPtr : ^Word;
begin
  Result := False;
  if Port_Find(Protocol, Port) = 0 then
  begin
    if Protocol = PROTOCOL_TCP then
      PortPtr := @TCP_Opened_Ports
    else
      PortPtr := @UDP_Opened_Ports;
    iPort := 0;
    while iPort < MAX_SOCKET do                                                     // Look for the first empty (Port = 0) slot
    begin
      if PortPtr^ = 0 then
      begin
        PortPtr^ := Port;
        Result := true;
        Exit;
      end;
      PortPtr := PortPtr + 1;
      Inc(iPort);
    end;
  end else
    Result := True
end;

function Port_Open_UDP(Port : Word): Boolean;
begin
  Result := Port_Open(PROTOCOL_UDP, Port);
end;

function Port_Open_TCP(Port : Word): Boolean;
begin
  Result := Port_Open(PROTOCOL_TCP, Port);
end;

function Port_Close_UDP(Port : Word): Boolean;
begin
  Result := Port_Close(PROTOCOL_UDP, Port);
end;

function Port_Close_TCP(Port : Word): Boolean;
begin
  Result := Port_Close(PROTOCOL_TCP, Port);
end;

procedure TCP_LoadPhysicalLayerHeader(var PhyBuffer: TPhysicalLayerHeader; var SourceMAC: TMACAddress; var DestMAC: TMACAddress);
begin
  memcpy(@PhyBuffer.SourceMacAddress, @SourceMAC, MAC_ADDRESS_LEN);
  memcpy(@PhyBuffer.DestMacAddress, @DestMAC, MAC_ADDRESS_LEN);
  PhyBuffer.Protocol := $0800;              // IP
end;

procedure TCP_LoadIPLayerHeader(var IPBuffer: TIPHeader; var SourceIP: TIPAddress; var DestIP: TIPAddress; DataLength: Word; Protocol: Word);
begin
  IPBuffer.Version := 4;                                                        // IPv4
  IPBuffer.IHL := 5;                                                            // Internet Header Length, 5 - 32bit blocks = no options
  IPBuffer.DSCP := 0 ;                                                          // Differentiated Services Code Point
  IPBuffer.ECN := 0;                                                            // Explicit Congestion Notification
  IPBuffer.TotalLength := DataLength + IP_HEADER_SIZE + TCP_HEADER_SIZE;
  Inc(SocketManager.IdentificationCounter);
  IPBuffer.Identification := SocketManager.IdentificationCounter;
  IPBuffer.Flags := %010;                                                       // Don't Fragment (DF)
  IPBuffer.FragmentOffset := 0;
  IPBuffer.TimeToLive := 128;                                                   // 128 Seconds
  IPBuffer.Protocol := Protocol;
  memcpy(@IPBuffer.SourceIPAddress, @SourceIP, IP_ADDRESS_LEN);
  memcpy(@IPBuffer.DestIPAddress, @DestIP, IP_ADDRESS_LEN);
end;

procedure TCP_LoadTCPLayerHeader(var TCPBuffer: TTCPHeader; SourcePort, DestPort: Word; SequenceNumber, AckNumber: DWord; Flags: Word);
begin
  TCPBuffer.SourcePort := SourcePort;
  TCPBuffer.DestPort := DestPort;
  TCPBuffer.SequenceNumber := SequenceNumber;
  TCPBuffer.AckNumber := AckNumber;
  TCPBuffer.Flags := Flags;
  TCPBuffer.WindowSize := 0;
  TCPBuffer.UrgentPtr := 0;
end;

procedure TCP_LoadTransmitter(var Socket: TSocket; IPFlags: Word; DataLen: Word; SendData: ^Byte; Protocol: Word);
begin
  TCP_LoadPhysicalLayerHeader(SocketManager.Transmitter.PhysicalLayerHeader, Settings.eth_mac, Socket.DestMAC);
  TCP_LoadIPLayerHeader(SocketManager.Transmitter.IPHeader, Settings.eth_ip_addr, Socket.DestIP, DataLen, Protocol);
  TCP_LoadTCPLayerHeader(SocketManager.Transmitter.TCPHeader, Socket.SourcePort, Socket.DestPort, Socket.Seq_No_S, Socket.Ack_No_S, IPFlags);
  if SendData <> nil then
    memcpy(@SocketManager.Transmitter.DataBuffer, SendData, DataLen);
  SocketManager.Transmitter.Flags.SOCKET_TX_FLAG_LOADED := 1;
  SocketManager.Transmitter.Flags.SOCKET_TX_FLAG_TRANSMITTING := 0;
end;

end.