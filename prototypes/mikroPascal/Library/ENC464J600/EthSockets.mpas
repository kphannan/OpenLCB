unit EthSockets;

{.$DEFINE LOG_UART}

uses


NMRAnetDefinesShared,

  EthCommon,
  dspic_additional_string_library,
  lib1_enc600_V3_5_b,
 // lib1_enc600_V3_5_b,
  definitions_ENC600;
  
const

  RESULT_OPEN_TCP_CONNECTION_OK = 0;
  RESULT_OPEN_TCP_CONNECTION_ARP_FAILED = 1;
  RESULT_OPEN_TCP_CONNECTION_NO_SOCKETS = 2;
  RESULT_OPEN_TCP_CONNECTION_SEND_FAILED = 3;
  
  MAX_SOCKET: byte                = 4;
  MAX_DATA_BUFFER_LENGTH          = 1024;
  MAX_TCP_RETRANSMIT_COUNT        = 3;                                          // Number of times to try to retransmit the TCP packet waiting for an ACK
  
  SOCKET_EXPIRE_TIME_DEFAULT      = $000A;   // Release the Socket after 10 seconds
  MAX_TCP_RESEND_ATTEMPTS = 5;               // Attempt to resend 5 times before giving up
  MAX_TCP_RESEND_TIMEOUT = 2;                // Resend TCP packet if no response within 2 seconds
  
  PROTOCOL_ICMP                  = 1;
  PROTOCOL_IGMP                  = 2;
  PROTOCOL_TCP                   = 6;
  PROTOCOL_UDP                   = 17;
  
const
  SOCKET_STATE_DISCONNECTED           = 0;
  SOCKET_STATE_CONNECT                = 1;
  SOCKET_STATE_CONNECT_SEND           = 2;
  SOCKET_STATE_WAITING_FOR_SYN_ACK    = 3;
  SOCKET_STATE_WAITING_FOR_SYN        = 4;
  SOCKET_STATE_CONNECTED              = 5;
  SOCKET_STATE_DISCONNECT             = 6;
  SOCKET_STATE_WAITING_FOR_FIN_ACK    = 7;
  SOCKET_STATE_WAITING_FOR_FIN        = 8;
  SOCKET_STATE_ERROR                  = 9;
  SOCKET_STATE_RESET                  = 10;
  
  SOCKET_FLAG_RECEIVED_FIN            = 0;  // Order matters it maps to the TCP Flags
  SOCKET_FLAG_RECEIVED_SYN            = 1;
  SOCKET_FLAG_RECEIVED_RST            = 2;
  SOCKET_FLAG_RECEIVED_PSH            = 3;
  SOCKET_FLAG_RECEIVED_ACK            = 4;
  SOCKET_FLAG_RECEIVED_URG            = 5;
  
  SOCKET_FLAG_ALLOCATED               = 6;
  SOCKET_FLAG_CONNECTED               = 7;    // Bit 1
//  SOCKET_FLAG_WAITING_FOR_ACK         = 8;    // Bit 2, 0 if not waiting for an ACK; 1 if Waiting for an ACK
  SOCKET_FLAG_FINISH                  = 9;    // Bit 3, Flagged to finish and disconnect
  SOCKET_FLAG_ACK_ERROR               = 10;   // Bit 4, Returned ACK had an invalid SEQ value
  
  
type
  TSocket = record
    iStateMachine   : Word;          // See SOCKET_STATE_xxxx constants
    Flags           : Word;          // See SOCKET_FLAG_xxxx contants
    SourcePort      : Word;          // Port of the source (us)
    DestIP          : TIPAddress;    // Ip of the resource to send the data to
    DestMAC         : TMACAddress;   // MAC of the resource to send the data to
    DestPort        : Word;          // Port of the resource to send the data to
    SequenceNumber  : DWord;         // Sequence number for the TCP conversation with the other resource
    AckNumber       : DWord;         // Ack sequence number for the TCP conversation with the other resource
    Identification  : Word;          // ID of the packet to handle fragmentation (if allowed)
    ExpireTimeCount : Word;          // Counter increments every 1s to allow auto destruction of socket after ExpireTimeMax has expired
    ExpireTimeMax   : Word;          // Default set to 12 seconds, global set this value with the Set_TCP_TimeOut_Interval function
    ResendAttempts  : Word;          // Number of times the Socket has tried to send it payload
    ResendTimeCount : Word;          // counter increments every Nms waiting for a reply (if needed), if the timer times out and the Resend Count is less than MAX_RESEND_TRIES the packet is resetn
    Start_addr      : DWord;         // The start of the valid data in the TCP_buf
    Stop_addr       : DWord;         // The end of the valid data in the TCP_buf
    RAM_ROM         : Word;
    Keep_Alive      : Boolean;       // [DEFAULT] = True; Keeps the socket alive (until the ExpireTimeMax expires at least) when it is empty.  If false then once the data is sent the socket is released.
    TCP_buf         : string[MAX_DATA_BUFFER_LENGTH];
  end;

  TSocketManager = record
    TCP_Wait,
    UDP_Wait : Word;                                                            // milliSeconds to wait for replies to TCP or UDP calls
    Socket : array[MAX_SOCKET] of TSocket;
    iLastProcessedSocket: Integer;                                              // Last index of the Socket that was processed in the process loop
    iLastOpenedSocked : Word;                                                   // Last Socket index that was opened
  end;
  
// User functions
function TCP_Open_Connection(var DestIP : TIPAddress; DestPort, SourcePort : Word) : Word;
function TCP_Close_Connection(var DestIP : TIPAddress; DestPort : Word) : Boolean;
function TCP_Find_Connection(var DestIP: TIPAddress; DestPort: Word): Integer;
function TCP_Find_Any_Connection(var DestIP: TIPAddress; DestPort: Word): Integer;
function TCP_Find_Free_Socket: Integer;
procedure TCP_Set_TimeOut_Interval_Global(NewTimeOut : Word);

function Port_Find(Protocol: Word; Port: Word) : Boolean;
function Port_Open_UDP(Port: Word): Boolean;
function Port_Open_TCP(Port: Word): Boolean;
function Port_Close_UDP(Port: Word): Boolean;
function Port_Close_TCP(Port: Word): Boolean;

procedure PrintSocket(var Socket: TSocket);

// Internally used functions
procedure Sockets_Init_Internal;

// External functions
function ARP_Validate_IP(var ip_arp1 : TIPAddress; var mac_arp : TMACAddress) : Boolean; external;
function TCP_Send_Internal(TCP_Flag_T : byte; iSocket: Integer) : Boolean; external;
procedure Do_EthernetProc(n : Word); external;
procedure DisableInt; external;
procedure EnableInt; external;
  
var
  SocketManager: TSocketManager;
  TCP_Opened_Ports,
  UDP_Opened_Ports : array[MAX_SOCKET] of Word;

implementation

procedure InitSocket(iSocket: Integer);
begin
  SocketManager.Socket[iSocket].Flags := 0;
  SocketManager.Socket[iSocket].iStateMachine := SOCKET_STATE_DISCONNECTED;
  SocketManager.Socket[iSocket].SourcePort := 0;
  Mem_Set(@SocketManager.Socket[iSocket].DestIP, 0, 4);
  Mem_Set(@SocketManager.Socket[iSocket].DestMAC, 0, 6);
  SocketManager.Socket[iSocket].DestPort := 0;
  SocketManager.Socket[iSocket].SequenceNumber := 0;
  SocketManager.Socket[iSocket].AckNumber := 0;
  SocketManager.Socket[iSocket].ExpireTimeCount := 0;                           // In Seconds
  SocketManager.Socket[iSocket].ExpireTimeMax := SOCKET_EXPIRE_TIME_DEFAULT;    // In Seconds
  SocketManager.Socket[iSocket].ResendAttempts := 0;
  SocketManager.Socket[iSocket].ResendTimeCount := 0;
  SocketManager.Socket[iSocket].Start_addr := 0;
  SocketManager.Socket[iSocket].Stop_addr := 0;
  SocketManager.Socket[iSocket].RAM_ROM := 0;
  SocketManager.Socket[iSocket].Keep_Alive := false;
  SocketManager.Socket[iSocket].TCP_buf := '';
end;

procedure PrintSocket(var Socket: TSocket);
begin
  WordToStr(Socket.iStateMachine, s1);
  UART1_Write_Text('iStateMachine: ' + s1 + LF);
  WordToHex(Socket.Flags, s1);
  UART1_Write_Text('Flags: 0x' + s1 + LF);
  WordToStr(Socket.SourcePort, s1);
  UART1_Write_Text('SourcePort: ' + s1 + LF);
  Mac2Str(Socket.DestMAC, s1);
  UART1_Write_Text('DestMac: ' + s1 + LF);
  ip2Str(Socket.DestIP, s1);
  UART1_Write_Text('DestIP: ' + s1 + LF);
  WordToStr(Socket.DestPort, s1);
  UART1_Write_Text('DestPort: ' + s1 + LF);
  LongWordToStr(Socket.SequenceNumber, s1);
  UART1_Write_Text('Seq Number: ' + s1 + LF);
  LongWordToStr(Socket.AckNumber, s1);
  UART1_Write_Text('Ack Number: ' + s1 + LF);
  WordToStr(Socket.Identification, s1);
  UART1_Write_Text('Identification: ' + s1 + LF);
  WordToStr(Socket.ExpireTimeCount, s1);
  UART1_Write_Text('Expire Time Count: ' + s1 + LF);
  WordToStr(Socket.ExpireTimeMax, s1);
  UART1_Write_Text('Expire Time Max: ' + s1 + LF);
  WordToStr(Socket.ResendAttempts, s1);
  UART1_Write_Text('Resend Attempts: ' + s1 + LF);
  WordToStr(Socket.ResendTimeCount, s1);
  UART1_Write_Text('Resend Time Count: ' + s1 + LF);
  LongWordToStr(Socket.Start_addr, s1);
  UART1_Write_Text('Start Addresss: ' + s1 + LF);
  LongWordToStr(Socket.Stop_addr, s1);
  UART1_Write_Text('Stop Address: ' + s1 + LF);
  WordToStr(Socket.RAM_ROM, s1);
  UART1_Write_Text('Ram or Rom: ' + s1 + LF);
  if Socket.Keep_Alive then
    UART1_Write_Text('Keep Alive : True' + s1 + LF)
  else
    UART1_Write_Text('Keep Alive : False' + s1 + LF);
end;

procedure Sockets_Init_Internal;
var
  iSocket: Integer;
begin
  Mem_Set(@TCP_Opened_Ports, 0, MAX_SOCKET*2); // clear ports Word format
  Mem_Set(@UDP_Opened_Ports, 0, MAX_SOCKET*2); // clear ports Word format
  SocketManager.iLastProcessedSocket := 0;
  iSocket := 0;
  while iSocket < MAX_SOCKET do
  begin
    InitSocket(iSocket);
    Inc(iSocket)
  end
end;
  
//******************************************************************************
// Name    : TCP_Open_Connection
// Purpose : Start the opening process.  The caller must poll the Connection to find
//           when it actually becomes open
//******************************************************************************
function TCP_Open_Connection(var DestIP : TIPAddress; DestPort, SourcePort : Word) : Word;
var
  iSocket : Integer;
  DestMAC: TMACAddress;
begin
  {$IFDEF LOG_UART}UART1_Write_Text('Opening TCP Connection'+LF);{$ENDIF}
  Result := RESULT_OPEN_TCP_CONNECTION_OK;
  
  if ARP_Validate_IP(DestIP, DestMAC) then                                      // Does the node exist on the network?
  begin
    iSocket := TCP_Find_Connection(DestIP, DestPort);                           // Look for an open socket
    if iSocket < 0 then                                                         // Can't find one, so begin the open process
    begin
      iSocket := TCP_Find_Free_Socket;
      if iSocket >= 0 then
      begin
        InitSocket(iSocket);
        SocketManager.Socket[iSocket].Flags.SOCKET_FLAG_ALLOCATED := 1;
        SocketManager.Socket[iSocket].iStateMachine := SOCKET_STATE_CONNECT;
        SocketManager.Socket[iSocket].SequenceNumber := 12345;
        SocketManager.Socket[iSocket].DestPort := DestPort;
        SocketManager.Socket[iSocket].SourcePort := SourcePort;
        Mem_Cpy(@SocketManager.Socket[iSocket].DestIP, @DestIP, 4);
        Mem_Cpy(@SocketManager.Socket[iSocket].DestMAC, @DestMAC, 6);
        SocketManager.Socket[iSocket].Keep_Alive := True;
      end else
        Result := RESULT_OPEN_TCP_CONNECTION_NO_SOCKETS;  // Out of sockets
    end
  end else
    Result := RESULT_OPEN_TCP_CONNECTION_ARP_FAILED;    // ARP Failed
end;

//******************************************************************************
// Name    : TCP_Close_Connection
// Purpose : Signals the TCP Connection and Socket to finish and close, note the
//            actual closing happens when it can
//******************************************************************************
function TCP_Close_Connection(var DestIP : TIPAddress; DestPort : Word) : Boolean;
var
  iSocket : Integer;
begin
  iSocket := TCP_Find_Any_Connection(DestIP, DestPort);
  if iSocket >= 0 then
  begin
    SocketManager.Socket[iSocket].Flags.SOCKET_FLAG_FINISH := 1;
    Result := True
  end
end;

//******************************************************************************
// Name    : TCP_Find_Free_Socket
// Purpose : Searches for a free socket, returns the index into the Socket Array
//           or -1 if none can be found
//******************************************************************************
function TCP_Find_Free_Socket: Integer;
var
  iSocket: Integer;
begin
  Result := -1;
  iSocket := 0;
  while iSocket < MAX_SOCKET do  // search for free socket
  begin
    if SocketManager.Socket[iSocket].Flags.SOCKET_FLAG_ALLOCATED = 0 then
    begin
      Result := iSocket;
      Break;
    end;
    Inc(iSocket);
  end;
end;

//******************************************************************************
// Name    : TCP_Find_Connection
// Purpose : Searches for a connected socket (does NOT include sockets in the
//           process of a SYN volley
//******************************************************************************
function TCP_Find_Connection(var DestIP: TIPAddress; DestPort: Word): Integer;
var
  iSocket: Integer;
begin
  Result := -1;
  iSocket := 0;
  while iSocket < MAX_SOCKET do  // search for opened socket
  begin
    if (SocketManager.Socket[iSocket].Flags.SOCKET_FLAG_CONNECTED = 1) then           // is the socket connected?
      if (SocketManager.Socket[iSocket].DestPort = DestPort) then                     // do the destination ports match
        if (Mem_Cmp(@DestIP, @SocketManager.Socket[iSocket].DestIP, 4) = 0) then      // does the destination IP addresses match?
        begin
          Result := iSocket;
          Break; // if connected
        end;
    Inc(iSocket);
  end;
end;

//******************************************************************************
// Name    : TCP_Find_Any_Connection
// Purpose : Searches for a socket that is in any state of connection and allocated
//******************************************************************************
function TCP_Find_Any_Connection(var DestIP: TIPAddress; DestPort: Word): Integer;
var
  iSocket: Integer;
begin
  Result := -1;
  iSocket := 0;
  while iSocket < MAX_SOCKET do  // search for opened socket
  begin
    if (SocketManager.Socket[iSocket].Flags.SOCKET_FLAG_ALLOCATED = 1) then
      if (SocketManager.Socket[iSocket].DestPort = DestPort) then
        if (Mem_Cmp(@DestIP, @SocketManager.Socket[iSocket].DestIP, 4) = 0) then
        begin
          Result := iSocket;
          Break; // if connected
        end;
    Inc(iSocket);
  end;
end;

//******************************************************************************
// Name    : TCP_Set_TimeOut_Interval_Global
// Purpose : Sets the timeout for all connections
//******************************************************************************
procedure TCP_Set_TimeOut_Interval_Global(NewTimeout : Word);
var
  iSocket: Integer;
begin
  iSocket := 0;
  while iSocket < MAX_SOCKET do
    begin
      SocketManager.Socket[iSocket].ExpireTimeMax := NewTimeout;
      Inc(iSocket)
    end;
end;

//******************************************************************************
// Name    : Port_Find
// Purpose : Searches for a Port that is allocated to a protocol (TCP or UDP)
//******************************************************************************
function Port_Find(Protocol: Word; Port: Word) : Boolean;
var
  iPort : Integer;
  PortPtr : ^Word;
begin
  Result := false;
  if Port > 0  then
  begin
    if Protocol = PROTOCOL_TCP then
      PortPtr := @TCP_Opened_Ports
    else
      PortPtr := @UDP_Opened_Ports;
    iPort := 0;
    while iPort < MAX_SOCKET do
    begin
      if PortPtr^ = Port then
      begin
        Result := true;
        Exit;
      end;
      PortPtr := PortPtr + 1;
      Inc(iPort);
    end
  end
end;

//******************************************************************************
// Name    : Port_Close
// Purpose : Closes a TCP or UDP Port
//******************************************************************************
function Port_Close(Protocol : byte; Port : Word) : Boolean;
var 
  iPort : Integer;
  PortPtr : ^Word;
begin
  Result := false;
  if Port > 0 then
  begin
    if Protocol = PROTOCOL_TCP then
      PortPtr := @TCP_Opened_Ports
    else
      PortPtr := @UDP_Opened_Ports;
    iPort := 0;
    while iPort < MAX_SOCKET do
    begin
      if PortPtr^ = Port then
      begin
        PortPtr^ := 0;
        Result := true;
        Exit;
      end;
      PortPtr := PortPtr + 1;
      Inc(iPort);
    end;
  end
end;

//******************************************************************************
// Name    : Port_Open
// Purpose : Opens a TCP or UDP Port
//******************************************************************************
function Port_Open(Protocol : Word; Port : Word) : Boolean;
var 
  iPort: Integer;
  PortPtr : ^Word;
begin
  Result := False;
  if Port_Find(Protocol, Port) = 0 then
  begin
    if Protocol = PROTOCOL_TCP then
      PortPtr := @TCP_Opened_Ports
    else
      PortPtr := @UDP_Opened_Ports;
    iPort := 0;
    while iPort < MAX_SOCKET do                                                     // Look for the first empty (Port = 0) slot
    begin
      if PortPtr^ = 0 then
      begin
        PortPtr^ := Port;
        Result := true;
        Exit;
      end;
      PortPtr := PortPtr + 1;
      Inc(iPort);
    end;
  end else
    Result := True
end;

function Port_Open_UDP(Port : Word): Boolean;
begin
  Result := Port_Open(PROTOCOL_UDP, Port);
end;

function Port_Open_TCP(Port : Word): Boolean;
begin
  Result := Port_Open(PROTOCOL_TCP, Port);
end;

function Port_Close_UDP(Port : Word): Boolean;
begin
  Result := Port_Close(PROTOCOL_UDP, Port);
end;

function Port_Close_TCP(Port : Word): Boolean;
begin
  Result := Port_Close(PROTOCOL_TCP, Port);
end;

end.