unit EthTCP;

{.$DEFINE LOG_UART}
{$DEFINE TRACE_SOCKET_STATE}

{$I Options.inc}

uses


NMRAnetDefinesShared,

  EthCommon,
  EthSockets,
  dspic_additional_string_library,
  lib1_enc600_V3_5_b,
  definitions_ENC600;
  
const
  MAX_TCP_RESEND_ATTEMPTS = 5;      // Attempt to resend 5 times before giving up
  MAX_TCP_RESEND_TIMEOUT = 1000;    // Resend TCP packet if no response within 1000ms
  
// User Functions
function TCP_TryLoadTransmitterAndSend(var Socket: TSocket; TCP_Flags: Byte): Boolean;

// Internal functions
procedure TCP_Init_Internal;

procedure TCP_Process_Stack;
procedure TCP_Process_Receive(ENC_MemoryOffset: Word);

//function TCP_UserSend(var ip_t1 : TIPAddress; dest_port_S1, len_data1 : word; var data_tcp2 : array[1472] of byte) : boolean;

//function TCP_Send_Internal(TCP_Flag_T : byte; iSocket: Integer) : boolean;
//procedure TCP_WriteToWire_Internal(source_portT, dest_portT, PacketLenT : word; SEQ_NoT, ACK_NoT : dWord; TCP_FlagT : byte);
//procedure TCP_Process_Internal(EthMemAddressRequest: Word);

// External functions
//procedure Eth_UserTCP(var dest_ip_addr_T : TIPAddress; var source_port_T, dest_port_T, len_T : word; iSocket : Integer); external;
//procedure Do_Ethernet_Receive; external;

implementation

var
  SEQ_No, ACK_No, SEQ_NoR, ACK_NoR : dWord;
  Window : word;
  
procedure TCP_Init_Internal;
begin
  ACK_No := $42844A80;
  SEQ_No := $42844A80;
end;

procedure LoadIPHeaderLine0(var HeaderLine: TEthernetHeaderLine; IP_Version, IHL, DSCP, ECN: Byte; PacketLength: Word);
begin
  HeaderLine[0] := (IP_Version shl 4) or IHL;
  HeaderLine[1] := (DSCP shl 2) or ECN;
  HeaderLine[2] := Hi(PacketLength);
  HeaderLine[3] := Lo(PacketLength);
end;

procedure LoadIPHeaderLine1(var HeaderLine: TEthernetHeaderLine; Identification: Word; FragmentationFlags: Byte; FragmentationOffset: Word);
begin
  HeaderLine[0] := Hi(Identification);
  HeaderLine[1] := Lo(Identification);
  HeaderLine[2] := (FragmentationFlags shl 5) or (Hi(FragmentationOffset) shr 3);
  HeaderLine[3] := Lo(FragmentationOffset)
end;

procedure LoadIPHeaderLine2(var HeaderLine: TEthernetHeaderLine; TimeToLive, Protocol: Byte);
begin
  HeaderLine[0] := TimeToLive;
  HeaderLine[1] := Protocol;
  HeaderLine[2] := 0;                                                           // Checksum comes after all of the header is filled in
  HeaderLine[3] := 0
end;

procedure LoadIPHeaderLine3(var HeaderLine: TEthernetHeaderLine; var SourceIP: TIPAddress);
begin
  HeaderLine := SourceIP;
end;

procedure LoadIPHeaderLine4(var HeaderLine: TEthernetHeaderLine; var DestIP: TIPAddress);
begin
  HeaderLine := DestIP;
end;

procedure LoadTCPHeaderLine0(var HeaderLine: TEthernetHeaderLine; SourcePort, DestPort: Word);
begin
  HeaderLine[0] := Hi(SourcePort);
  HeaderLine[1] := Lo(SourcePort);
  HeaderLine[2] := Hi(DestPort);
  HeaderLine[3] := Lo(DestPort);
end;

procedure LoadTCPHeaderLine1(var HeaderLine: TEthernetHeaderLine; SequenceNumber: DWord);
begin
  MemCpy(@HeaderLine[0], @SequenceNumber, 4);
end;

procedure LoadTCPHeaderLine2(var HeaderLine: TEthernetHeaderLine; AckNumber: DWord);
begin
  MemCpy(@HeaderLine[0], @AckNumber, 4);
end;

procedure LoadTCPHeaderLine3(var HeaderLine: TEthernetHeaderLine; DataOffset: Byte; TCP_Flags, WindowSize: Word);
begin
  HeaderLine[0] := (DataOffset shl 4) or (Hi(TCP_Flags) and $0001);
  HeaderLine[1] := Lo(TCP_Flags);
  HeaderLine[2] := Hi(WindowSize);
  HeaderLine[3] := Lo(WindowSize);
end;

procedure LoadTCPHeaderLine4(var HeaderLine: TEthernetHeaderLine; UrgentPtr: Word);
begin
  HeaderLine[0] := 0;               // Calcuate Checksum later
  HeaderLine[1] := 0;               // Calcuate Checksum later
  HeaderLine[2] := Hi(UrgentPtr);
  HeaderLine[3] := Lo(UrgentPtr);
end;


function TCP_TryLoadTransmitterAndSend(var Socket: TSocket; TCP_Flags: Byte;): Boolean;
var
  Header: TEthernetHeader;
  PhyHeader: TPhysicalLayerHeader;
  CheckSum, MessageLength: Word;
begin
  Result := False;
  
  UART1_Write_Text('Trying to Load XMTR');
  
  if not EthernetTransmitting then       // Only load if the ethernet chip transmitter is empty
  begin
  
    UART1_Write_Text('Empty, loading XMTR');
  
    PhyHeader.SourceMacAddress := Settings.eth_mac;
    PhyHeader.DestMacAddress := Socket.DestMAC;
    PhyHeader.Protocol := $0800;                   // IP
    CopyRamToEthMem(@PhyHeader, TXSTART + PHYSICAL_LAYER_HEADER_OFFSET, PHYSICAL_LAYER_HEADER_SIZE);
  
    MessageLength := TCP_IP_HEADER_SIZE + Socket.Stop_addr - Socket.Stop_addr;
    LoadIPHeaderLine0(Header[0], Settings.IP_Version, 5, Settings.IP_DSCP, Settings.IP_ECN, MessageLength);
    LoadIPHeaderLine1(Header[1], Socket.Identification, Settings.IP_FragmentationFlags, 0);
    LoadIPHeaderLine2(Header[2], Settings.IP_TimeToLive, PROTOCOL_TCP);
    LoadIPHeaderLine3(Header[3], Settings.eth_ip_addr);
    LoadIPHeaderLine4(Header[4], Socket.DestIP);
    CopyRamToEthMem(@Header, TXSTART + PHYSICAL_LAYER_HEADER_SIZE, IP_HEADER_SIZE);
    CheckSum := Eth_Cksum(TXSTART + PHYSICAL_LAYER_HEADER_SIZE, IP_HEADER_SIZE);    // Let ENC calculate the Checksum for the IP Header data
    CopyRamToEthMem(@Checksum, TXSTART + IP_CHECKSUM_OFFSET, 2);                                    // Store the Checksum
  
    LoadTCPHeaderLine0(Header[0], Socket.SourcePort, Socket.DestPort);
    LoadTCPHeaderLine1(Header[1], Socket.SequenceNumber);
    LoadTCPHeaderLine2(Header[2], Socket.Identification);
    LoadTCPHeaderLine3(Header[3], 5, TCP_Flags, 1024);
    LoadTCPHeaderLine4(Header[4], 0);
    CopyRamToEthMem(@Header, TXSTART + TCP_HEADER_OFFSET, TCP_HEADER_SIZE);
    CopyRamToEthMem(Socket.Start_addr, TXSTART + TCP_DATA_OFFSET, Socket.Stop_addr - Socket.Stop_addr);
    CheckSum := Eth_Cksum(TXSTART + TCP_HEADER_OFFSET, TCP_HEADER_SIZE + Socket.Stop_addr - Socket.Stop_addr);    // Let ENC calculate the Checksum
    CopyRamToEthMem(@CheckSum, TXSTART + TCP_CHECKSUM_OFFSET, 2);                                           // Store the Checksum
    
    Eth_WriteReg(ETXST_, TXSTART);                                              // Set the start of packet
    Eth_WriteReg(ETXLEN_, MessageLength);                                       // DOUBLE CHECK THE LENGTH CALCULATION>>>>>>>>>>>>
    Eth_BSF(ECON1_, ECON1_TXRTS_);                                              // Enable the Transmit
    
    Result := True;
  end;
end;

procedure TCP_Process_Receive(ENC_MemoryOffset: Word);
var
  Header: TEthernetHeader;
  PhysicalLayerHeader: TPhysicalLayerHeader;                                  // Current info for the Physical Layer of the current transmission
  IP_Checksum, TCP_Checksum: Word;
  iSocket: Integer;
  Socket: ^TSocket;
begin

  CopyEthMemToRam(ENC_MemoryOffset, @Header, PHYSICAL_LAYER_HEADER_SIZE);     // 1 to 1 mapping overlay for the phy header, easy
  
  {$IFDEF ETHERNET_16_BIT_PROCESSOR}
  PhysicalLayerHeader.SourceMacAddress[0] := Header.Offset0Hi shr 12;
  PhysicalLayerHeader.SourceMacAddress[1] := Header.Offset0Hi shr 8;
  PhysicalLayerHeader.SourceMacAddress[2] := Header.Offset0Hi shr 4;
  PhysicalLayerHeader.SourceMacAddress[3] := Header.Offset0Hi;
  PhysicalLayerHeader.SourceMacAddress[4] := Header.Offset0Lo shr 12;
  PhysicalLayerHeader.SourceMacAddress[5] := Header.Offset0Lo shr 8;
  PhysicalLayerHeader.DestMacAddress[0] := Header.Offset1Hi shr 12;
  PhysicalLayerHeader.DestMacAddress[1] := Header.Offset1Hi shr 8;
  PhysicalLayerHeader.DestMacAddress[2] := Header.Offset1Hi shr 4;
  PhysicalLayerHeader.DestMacAddress[3] := Header.Offset1Hi;
  PhysicalLayerHeader.DestMacAddress[4] := Header.Offset1Lo shr 12;
  PhysicalLayerHeader.DestMacAddress[5] := Header.Offset1Lo shr 8;
  PhysicalLayerHeader.Protocol := Header.Offset3Hi;
  {$ENDIF}
  
  {$IFDEF ETHERNET_32_BIT_PROCESSOR}
  PhysicalLayerHeader.SourceMacAddress[0] := Header.Offset0 shr 28;
  PhysicalLayerHeader.SourceMacAddress[1] := Header.Offset0 shr 24;
  PhysicalLayerHeader.SourceMacAddress[2] := Header.Offset0 shr 20;
  PhysicalLayerHeader.SourceMacAddress[3] := Header.Offset0 shr 16;
  PhysicalLayerHeader.SourceMacAddress[4] := Header.Offset0 shr 12;
  PhysicalLayerHeader.SourceMacAddress[5] := Header.Offset0 shr 8;
  PhysicalLayerHeader.DestMacAddress[0] := Header.Offset1 shr 28;
  PhysicalLayerHeader.DestMacAddress[1] := Header.Offset1 shr 24;
  PhysicalLayerHeader.DestMacAddress[2] := Header.Offset1 shr 20;
  PhysicalLayerHeader.DestMacAddress[3] := Header.Offset1 shr 16
  PhysicalLayerHeader.DestMacAddress[4] := Header.Offset1 shr 12;
  PhysicalLayerHeader.DestMacAddress[5] := Header.Offset1 shr 8;
  PhysicalLayerHeader.Protocol := Header.Offset3Hi;
  {$ENDIF}
  
  CopyEthMemToRam(ENC_MemoryOffset + PHYSICAL_LAYER_HEADER_SIZE, @Header, IP_HEADER_SIZE); // Read in the entire IP Header
  
  {$IFDEF ETHERNET_16_BIT_PROCESSOR}
  IPHeader.Version := (Header.Offset0Hi shr 12) and $000F;
  IPHeader.IHL := (Header.Offset0Hi shr 8) and $000F;
  IPHeader.DSCP := (Header.Offset0Hi shr 3) and $003F;
  IPHeader.ECN := Header.Offset0Hi and $00000002;
  IPHeader.TotalLength := Header.Offset0Lo;
  IPHeader.Identification := Header.Offset1Hi;
  IPHeader.Flags := (Header.Offset1Lo shr 13) and $0003;
  IPHeader.FragmentOffset := Header.Offset1Lo and $1FFF;
  IPHeader.TimeToLive := (Header.Offset2Hi shr 8) and $00FF;
  IPHeader.Protocol := Header.Offset2Hi and $00FF;
  IP_CheckSum := Header.Offset2Lo;
  memcpy(@IPHeader.SourceIPAddress, @Header.Offset3Hi, IP_ADDRESS_LEN);
  memcpy(@IPHeader.DestIPAddress, @Header.Offset4Hi, IP_ADDRESS_LEN);
  {$ENDIF}
  
  {$IFDEF ETHERNET_32_BIT_PROCESSOR}
  IPHeader.Version := (Header.Offset0 shr 28) and $0000000F;
  IPHeader.IHL := (Header.Offset0 shr 24) and $0000000F;
  IPHeader.DSCP := (Header.Offset0 shr 18) and $0000003F;
  IPHeader.ECN := (Header.Offset0 shr 16) and $00000002;
  IPHeader.TotalLength := Header.Offset0 and $0000FFFF;
  IPHeader.Identification := (Header.Offset1 shr 16) and $0000FFFF;
  IPHeader.Flags := (Header.Offset1 shr 19) and $00000003;
  IPHeader.FragmentOffset := Header.Offset1 and $00001FFF;
  IPHeader.TimeToLive := (Header.Offset2 shr 24) and $000000FF;
  IPHeader.Protocol := (Header.Offset2 shr 16) and $000000FF;
  IP_CheckSum := Header.Offset2 and $0000FFFF;
  memcpy(@IPHeader.SourceIPAddress, @Header.Offset3, IP_ADDRESS_LEN);
  memcpy(@IPHeader.DestIPAddress, @Header.Offset4, IP_ADDRESS_LEN);
  {$ENDIF}

  
  WriteToEthMem(ENC_MemoryOffset + 24, $00);      // Put $0000 in for the Checksum
  Eth_PutByte($00);
  if IP_CheckSum = Eth_Cksum(ENC_MemoryOffset + IP_HEADER_OFFSET, IP_HEADER_SIZE) then
  begin

 //   CopyEthMemToRam(ENC_MemoryOffset + PHYSICAL_LAYER_HEADER_SIZE + IP_HEADER_SIZE + (IPHeader.IHL - 5), @Header, TCP_HEADER_SIZE);
    
    {$IFDEF ETHERNET_16_BIT_PROCESSOR}
    TCPHeader.SourcePort := Header.Offset0Hi;
    TCPHeader.DestPort := Header.Offset0Lo;
    Hi(TCPHeader.SequenceNumber) := Header.Offset1Hi;
    Lo(TCPHeader.SequenceNumber) := Header.Offset1Lo;
    Hi(TCPHeader.AckNumber) := Header.Offset2Hi;
    Lo(TCPHeader.AckNumber) := Header.Offset2Lo;
    TCPHeader.DataOffset := (Header.Offset3Hi shr 12) and $000F;
    TCPHeader.Flags := Header.Offset3Hi and $00FF;
    TCPHeader.WindowSize := Header.Offset3Lo;
    TCP_Checksum := Header.Offset4Hi;
    TCPHeader.UrgentPtr := Header.Offset4Lo;
    {$ENDIF}
    
    {$IFDEF ETHERNET_32_BIT_PROCESSOR}
    TCPHeader.SourcePort := (Header.Offset0 shr 16) and $0000FFFF;
    TCPHeader.DestPort := (Header.Offset0 and $0000FFFF);
    TCPHeader.SequenceNumber := Header.Offset1;
    TCPHeader.AckNumber := Header.Offset2;
    TCPHeader.DataOffset := (Header.Offset3 shr 28) and $0000000F;
    TCPHeader.Flags := (Header.Offset3 shr 16) and $000000FF;
    TCPHeader.WindowSize := (Header.Offset3 and $0000FFFF);
    TCP_Checksum := (Header.Offset4 shr 16) and $0000FFFF;
    TCPHeader.UrgentPtr := Header.Offset4 and $0000FFFF;
    {$ENDIF}

    WriteToEthMem(ENC_MemoryOffset + 50, $00);      // Put $0000 in for the Checksum
    Eth_PutByte($00);

  //  if TCP_Checksum = Eth_Cksum(ENC_MemoryOffset + TCP_HEADER_OFFSET, IPHeader.TotalLength - IP_HEADER_SIZE) then
    begin
  //    iSocket := TCP_Find_Any_Connection(IPHeader.DestIPAddress, TCPHeader.DestPort);
      if iSocket > -1 then
      begin
        Socket := @SocketManager.Socket[iSocket];
    //    Socket^.Flags := Socket^.Flags or (TCPHeader.Flags and $003F);  // Only support first 6 bits of flags
      end
    end
  end
end;

procedure TCP_Process_TestForResend(var Socket: TSocket; ResendState: Word);
begin
  if Socket.ResendTimeCount > MAX_TCP_RESEND_TIMEOUT then
    if Socket.ResendAttempts < MAX_TCP_RESEND_ATTEMPTS then
    begin
      Socket.ExpireTimeCount := 0;
      Socket.ResendTimeCount := 0;
      Inc(Socket.ResendAttempts);
      Socket.iStateMachine := ResendState                   // Resend
    end else
      Socket.iStateMachine := SOCKET_STATE_RESET            // IF CONNECTED THIS SHOULD SEND A FIN-ACK AND GIVE UP
end;

procedure TCP_Process_ClearTimers(var Socket: TSocket);
begin
  Socket.ExpireTimeCount := 0;
  Socket.ResendTimeCount := 0;
end;

procedure TCP_Process_ClearTimersAndResendAttempts(var Socket: TSocket);
begin
  Socket.ExpireTimeCount := 0;
  Socket.ResendTimeCount := 0;
  Socket.ResendAttempts := 0;
end;

//******************************************************************************
//* Name    : TCP_Process_Stack                                                         *
//* Purpose : Process packets from TCP/IP Stack                                *
//******************************************************************************
procedure TCP_Process_Stack;
var
  Socket: ^TSocket;
begin
  Socket := @SocketManager.Socket[SocketManager.iLastProcessedSocket];
  
  if Socket^.Flags.SOCKET_FLAG_RECEIVED_RST then
    Socket^.iStateMachine := SOCKET_STATE_RESET;
    
  case Socket^.iStateMachine of
    SOCKET_STATE_DISCONNECTED :
        begin

        end;
    SOCKET_STATE_CONNECT :
        begin   
          {$IFDEF TRACE_SOCKET_STATE}UART1_Write_Text('SOCKET_STATE_SENDING_SYN');{$ENDIF}
          if TCP_TryLoadTransmitterAndSend(Socket^, SYN_S) then
          begin 
            {$IFDEF TRACE_SOCKET_STATE}UART1_Write_Text('Loaded to Send');{$ENDIF}
            TCP_Process_ClearTimersAndResendAttempts(Socket^);
            Socket^.iStateMachine := SOCKET_STATE_WAITING_FOR_SYN_ACK;
          end;
        end;
    SOCKET_STATE_WAITING_FOR_SYN_ACK :
        begin 
          {$IFDEF TRACE_SOCKET_STATE}UART1_Write_Text('SOCKET_STATE_WAITING_FOR_SYN_ACK');{$ENDIF}
          if Socket^.Flags.SOCKET_FLAG_RECEIVED_ACK = 1 then                    // Client will send an ACK then a SYN flag (or both at the same time)
          begin
            Socket^.Flags.SOCKET_FLAG_RECEIVED_ACK := 0;                        // Clear the ACK flag
            TCP_Process_ClearTimersAndResendAttempts(Socket^);
            Socket^.iStateMachine := SOCKET_STATE_WAITING_FOR_SYN;
          end else
            TCP_Process_TestForResend(Socket^, SOCKET_STATE_CONNECT);
        end;
    SOCKET_STATE_WAITING_FOR_SYN :
        begin 
          {$IFDEF TRACE_SOCKET_STATE}UART1_Write_Text('SOCKET_STATE_WAITING_FOR_SYN');{$ENDIF}
          if Socket^.Flags.SOCKET_FLAG_RECEIVED_SYN = 1 then
          begin
            Socket^.Flags.SOCKET_FLAG_RECEIVED_SYN := 0;
            TCP_Process_ClearTimersAndResendAttempts(Socket^);
            Socket^.iStateMachine := SOCKET_STATE_CONNECTED;
          end else
            TCP_Process_TestForResend(Socket^, SOCKET_STATE_CONNECT);
        end;
    SOCKET_STATE_CONNECTED :
        begin
          if Socket^.Stop_addr - Socket^.Start_addr > 0 then                    // Do we have some data to send?
          begin
            Socket^.ExpireTimeCount := 0;                                              // Reset Expiration time
            if TCP_TryLoadTransmitterAndSend(Socket^, PSH_S + ACK_S) then
            begin
              // Send the data here.....
              if not Socket^.Keep_Alive then
              begin
                TCP_Process_ClearTimersAndResendAttempts(Socket^);
                Socket^.iStateMachine := SOCKET_STATE_DISCONNECT;
              end
            end
          end else
          begin
            if (Socket^.Flags.SOCKET_FLAG_FINISH = 1) or (Socket^.ExpireTimeCount > Socket^.ExpireTimeMax) then
            begin
              TCP_Process_ClearTimersAndResendAttempts(Socket^);
              Socket^.iStateMachine := SOCKET_STATE_DISCONNECT;
            end
          end;
        end;
    SOCKET_STATE_DISCONNECT :
        begin
          {$IFDEF TRACE_SOCKET_STATE}UART1_Write_Text('SOCKET_STATE_DISCONNECT');{$ENDIF}
          if TCP_TryLoadTransmitterAndSend(Socket^, FIN_S) then
          begin 
            {$IFDEF TRACE_SOCKET_STATE}UART1_Write_Text('Disconnect Sent');{$ENDIF}
            Socket^.Flags.SOCKET_FLAG_RECEIVED_FIN := 0;
            Socket^.Flags.SOCKET_FLAG_RECEIVED_ACK := 0;
            Socket^.ResendTimeCount := 0;
            Socket^.ResendAttempts := 0;
            Socket^.iStateMachine := SOCKET_STATE_WAITING_FOR_FIN_ACK;
          end
        end;
    SOCKET_STATE_WAITING_FOR_FIN_ACK :
        begin  
          {$IFDEF TRACE_SOCKET_STATE}UART1_Write_Text('SOCKET_STATE_WAITING_FOR_FIN_ACK');{$ENDIF}
          // We have FIN'ed so we can't send anymore but we can receive until we receive a FIN
          if Socket^.Flags.SOCKET_FLAG_RECEIVED_ACK = 1 then
          begin
            // Update the Acknowledge field here
            Socket^.iStateMachine := SOCKET_STATE_WAITING_FOR_FIN;
          end else
            TCP_Process_TestForResend(Socket^, SOCKET_STATE_DISCONNECT);
        end;
    SOCKET_STATE_WAITING_FOR_FIN :
        begin 
          {$IFDEF TRACE_SOCKET_STATE}UART1_Write_Text('SOCKET_STATE_WAITING_FOR_FIN');{$ENDIF}
          if Socket^.Flags.SOCKET_FLAG_RECEIVED_FIN = 1 then
          begin
            Socket^.iStateMachine := SOCKET_STATE_DISCONNECTED;
            Socket^.Flags := 0;
          end
        end;
    SOCKET_STATE_ERROR :
        begin
          {$IFDEF TRACE_SOCKET_STATE}UART1_Write_Text('SOCKET_STATE_ERROR');{$ENDIF}
          if TCP_TryLoadTransmitterAndSend(Socket^, FIN_S + ACK_S) then
          begin
            Socket^.iStateMachine := SOCKET_STATE_RESET;
          end;
        end;
    SOCKET_STATE_RESET :
        begin 
          {$IFDEF TRACE_SOCKET_STATE}UART1_Write_Text('SOCKET_STATE_RESET');{$ENDIF}
          // This will have been set asyncronously from the TCP Receive call
          Socket^.iStateMachine := SOCKET_STATE_DISCONNECTED;
          Socket^.Flags := 0;
        end;
  end;

  // Loop around if necessary
  Inc(SocketManager.iLastProcessedSocket);
  if SocketManager.iLastProcessedSocket >= MAX_SOCKET then
    SocketManager.iLastProcessedSocket := 0;
end;

(*

//******************************************************************************
//* Name    : TCP_Send_Load_Addresses_And_Data_Internal
//* Purpose : Send TCP packets, used by TCP/IP Stack
//  Description: This is only called by TCP_Send_Internal to move the MAC and
//               IP addresses to the ENC device, then decode if the data is RAM
//               or ROM and move that to the device.  It then calls the function
//               to load the rest of the IP/TCP header info to the device and send
//               the packet
//******************************************************************************
function TCP_Send_LoadAddressesAndDataThenSend_Internal(TCP_Flag_T: byte; iSocket: byte; AddressOffset : word; MaxPacketDataSize: Word) : word;
var
  BytesToWrite : word;
  Stop_addr_S, Start_addr_S : dword;
  kk : dword;
  ptf : ^far const byte;

begin
  Result := 0;
  Stop_addr_S := SocketManager.Socket[iSocket].Stop_addr;
  Start_addr_S := SocketManager.Socket[iSocket].Start_addr;

  CopyRamToEthMem(@SocketManager.Socket[iSocket].Dest_Mac, TXSTART, 6);
  CopyRamToEthMem(@Settings.eth_mac, TXSTART + 6, 6);
  CopyRamToEthMem(@Settings.eth_ip_addr, TXSTART + 26, 4);
  CopyRamToEthMem(@SocketManager.Socket[iSocket].Dest_Ip, TXSTART + 30, 4);
  WriteToEthMem(TXSTART + 53, $00);

  if SocketManager.Socket[iSocket].RAM_ROM = 0 then
  begin
    BytesToWrite := dword(Stop_addr_S - (Start_addr_S + AddressOffset));
    if BytesToWrite >= MaxPacketDataSize then
      BytesToWrite := MaxPacketDataSize;
    if BytesToWrite <> 0 then
      CopyRamToEthMem_CP((Start_addr_S + AddressOffset), BytesToWrite);
  end else
  if SocketManager.Socket[iSocket].RAM_ROM = 1 then
  begin
    ptf := Start_addr_S + AddressOffset;
    BytesToWrite := 0;
    while dword(ptf) < Stop_addr_S do
    begin
      Eth_PutByte(ptf^);
      ptf := ptf + 1;
      if inc(BytesToWrite) >= MaxPacketDataSize then
        Break;
    end;
    if BytesToWrite = 0 then
      Exit;
  end;

  TCP_WriteToWire_Internal(SocketManager.Socket[iSocket].source_port_S, SocketManager.Socket[iSocket].dest_port_S, BytesToWrite, (SocketManager.Socket[iSocket].SequenceNumber + AddressOffset), SocketManager.Socket[iSocket].ACK_No_S, TCP_Flag_T);

  Result := BytesToWrite;
end;

//******************************************************************************
//* Name    : TCP_Send_Internal
//* Purpose : Send TCP packets, used by TCP/IP Stack
//  Description:  This is the internal equivalent to the TCP_UserSend function.
//                When the library wants to send a packet it usees this function.
//                It allows other packet flag to be st for other packets than
//                sending data. TCP_UserSend comes through this after it sets
//                up the variables property
//******************************************************************************
function TCP_Send_Internal(TCP_Flag: byte; iSocket: Integer) : boolean;
var
  AddressOffset, iReTransmit, MaxPacketDataSize : word;
  Stop_addr_S, Start_addr_S, seq_buf : dword;
  AddressDelta : dword;
begin
  {$IFDEF LOG_UART}UART1_Write_Text(LF+'Transmitting a TCP Packet................<START>'+LF);{$ENDIF}
  {$IFDEF LOG_UART}
  s1 := 'TCP Tx: TCP Flags: |';
  if TCP_Flag.FIN = 1 then
    s1 := s1 + 'FIN|';
  if TCP_Flag.SYN = 1 then
    s1 := s1 + 'SYN|';
  if TCP_Flag.RST = 1 then
    s1 := s1 + 'RST|';
  if TCP_Flag.PSH = 1 then
    s1 := s1 + 'PSH|';
  if TCP_Flag.ACK = 1 then
    s1 := s1 + 'ACK|';
  if TCP_Flag.URG = 1 then
    s1 := s1 + 'URG|';
  UART1_Write_Text(+s1+LF);
  {$ENDIF}

  Result := False;

  iReTransmit := 0;
  while iReTransmit < 3 do
  begin
  //  Do_Ethernet_Receive;
 //   Do_Ethernet_Receive;

    // If not connected then only allow sends that have FIN or SYN as they are the only calls that are valid in this state
    if SocketManager.Socket[iSocket].State.SOCKET_STATE_CONNECTED = 0 then
      if TCP_Flag.FIN = 0 then
        if TCP_Flag.SYN = 0 then
        begin
          Result := False;
          {$IFDEF LOG_UART}UART1_Write_Text('TCP Tx: The socket is not connected and the request was not a FIN or SYN, we are out of here...'+LF);{$ENDIF}
          {$IFDEF LOG_UART}UART1_Write_Text('Transmitting a TCP Packet...............<END>'+LF+LF);{$ENDIF}
          Exit;
        end;

    AddressOffset := 0;
    MaxPacketDataSize := 1300;
    Stop_addr_S := SocketManager.Socket[iSocket].Stop_addr;
    Start_addr_S := SocketManager.Socket[iSocket].Start_addr;
    seq_buf := SocketManager.Socket[iSocket].SequenceNumber;
    AddressDelta := (Stop_addr_S - Start_addr_S);

    SocketManager.Socket[iSocket].Wait_ACK := 1;
    AddressOffset := TCP_Send_LoadAddressesAndDataThenSend_Internal(TCP_Flag, iSocket, AddressOffset, MaxPacketDataSize);   // Send the rest of the data bytes, if there are any

    TickCounter10 := 0;
    while TickCounter10 < SocketManager.TCP_Wait do // wait for ack
    begin
      Do_Ethernet_Receive;                                                             // Local spin looking for the ACK reply.  The rub is the ACK may come with a PSH and data that can cause recursion....
      if SocketManager.Socket[iSocket].Wait_ACK = 0 then                        // Not waiting anymore, received
      begin
    //    SocketManager.Socket[iSocket].Wait_ACK := 1;
    //    if seq_buf <> SocketManager.Socket[iSocket].SequenceNumber then               // The SequenceNumber is updated in the receive of the ACK, needs to be better for error detection
          Break;
      end;
    end;

    if TickCounter10 < SocketManager.TCP_Wait then
      Break;

    inc(iReTransmit);
  end;

  if iReTransmit = 3 then
  begin
    {$IFDEF LOG_UART}UART1_Write_Text('TCP Tx: Packets sent 3 times but timed out waiting for the first ACK from the receiver, we are out of here...'+LF);{$ENDIF}
    {$IFDEF LOG_UART}UART1_Write_Text('Transmitting a TCP Packet................<END>'+LF+LF);{$ENDIF}
    Exit;
  end;

  // Increment the sliding address for the data window
  if (SocketManager.Socket[iSocket].Start_addr = Start_addr_S) and (SocketManager.Socket[iSocket].Stop_addr = Stop_addr_S) then
    SocketManager.Socket[iSocket].Start_addr := SocketManager.Socket[iSocket].Start_addr + AddressOffset;

  Result := True;
  {$IFDEF LOG_UART}UART1_Write_Text('Transmitting a TCP Packet................<END>'+LF+LF);{$ENDIF}
end;

//******************************************************************************
//* Name    : TCP_UserSend                                                         *
//* Purpose : Send TCP packet                                                  *
//******************************************************************************
function TCP_UserSend(var ip_t1 : TIPAddress; dest_port_S1, len_data1 : word; var data_tcp2 : array[1472] of byte) : boolean;
var
  iSocket : Integer;
begin
  iSocket := TCP_Find_Connection(ip_t1, dest_port_S1);

  if iSocket < 0 then // no sockets available
  begin
    Result := False;
    Exit;
  end;

  SocketManager.Socket[iSocket].RAM_ROM := 0;
  SocketManager.Socket[iSocket].Start_addr := @data_tcp2;
  SocketManager.Socket[iSocket].Stop_addr := @data_tcp2 + len_data1;
  Result := TCP_Send_Internal(PSH_S + ACK_S, iSocket);
  if Result = False then
    begin
      SocketManager.Socket[iSocket].State.SOCKET_STATE_DISCONNECTED := 1;
      SocketManager.Socket[iSocket].State.SOCKET_STATE_WAITING_FOR_CONNECTION := 0;
      SocketManager.Socket[iSocket].State.SOCKET_STATE_CONNECTED := 0;
      SocketManager.Socket[iSocket].Keep_Alive := False;
    end;
end;

*)

 (*

//******************************************************************************
//* Name    : TCP_WriteToWire_Internal                                                      *
//* Purpose : Send TCP packet, used by library                                 *
//  Descriptions:
//     The data has already been written to the ENC by the time this is called
//******************************************************************************
procedure TCP_WriteToWire_Internal(source_portT, dest_portT, PacketLenT : word; SEQ_NoT, ACK_NoT : dWord; TCP_Flag : byte);
var
  TotalLen : word;
  Align : byte;
  CkSum_TCP, CkSum_IP: Word;
begin

  {$IFDEF LOG_UART}
  s1 := '|';
  if TCP_Flag.FIN = 1 then
    s1 := s1 + 'FIN|';
  if TCP_Flag.SYN = 1 then
    s1 := s1 + 'SYN|';
  if TCP_Flag.RST = 1 then
    s1 := s1 + 'RST|';
  if TCP_Flag.PSH = 1 then
    s1 := s1 + 'PSH|';
  if TCP_Flag.ACK = 1 then
    s1 := s1 + 'ACK|';
  if TCP_Flag.URG = 1 then
    s1 := s1 + 'URG|';
  UART1_Write_Text('TCP Write to wire with Flags: '+s1+LF);
  {$ENDIF}

  WriteToEthMem(TXSTART+12,$08);    // Phy Layer Protocol HI
  Eth_PutByte($00);                 // Phy Layer Protocol LO
  Eth_PutByte($45);                 // Version/IHL
  Eth_PutByte($00);                 // DCP/ECN
  TotalLen := 40 + PacketLenT;      // Does not count the physical layer MAC addresses or Protocol type
  Eth_PutByte(Hi(TotalLen));        // Total Length HI
  Eth_PutByte(Lo(TotalLen));        // Total Length LO
  inc(TCP_IdentificationCounter);
  Eth_PutByte(Hi(TCP_IdentificationCounter));     // Identification HI
  Eth_PutByte(Lo(TCP_IdentificationCounter));     // Identification LO
  Eth_PutByte($40);                 // Fragment Flags (DF, don't fragment) / Fragment Offset upper bits
  Eth_PutByte($00);                 // Fragment Offset Lo
  Eth_PutByte($80);                 // Time to Live in seconds (128 seconds)
  Eth_PutByte($06);                 // Protocol = TCP
  Eth_PutByte($00);                 // Checksum HI
  Eth_PutByte($00);                 // Checksum LO
  CkSum_IP := Eth_Cksum(TXSTART+14, 20); // Checksum the entire IP Header of 20 bytes
  WriteToEthMem(TXSTART+24 ,Hi(CkSum_IP)); // Write check sum to Header Checksum offset in Header (with 0 for the Checksum we calculated)
  Eth_PutByte(Lo(CkSum_IP));
  WriteToEthMem(TXSTART+34, Hi(source_portT));  // TCP Source Port Hi
  Eth_PutByte(Lo(source_portT));               // Lo
  Eth_PutByte(Hi(dest_portT));                 // TCP Dest Port Hi
  Eth_PutByte(Lo(dest_portT));                 // Lo
  CopyRamToEthMem_Inv(@SEQ_NoT, TXSTART+38, 4);
  CopyRamToEthMem_Inv(@ACK_NoT, TXSTART+42, 4);
  if TCP_Flag = $12 then                      // if [SYN, ACK] then
    WriteToEthMem(TXSTART+46, $70)             // (upper nibble = 7 - 32 bit block or 8 bytes of options added)
  else
    WriteToEthMem(TXSTART+46, $50);            // (upper nibble = 5 so no options)

  WriteToEthMem(TXSTART+47, TCP_Flag);       // Flags
  Window := 65200;
  Eth_PutByte(Hi(Window));                    // Window HI
  Eth_PutByte(Lo(Window));                    // Window LO

  WriteToEthMem(TXSTART+50, $00);             // TCP checksum HI zeroed out
  Eth_PutByte($00);                           // TCP checksum LO zeroed out
  Eth_PutByte($00);                           // TCP Urgent Ptr Hi zeroed out
  Eth_PutByte($00);                           // TCP Urgent Ptr Lo zeroed out
  WriteToEthMem(TXSTART+14+TotalLen, $00);    // The 2 data bytes PAST the data write 0
  Eth_PutByte($00);
  Align := TotalLen and $01;
  CopyEthMemToEthMem(TXSTART+26, TXSTART+14+TotalLen+Align, 8);
  WriteToEthMem(TXSTART+22+TotalLen+Align, $00);
  Eth_PutByte($06);
  TotalLen := TotalLen - 20;
  Eth_PutByte(Hi(TotalLen));
  Eth_PutByte(Lo(TotalLen));
  CkSum_TCP := Eth_Cksum(TXSTART+34, 12+TotalLen+Align);
  WriteToEthMem(TXSTART+50, Hi(CkSum_TCP));
  Eth_PutByte(Lo(CkSum_TCP));
  Eth_Send(34+TotalLen);                                                        // Blocks until sent
end;



//******************************************************************************
//* Name    : TCP_Process_Internal
//* Purpose : Process incomming TCP packets
//******************************************************************************
procedure TCP_Process_Internal(EthMemAddressRequest: Word);
var
  PacketLen, source_port2, dest_port2, len_ack : word;
  iSocket: Integer;
  Align, TCP_FlagReceive, TCP_FlagSend : byte;
  dest_mac2 : TMACAddress;
  dest_ip_addr: TIPAddress;
  CkSum_TCP: word;
  CkSum_IP: word;
  len_data: word;
label
  next_phs;

begin
  source_port2 := 0;
  CkSum_IP := 0;
  CkSum_TCP := 0;
  len_data := 0;
  dest_port2 := 0;
  Hi(source_port2) := ReadFromEthMem(EthMemAddressRequest+36);
  Lo(source_port2) := Eth_GetByte;
  if Port_Find(PROTOCOL_TCP, source_port2) = False then
    begin
      if Settings.Policy = POLICY_REJECT then
        Common_Reject_Internal(EthMemAddressRequest);
      Exit;
    end;

  Hi(CkSum_IP) :=  ReadFromEthMem(EthMemAddressRequest+24);
  Lo(CkSum_IP) :=  Eth_GetByte;
  Hi(CkSum_TCP) := ReadFromEthMem(EthMemAddressRequest+50);
  Lo(CkSum_TCP) := Eth_GetByte;
  Hi(len_data) := ReadFromEthMem(EthMemAddressRequest+16);
  Lo(len_data) := Eth_GetByte;
  len_ack := len_data;
  PacketLen := len_data - 40;
  CopyEthMemToEthMem(EthMemAddressRequest,TXSTART,len_data+14); // Total Length does not include physical layer information
  WriteToEthMem(TXSTART+24,$00);
  Eth_PutByte($00);
  if cksum_ip <> Eth_Cksum(TXSTART+14,20) then
    Exit;
  Align := len_data and $01;
  WriteToEthMem(TXSTART+50,$00);
  Eth_PutByte($00);
  WriteToEthMem(TXSTART+len_data+14,$00);
  Eth_PutByte($00);
  CopyEthMemToEthMem(TXSTART+26,TXSTART+len_data+Align+14,8);
  WriteToEthMem(TXSTART+len_data+Align+22,$00);
  Eth_PutByte($06);
  len_data := len_data - 20;
  Eth_PutByte(Hi(len_data));
  Eth_PutByte(Lo(len_data));
  if CkSum_TCP <> Eth_Cksum(TXSTART+34,len_data + Align + 12) then
    Exit;
  Hi(dest_port2) := ReadFromEthMem(EthMemAddressRequest+34);
  Lo(dest_port2) := Eth_GetByte;
  TCP_FlagReceive := ReadFromEthMem(EthMemAddressRequest + 47);
  CopyEthMemToRam_Inv(EthMemAddressRequest + 38,@SEQ_NoR,4);
  CopyEthMemToRam_Inv(EthMemAddressRequest + 42,@ACK_NoR,4);
  Hi(Window) := ReadFromEthMem(EthMemAddressRequest+48);
  Lo(Window) := Eth_GetByte;
  CopyEthMemToRam(EthMemAddressRequest + 26,@dest_ip_addr,4);
  CopyEthMemToRam(EthMemAddressRequest + 6, @dest_mac2,6);

  {$IFDEF LOG_UART}
  s1 := 'TCP Flags: |';
  if TCP_FlagReceive.FIN = 1 then
    s1 := s1 + 'FIN|';
  if TCP_FlagReceive.SYN = 1 then
    s1 := s1 + 'SYN|';
  if TCP_FlagReceive.RST = 1 then
    s1 := s1 + 'RST|';
  if TCP_FlagReceive.PSH = 1 then
    s1 := s1 + 'PSH|';
  if TCP_FlagReceive.ACK = 1 then
    s1 := s1 + 'ACK|';
  if TCP_FlagReceive.URG = 1 then
    s1 := s1 + 'URG|';
  UART1_Write_Text(+s1+LF);
  {$ENDIF}

  // Handle RST..................................................................
  if TCP_FlagReceive.RST = 1 then
  begin
    {$IFDEF LOG_UART}UART1_Write_Text('TCP Rx: Handling RST'+LF);{$ENDIF}
    iSocket := TCP_Find_Any_Connection(dest_ip_addr, dest_port2);
    if iSocket >= 0 then
    begin
      {$IFDEF LOG_UART}UART1_Write_Text('TCP Rx: Found the Socket to Reset'+LF);{$ENDIF}
      SocketManager.Socket[iSocket].State.SOCKET_STATE_DISCONNECTED := 1;
      SocketManager.Socket[iSocket].State.SOCKET_STATE_WAITING_FOR_CONNECTION := 0;
      SocketManager.Socket[iSocket].State.SOCKET_STATE_CONNECTED := 0;
      SocketManager.Socket[iSocket].Keep_Alive := False;
      SocketManager.Socket[iSocket].Wait_ACK := 0;
    end;

    {$IFDEF LOG_UART}
    if iSocket < 0 then
      UART1_Write_Text('TCP Rx: Count not find the Socket to Reset'+LF);
    {$ENDIF}
    {$IFDEF LOG_UART}UART1_Write_Text('TCP Rx: Handling a RST, done we are out of here'+LF);{$ENDIF}
    
    Exit;
  end;
  // Handle RST..................................................................

  // Handle FIN..................................................................
  if PacketLen = 0 then
  begin
    {$IFDEF LOG_UART}UART1_Write_Text('TCP Rx: Packet Length = 0 Handling....'+LF);{$ENDIF}
    
    if TCP_FlagReceive.FIN = 1 then
    begin
      {$IFDEF LOG_UART}UART1_Write_Text('TCP Rx: Handling FIN'+LF);{$ENDIF}
      iSocket := TCP_Find_Any_Connection(dest_ip_addr, dest_port2);
      if iSocket >= 0 then
      begin
        {$IFDEF LOG_UART}UART1_Write_Text('TCP Rx: Handling FIN and found Socket'+LF);{$ENDIF}
        SocketManager.Socket[iSocket].State.SOCKET_STATE_DISCONNECTED := 1;
        SocketManager.Socket[iSocket].State.SOCKET_STATE_WAITING_FOR_CONNECTION := 0;
        SocketManager.Socket[iSocket].State.SOCKET_STATE_CONNECTED := 0;
        SocketManager.Socket[iSocket].Keep_Alive := False;
        SocketManager.Socket[iSocket].Wait_ACK := 0;
      end;

      {$IFDEF LOG_UART}
      if iSocket < 0 then
        UART1_Write_Text('TCP Rx: Handling FIN and could not find Socket'+LF);
      {$ENDIF}

      if TCP_FlagReceive.RST = 1 then    // This should have been detected above and there is no way this block of code should ever get called
      begin
        {$IFDEF LOG_UART}UART1_Write_Text('TCP Rx: Handling FIN with a RST we are out of here'+LF);{$ENDIF}
        Exit; // Note that RST packets are not acknowledged.
      end;

      SEQ_No := ACK_NoR;
      ACK_No := SEQ_NoR + 1;

      if TCP_FlagReceive.ACK = 1 then
      begin
        {$IFDEF LOG_UART}UART1_Write_Text('TCP Rx: Hanlding FIN with an ACK, asking for a 3 step finish (FIN+ACK), just send and ACK'+LF);{$ENDIF}
        TCP_FlagSend := ACK_S                 // FIN + ACK, response only with ACK
      end else 
      begin
        if TCP_FlagReceive.FIN = 1 then      // We have already established this is true here...
        begin
          {$IFDEF TRACE_TCP_RX}UART1_Write_Text('TCP Rx: Handling FIN by itself, normal dual question/answer finish (FIN+ACK) send an ACK+FIN to ACK the FIN and send our own FIN'+LF);{$ENDIF}
          TCP_FlagSend := ACK_S + FIN_S;   // FIN response with FIN + ACK
        end
      end;
      CopyEthMemToEthMem(EthMemAddressRequest + 6, TXSTART, 6);                 // Copy the Source MAC of the received packet to the Dest MAC of the packet to send
      CopyRamToEthMem(@Settings.eth_mac, TXSTART + 6, 6);                       // Copy the Source MAC (us) to the Source MAC of the packet to transmit
      CopyRamToEthMem(@Settings.eth_ip_addr, TXSTART + 26, 4);                  // Copy the Source IP (us) to the Source IP of the packet to transmit
      CopyEthMemToEthMem(EthMemAddressRequest + 26, TXSTART + 30, 4);           // Copy the Source IP of the received packet to the Dest IP of the transmit packet
      TCP_WriteToWire_Internal(source_port2, dest_port2, 0, SEQ_No, ACK_No, TCP_FlagSend); // Send it out
      {$IFDEF LOG_UART}UART1_Write_Text('TCP Rx: Handling FIN done, we are out of here'+LF);{$ENDIF}
      Exit;
    end;
  end;
  // Handle FIN..................................................................

  // Handle SYN..................................................................
  if TCP_FlagReceive.SYN = 1 then // SYN
  begin
    {$IFDEF LOG_UART}UART1_Write_Text('TCP Rx: Handling a SYN'+LF);{$ENDIF}
    iSocket := TCP_Find_Any_Connection(dest_ip_addr, dest_port2);
    if iSocket < 0 then
    begin
      {$IFDEF LOG_UART}UART1_Write_Text('TCP Rx: Handling a SYN, could not find allocated Socket'+LF);{$ENDIF}
      iSocket := TCP_Find_Free_Socket;
    end else
    begin
      {$IFDEF LOG_UART}UART1_Write_Text('TCP Rx: Handling a SYN, found allocated Socket'+LF);{$ENDIF}
    end;

    if iSocket < 0 then
    begin
      {$IFDEF LOG_UART}UART1_Write_Text('TCP Rx: Handling a SYN, could not find free Socket we are out of here'+LF);{$ENDIF}
      Exit;
    end;

    SEQ_No := ACK_NoR;
    ACK_No := SEQ_NoR + 1;

    if TCP_FlagReceive.ACK = 1 then // If we opened the connection and the other node has replied with a SYN+ACK
    begin
      {$IFDEF LOG_UART}UART1_Write_Text('TCP Rx: Handling a SYN with and ACK, we opened the connection and the other node has replied with a SYN+ACK, our connection is now OPEN. reply with an ACK'+LF);{$ENDIF}
      TCP_FlagSend := ACK_S;
      Align := 0;
      SocketManager.Socket[iSocket].State.SOCKET_STATE_DISCONNECTED := 0;
      SocketManager.Socket[iSocket].State.SOCKET_STATE_WAITING_FOR_CONNECTION := 0;
      SocketManager.Socket[iSocket].State.SOCKET_STATE_CONNECTED := 1;
    end else
    begin                           // If we are listening and a client asks to open a connection by sending just a ACK
      {$IFDEF LOG_UART}UART1_Write_Text('TCP Rx: Handling a SYN by itself, we are listening and a client asks to open a connection by sending just a ACK, reply with a SYN+ACK'+LF);{$ENDIF}
      TCP_FlagSend := SYN_S + ACK_S;
      Align := 8;
      SocketManager.Socket[iSocket].State.SOCKET_STATE_DISCONNECTED := 0;
      SocketManager.Socket[iSocket].State.SOCKET_STATE_WAITING_FOR_CONNECTION := 1;
      SocketManager.Socket[iSocket].State.SOCKET_STATE_CONNECTED := 0;
    end;

    SocketManager.Socket[iSocket].Wait_Ack := 0;
    SocketManager.Socket[iSocket].SequenceNumber := SEQ_No;
    SocketManager.Socket[iSocket].ACK_No_S := ACK_No;
    SocketManager.Socket[iSocket].dest_port_S := dest_port2;
    SocketManager.Socket[iSocket].source_port_S := source_port2;
    Mem_Cpy(@SocketManager.Socket[iSocket].Dest_Ip, @dest_ip_addr, 4);
    Mem_Cpy(@SocketManager.Socket[iSocket].Dest_Mac, @dest_mac2, 6);
    SocketManager.Socket[iSocket].ExpireTimeCount := 0;
    SocketManager.Socket[iSocket].Start_addr := 0;
    SocketManager.Socket[iSocket].Stop_addr := 0;
    SocketManager.Socket[iSocket].Keep_Alive := True; // Keep Alive

    CopyEthMemToEthMem(EthMemAddressRequest + 6, TXSTART, 6);
    CopyRamToEthMem(@Settings.eth_mac, TXSTART + 6, 6);
    CopyRamToEthMem(@Settings.eth_ip_addr, TXSTART + 26, 4);
    CopyEthMemToEthMem(EthMemAddressRequest + 26, TXSTART + 30, 4);
    TCP_WriteToWire_Internal(source_port2, dest_port2, Align, SEQ_No, ACK_No, TCP_FlagSend);
    {$IFDEF LOG_UART}UART1_Write_Text('TCP Rx: Handling SYN done, we are out of here'+LF);{$ENDIF}
    Exit;
  end;
  // Handle SYN..................................................................

  // Handle ACK..................................................................
  if TCP_FlagReceive.ACK = 1 then // ACK
  begin
    {$IFDEF LOG_UART}UART1_Write_Text('TCP Rx ACK Handling.....'+LF);{$ENDIF}
    iSocket := TCP_Find_Any_Connection(dest_ip_addr, dest_port2);

    if iSocket >= 0 then
    begin
      {$IFDEF LOG_UART}UART1_Write_Text('TCP Rx: Handling a ACK, found allocated Socket'+LF);{$ENDIF}
      if (SocketManager.Socket[iSocket].State.SOCKET_STATE_WAITING_FOR_CONNECTION = 1) {or (SocketManager.Socket[iSocket].Wait_ACK <> 0)} then
      begin
        {$IFDEF LOG_UART}UART1_Write_Text('TCP Rx: Handling a ACK, this was an ACK in response to a SYN (us) - SYN+ACK (them), connection is complete'+LF);{$ENDIF}
        SocketManager.Socket[iSocket].State.SOCKET_STATE_DISCONNECTED := 0;
        SocketManager.Socket[iSocket].State.SOCKET_STATE_WAITING_FOR_CONNECTION := 0;
        SocketManager.Socket[iSocket].State.SOCKET_STATE_CONNECTED := 1;
        SocketManager.Socket[iSocket].Wait_ACK := 0;
        SocketManager.Socket[iSocket].ACK_No_S := SEQ_NoR;
        SocketManager.Socket[iSocket].SequenceNumber := ACK_NoR;
        SocketManager.Socket[iSocket].ExpireTimeCount := 0; // keep Alive
        Exit;
      end else
      begin                                       
        {$IFDEF LOG_UART}
        if PacketLen > 0 then
          UART1_Write_Text('TCP Rx: Handling a ACK, this is a data packet being sent to us'+LF)
        else
          UART1_Write_Text('TCP Rx: Handling a ACK, this is a reply for something we sent'+LF);
        {$ENDIF}

        SEQ_No := ACK_NoR;
        ACK_No := SEQ_NoR + PacketLen;
        TCP_FlagSend := ACK_S;

        SocketManager.Socket[iSocket].SequenceNumber := SEQ_No;
        SocketManager.Socket[iSocket].ACK_No_S := ACK_No;
        SocketManager.Socket[iSocket].ExpireTimeCount := 0; // keep Alive

        if PacketLen <> 0 then                                                // We were sent data so we must ACK back
        begin
          // Can combine the needed reply ACKs
          SocketManager.Socket[iSocket].dest_port_S := dest_port2;
          SocketManager.Socket[iSocket].source_port_S := source_port2;
          CopyEthMemToEthMem(EthMemAddressRequest + 6, TXSTART, 6);
          CopyRamToEthMem(@Settings.eth_mac, TXSTART + 6, 6);
          CopyRamToEthMem(@Settings.eth_ip_addr, TXSTART + 26, 4);
          CopyEthMemToEthMem(EthMemAddressRequest + 26, TXSTART + 30, 4);
          TCP_WriteToWire_Internal(source_port2, dest_port2, 0, SEQ_No, ACK_No, TCP_FlagSend);
        end;

        SocketManager.Socket[iSocket].Wait_ACK := 0; // Handled above
        Align := ReadFromEthMem(EthMemAddressRequest + 53); // dummy read puts rx pointer to start of TCP data.
        if PacketLen <> 0 then
        begin
          CopyEthMem_CPToRam(word(@SocketManager.Socket[iSocket].TCP_buf), PacketLen);
          SocketManager.Socket[iSocket].Start_addr := 0;
          SocketManager.Socket[iSocket].Stop_addr := PacketLen;
          Eth_UserTCP(dest_ip_addr, source_port2, dest_port2, PacketLen, iSocket);
          {$IFDEF LOG_UART}UART1_Write_Text('TCP Rx: Handling a ACK, data packet, sent to Eth_UserTCP'+LF);{$ENDIF}
        end
      end;
    end else
    begin
      {$IFDEF LOG_UART}UART1_Write_Text('TCP Rx ACK Handling Socket not found'+LF);{$ENDIF}
    end;
    {$IFDEF LOG_UART}UART1_Write_Text('TCP Rx: Handling a ACK, done we are out of here'+LF);{$ENDIF}
  end;
  // Handle ACK..................................................................
end;

 *)
 

end.