unit EthTCP;

{.$DEFINE LOG_UART}
{.$DEFINE TRACE_SOCKET_STATE}
{.$DEFINE TRACE_ETHERNET_TX}
{.$DEFINE TRACE_ETHERNET_RX}
{.$DEFINE TRACE_ETHERNET_SOCKET_RX}

{$I Options.inc}

uses


NMRAnetDefinesShared,

  EthCommon,
  EthSockets,
  dspic_additional_string_library,
  lib1_enc600_V3_5_b,
  definitions_ENC600,
  ENCJ600;



  
// User Functions
function TCP_TryLoadTransmitterAndSend(var Socket: TSocket; TCP_Flags: Byte; TxMemoryAddress: Word): Boolean;

// Internally used Functions
procedure TCP_Process_Stack;
procedure TCP_Process_Receive(RxMemoryAddress: Word);

implementation

// *****************************************************************************
// PrintHeader
//   Parmeters: Header: The data to print
//              LineCount: The number of 32 bit lines to print from the Header
//   Results:
//   Description: Prints the contents of the Header to UART1
// *****************************************************************************
procedure PrintHeader(var Header: TEthernetHeader; LineCount: Integer);
var
  i, j: Integer;
begin
  for i := 0 to LineCount - 1 do
  begin
    UART1_Write_Text('0x');
    for j := 0 to 3 do
    begin
      ByteToHex( Header[i][j], s1);
      UART1_Write_Text(s1);
    end;
    UART1_Write_Text(LF);
  end;
end;

// *****************************************************************************
// PrintPhysicalHeader
//   Parmeters: PhyHeader: The data to print
//   Results:
//   Description: Prints the contents of the Header to UART1
// *****************************************************************************
procedure PrintPhysicalHeader(var PhyHeader: TPhysicalLayerHeader);
begin
  UART1_Write_Text(LF+LF+'....Printing Physical Layer Header.... '+LF);
  Mac2Str(PhyHeader.DestMacAddress, s1);
  UART1_Write_Text('0x' + s1 + ' [Physical Header Dest MAC]' + LF);
  Mac2Str(PhyHeader.SourceMacAddress, s1);
  UART1_Write_Text('0x' + s1 + ' [Physical Header Source MAC]' + LF);
  ByteToHex(PhyHeader.Protocol[0], s1);
  UART1_Write_Text('0x' + s1 + ' [Phy Protocol]' + LF);
end;

// *****************************************************************************
// LoadIPHeaderLine0
//   Parmeters: HeaderLine: The first 4 Byte structure in the IP Header
//              IP_Version: The version of IP (typcically 4);
//              IHL: Number of these 4 Byte lines in this structure
//              DSCP: See the IP Header for details, not used often
//              ECN: See the IP Header for details, not used often
//              PacketLength: The Total Length of the packet (not just the IP Header) including any headers and the data
//   Results:
//   Description: Helper function for TCP_TryLoadTransmitterAndSend
// *****************************************************************************
procedure LoadIPHeaderLine0(var HeaderLine: TEthernetHeaderLine; IP_Version, IHL, DSCP, ECN: Byte; PacketLength: Word);
begin
  HeaderLine[0] := (IP_Version shl 4) or IHL;
  HeaderLine[1] := (DSCP shl 2) or ECN;
  HeaderLine[2] := Hi(PacketLength);
  HeaderLine[3] := Lo(PacketLength);
end;

// *****************************************************************************
// LoadIPHeaderLine1
//   Parmeters: HeaderLine: The second 4 Byte structure in the IP Header
//              Identification: The ID number of the stream (useful in reconstucting fragmented packets if supported)
//              FragmentationFlags: Does the packet support Fragmentation or just drop it
//              FragmentationOffset: If fragmented then this is the offset from start of the first packet to allow reconstruction
//   Results:
//   Description: Helper function for TCP_TryLoadTransmitterAndSend
// *****************************************************************************
procedure LoadIPHeaderLine1(var HeaderLine: TEthernetHeaderLine; Identification: Word; FragmentationFlags: Byte; FragmentationOffset: Word);
begin
  HeaderLine[0] := Hi(Identification);
  HeaderLine[1] := Lo(Identification);
  HeaderLine[2] := (FragmentationFlags shl 5) or (Hi(FragmentationOffset) shr 3);
  HeaderLine[3] := Lo(FragmentationOffset)
end;

// *****************************************************************************
// LoadIPHeaderLine2
//   Parmeters: HeaderLine: The third 4 Byte structure in the IP Header
//              Protocol: The Protocol of the message, for TCP this is $06
//   Results:
//   Description: Helper function for TCP_TryLoadTransmitterAndSend
// *****************************************************************************
procedure LoadIPHeaderLine2(var HeaderLine: TEthernetHeaderLine; TimeToLive, Protocol: Byte);
begin
  HeaderLine[0] := TimeToLive;
  HeaderLine[1] := Protocol;
  HeaderLine[2] := 0;                                                           // Checksum comes after all of the header is filled in
  HeaderLine[3] := 0
end;

// *****************************************************************************
// LoadIPHeaderLine3
//   Parmeters: HeaderLine: The fourth 4 Byte structure in the IP Header
//              SourceIP: IP Address of this node
//   Results:
//   Description: Helper function for TCP_TryLoadTransmitterAndSend
// *****************************************************************************
procedure LoadIPHeaderLine3(var HeaderLine: TEthernetHeaderLine; var SourceIP: TIPAddress);
begin
  HeaderLine := SourceIP;
end;

// *****************************************************************************
// LoadIPHeaderLine3
//   Parmeters: HeaderLine: The fifth 4 Byte structure in the IP Header
//              SourceIP: IP Address of the node we are sending the packet to
//   Results:
//   Description: Helper function for TCP_TryLoadTransmitterAndSend
// *****************************************************************************
procedure LoadIPHeaderLine4(var HeaderLine: TEthernetHeaderLine; var DestIP: TIPAddress);
begin
  HeaderLine := DestIP;
end;

// *****************************************************************************
// LoadTCPHeaderLine0
//   Parmeters: HeaderLine: The first 4 Byte structure in the TCP Header
//              SourcePort: Port we are assigned for this socket
//              DestPort: Port assigned to the destination IP for this socket
//   Results:
//   Description: Helper function for TCP_TryLoadTransmitterAndSend
// *****************************************************************************
procedure LoadTCPHeaderLine0(var HeaderLine: TEthernetHeaderLine; SourcePort, DestPort: Word);
begin
  HeaderLine[0] := Hi(SourcePort);
  HeaderLine[1] := Lo(SourcePort);
  HeaderLine[2] := Hi(DestPort);
  HeaderLine[3] := Lo(DestPort);
end;

// *****************************************************************************
// LoadTCPHeaderLine1
//   Parmeters: HeaderLine: The second 4 Byte structure in the TCP Header
//              SequenceNumber: The number of bytes we have sent (relative to a random start number)
//   Results:
//   Description: Helper function for TCP_TryLoadTransmitterAndSend
// *****************************************************************************
procedure LoadTCPHeaderLine1(var HeaderLine: TEthernetHeaderLine; SequenceNumber: DWord);
var
  TempHi, TempLo: Word;
begin
  // Little Endian forces this
  TempHi := Hi(SequenceNumber);
  TempLo := Lo(SequenceNumber);
  HeaderLine[0] := Hi(TempHi);
  HeaderLine[1] := Lo(TempHi);
  HeaderLine[2] := Hi(TempLo);
  HeaderLine[3] := Lo(TempLo);
end;

// *****************************************************************************
// LoadTCPHeaderLine2
//   Parmeters: HeaderLine: The third 4 Byte structure in the TCP Header
//              AckNumber: The number of bytes we acknowledged we have received from the destination
//   Results:
//   Description: Helper function for TCP_TryLoadTransmitterAndSend
// *****************************************************************************
procedure LoadTCPHeaderLine2(var HeaderLine: TEthernetHeaderLine; AckNumber: DWord);
var
  TempHi, TempLo: Word;
begin
  // Little Endian forces this
  TempHi := Hi(AckNumber);
  TempLo := Lo(AckNumber);
  HeaderLine[0] := Hi(TempHi);
  HeaderLine[1] := Lo(TempHi);
  HeaderLine[2] := Hi(TempLo);
  HeaderLine[3] := Lo(TempLo);
end;

// *****************************************************************************
// LoadTCPHeaderLine3
//   Parmeters: HeaderLine: The fourth 4 Byte structure in the TCP Header
//              DataOffset: Number of 4 Byte Lines in this Header
//              TCP_Flags: The TCP Flags (SYN, FIN, ACK, FIN, ect)
//              WindowSize: Sliding window size for our reception
//   Results:
//   Description: Helper function for TCP_TryLoadTransmitterAndSend
// *****************************************************************************
procedure LoadTCPHeaderLine3(var HeaderLine: TEthernetHeaderLine; DataOffset: Byte; TCP_Flags, WindowSize: Word);
begin
  HeaderLine[0] := (DataOffset shl 4) or (Hi(TCP_Flags) and $0001);
  HeaderLine[1] := Lo(TCP_Flags);
  HeaderLine[2] := Hi(WindowSize);
  HeaderLine[3] := Lo(WindowSize);
end;

// *****************************************************************************
// LoadTCPHeaderLine4
//   Parmeters: HeaderLine: The fifth 4 Byte structure in the TCP Header
//              UrgentPtr: Address to the urgent data, not used often
//   Results:
//   Description: Helper function for TCP_TryLoadTransmitterAndSend
// *****************************************************************************
procedure LoadTCPHeaderLine4(var HeaderLine: TEthernetHeaderLine; UrgentPtr: Word);
begin
  HeaderLine[0] := 0;               // Calcuate Checksum later
  HeaderLine[1] := 0;               // Calcuate Checksum later
  HeaderLine[2] := Hi(UrgentPtr);
  HeaderLine[3] := Lo(UrgentPtr);
end;

// *****************************************************************************
// HeaderLineToDWord
//   Parmeters: HeaderLine: A 4 Byte structure in the TCP Header
//   Results: The 4 Bytes contacted in to a DWord
//   Description: Helper function for TCP_Process_Receive
// *****************************************************************************
function HeaderLineToDWord(var HeaderLine: TEthernetHeaderLine): DWord;
var
  TempHi, TempLo: Word;
begin
  Hi( TempHi) := HeaderLine[0];
  Lo( TempHi) := HeaderLine[1];
  Hi( TempLo) := HeaderLine[2];
  Lo( TempLo) := HeaderLine[3];
  Hi( Result) := TempHi;
  Lo( Result) := TempLo;
end;

// *****************************************************************************
// TCP_TryLoadTransmitterAndSend
//   Parmeters: Socket: Socket to send the data for
//              TCP_Flags: The TCP Flags (SYN, FIN, ACK, FIN, ect)
//              TxMemoryAddress: Where in the Ethernet memory space to create the Transmit Packet
//   Results:
//   Description: Load up a complient Ethernet packet and enables the Ehternet IC to transmit.
//                It does NOT wait for the transmit to occur, poll EthernetTransmitIdle to
//                determine if the transmission is complete
// *****************************************************************************
function TCP_TryLoadTransmitterAndSend(var Socket: TSocket; TCP_Flags: Byte; TxMemoryAddress: Word): Boolean;
var
  Header: TEthernetHeader;
  PhyHeader: TPhysicalLayerHeader;
  CheckSum, MessageLength, TcpHeaderAndDataLength: Word;
  TcpDataLength: DWord;
begin
  Result := False;
  if EthernetTransmitIdle then       // Only load if the ethernet chip transmitter is empty
  begin
  
  // NOT SENDING AN ACK (EXCEPT FOR DURING A SYN) IS AN ERROR, MUST ALWAYS SEND AN ACK
  
   {$IFDEF TRACE_ETHERNET_TX}PrintSocket(Socket);{$ENDIF}
    
    CheckSum := 0;
    MessageLength := 0;
    
    PhyHeader.DestMacAddress := Socket.DestMAC;
    PhyHeader.SourceMacAddress := Settings.eth_mac;
    PhyHeader.Protocol[0] := $08;                   // IP Protocol
    PhyHeader.Protocol[1] := $00;
    CopyRamToEthMem(@PhyHeader, TxMemoryAddress + PHYSICAL_LAYER_HEADER_OFFSET, PHYSICAL_LAYER_HEADER_SIZE);
    
    {$IFDEF TRACE_ETHERNET_TX}PrintPhysicalHeader(PhyHeader);{$ENDIF}
    
    TcpDataLength := Socket.Stop_addr - Socket.Stop_addr;
    MessageLength := TCP_HEADER_SIZE + IP_HEADER_SIZE + TcpDataLength;
    
    LoadIPHeaderLine0(Header[0], Settings.IP_Version, 5, Settings.IP_DSCP, Settings.IP_ECN, MessageLength);
    LoadIPHeaderLine1(Header[1], Socket.Identification, Settings.IP_FragmentationFlags, 0);
    LoadIPHeaderLine2(Header[2], Settings.IP_TimeToLive, PROTOCOL_TCP);
    LoadIPHeaderLine3(Header[3], Settings.eth_ip_addr);
    LoadIPHeaderLine4(Header[4], Socket.DestIP);
    CopyRamToEthMem(@Header, TxMemoryAddress + PHYSICAL_LAYER_HEADER_SIZE, IP_HEADER_SIZE);
    CheckSum := Eth_Cksum(TxMemoryAddress + PHYSICAL_LAYER_HEADER_SIZE, IP_HEADER_SIZE);    // Let ENC calculate the Checksum for the IP Header data
    WriteToEthMem(TxMemoryAddress + IP_CHECKSUM_OFFSET ,Hi(CheckSum)); // Stored in little endian form so Copying Ram puts the bytes backwards
    Eth_PutByte(Lo(CheckSum));
    
    {$IFDEF TRACE_ETHERNET_TX}UART1_Write_Text('IP Header: ' + LF); PrintHeader(Header, IP_HEADER_SIZE div MAX_ETHERNET_HEADERLINE_BYTES); WordToHex(CheckSum, s1); UART1_Write_Text('IP Checksum: 0x' + s1 + LF); WordToStr(MessageLength, s1); UART1_Write_Text('MessageLength: ' + s1 + LF);{$ENDIF}
  
    LoadTCPHeaderLine0(Header[0], Socket.SourcePort, Socket.DestPort);

    if TCP_Flags and SYN_S <> 0 then                                            // Special case
    begin
      LoadTCPHeaderLine2(Header[1], Socket.SequenceNumber);                     // Our initial Sequence Number of SYN is set or the total number of bytes we have sent to the other node of not SYN
      LoadTCPHeaderLine2(Header[2], 0)                                          // Ack Number = 0 by definition
    end else 
    begin
      Socket.SequenceNumber := Socket.SequenceNumber + TcpDataLength;           // Update the sequence to data sent THIS IS NOT RIGHT FOR A SLIDING WINDOW
      LoadTCPHeaderLine2(Header[1], Socket.SequenceNumber);
      if TCP_Flags and ACK_S <> 0 then
        LoadTCPHeaderLine2(Header[2], Socket.AckNumber)                         // Tell the other socket how many bytes we have received from it so far
      else
        LoadTCPHeaderLine2(Header[2], 0);                                       // If the flag is not set then send 0 (per the spec)
    end;
      
    LoadTCPHeaderLine3(Header[3], 5, TCP_Flags, 1024);
    LoadTCPHeaderLine4(Header[4], 0);
    CopyRamToEthMem(@Header, TxMemoryAddress + TCP_HEADER_OFFSET, TCP_HEADER_SIZE);
    CopyRamToEthMem(Socket.Start_addr, TxMemoryAddress + TCP_DATA_OFFSET, TcpDataLength);
    
    // Need to add the Psudo header per the standard, this include Source IP, Dest IP, 8 bits of zeros, Protocol from the IP header, 
    // TCP Length (header + data) all added to the TCP Header and data
    CopyEthMemToEthMem(TxMemoryAddress + IP_SOURCE_ADDRESS_OFFSET, TxMemoryAddress + TCP_DATA_OFFSET + TcpDataLength, 8); // Copy the IP Source and Destination Addresses after the Tcp Data to calculate the Psudo Header
    WriteToEthMem(TxMemoryAddress + TCP_DATA_OFFSET + TcpDataLength + 8, $00);
    Eth_PutByte(PROTOCOL_TCP);
    TcpHeaderAndDataLength := TCP_HEADER_SIZE + TcpDataLength;
    Eth_PutByte(Hi( TcpHeaderAndDataLength));
    Eth_PutByte(Lo( TcpHeaderAndDataLength));
    CheckSum := Eth_Cksum(TxMemoryAddress + TCP_HEADER_OFFSET, TCP_HEADER_SIZE + TcpDataLength + PSUDO_HEADER_SIZE);    // Let ENC calculate the Checksum
    WriteToEthMem(TxMemoryAddress + TCP_CHECKSUM_OFFSET ,Hi(CheckSum)); // Stored in little endian form so Copying Ram puts the bytes backwards
    Eth_PutByte(Lo(CheckSum));
   
   {$IFDEF TRACE_ETHERNET_TX}UART1_Write_Text('TCP Header: ' + LF); PrintHeader(Header, TCP_HEADER_SIZE div MAX_ETHERNET_HEADERLINE_BYTES); WordToHex(CheckSum, s1); UART1_Write_Text('TCP Checksum: 0x' + s1 + LF);{$ENDIF}

    Ethernet_Send(TxMemoryAddress, MessageLength + PHYSICAL_LAYER_HEADER_SIZE);          // Enable the data transmit
    
    Result := True;
  end;
end;

// *****************************************************************************
// TCP_Process_Receive
//   Parmeters: RxMemoryAddress: Where in the Ethernet memory space the received Packet is
//   Results:
//   Description: Reads and Decodes the Ehternet packet to allow the application
//                to handle the received data, or automatically hanldles SYN, FIN, RST, etc
// *****************************************************************************
procedure TCP_Process_Receive(RxMemoryAddress: Word);
var
  Header: TEthernetHeader;
  PhysicalLayerHeader: TPhysicalLayerHeader;                                              // Current info for the Physical Layer of the current transmission
  Checksum: Word;
  iSocket: Integer;
  Socket: ^TSocket;
  Local_IP_HeaderSize, Local_TCP_HeaderSize, Local_TCP_HeaderStart, Local_IP_HeaderStart, Local_TCP_PacketSize, Local_TCP_DataSize, Local_PacketSize: Word;
  TargetAddress, SourceAddress: TIPAddress;
  TargetPort, SourcePort: Word;
  Local_IP_Protocol: Byte;
begin
  // We already know this is a TCP packet when it enters this procedure   
  {$IFDEF TRACE_ETHERNET_RX}UART1_Write_Text(LF+LF+'....Reading Physical Layer Header.... '+LF);{$ENDIF}
  CopyEthMemToRam(RxMemoryAddress, @PhysicalLayerHeader, PHYSICAL_LAYER_HEADER_SIZE);            // 1 to 1 mapping overlay for the phy header, easy
  
  {$IFDEF TRACE_ETHERNET_RX}UART1_Write_Text(LF+LF+'....Reading IP Header.... '+LF);{$ENDIF}
  
  Local_IP_HeaderStart := RxMemoryAddress + PHYSICAL_LAYER_HEADER_SIZE;
  Local_IP_HeaderSize := (ReadFromEthMem(Local_IP_HeaderStart + IP_IHL_RELATIVE_OFFSET) and $0F) * MAX_ETHERNET_HEADERLINE_BYTES;
  CopyEthMemToRam(Local_IP_HeaderStart, @Header, Local_IP_HeaderSize);          // Read in the entire IP Header
  Hi(CheckSum) := Header[2][2];                                                 // Extract the Checksum from the Header we read
  Lo(CheckSum) := Header[2][3];
  MemCpy(@SourceAddress, @Header[3], 4);
  MemCpy(@TargetAddress, @Header[4], 4);
  Local_IP_Protocol := Header[2][1];
  Hi(Local_PacketSize) := Header[0][2];                                       // Extract the total message size to back calculate the Data Size
  Lo(Local_PacketSize) := Header[0][3];
  
  {$IFDEF TRACE_ETHERNET_RX}
  WordToStr(Local_IP_HeaderStart, s1);
  UART1_Write_Text('IP Header Start: ' + s1 + LF);
  WordToStr(Local_IP_HeaderSize, s1);
  UART1_Write_Text('IP Header Size: ' + s1 + LF);
  UART1_Write_Text('IP Header: ' + LF);
  PrintHeader(Header, Local_IP_HeaderSize div MAX_ETHERNET_HEADERLINE_BYTES);
  WordToHex(CheckSum, s1); UART1_Write_Text('CheckSum: 0x' + s1 + LF);
  Ip2Str(SourceAddress, s1); 
  UART1_Write_Text('Source IP Address: ' + s1 + LF);
  Ip2Str(TargetAddress, s1); UART1_Write_Text('Target IP Address: ' + s1 + LF);
  {$ENDIF}
  
  WriteToEthMem(Local_IP_HeaderStart + IP_CHECKSUM_RELATIVE_OFFSET, $00);       // Put $0000 in for the Checksum to calculate
  Eth_PutByte($00);
  
  if CheckSum = Eth_Cksum(Local_IP_HeaderStart, Local_IP_HeaderSize) then       // Calcuate the checksum in the IP Header data in the chip and compare
  begin
    {$IFDEF TRACE_ETHERNET_RX}UART1_Write_Text(LF+LF+'....Reading TCP Header.... '+LF);{$ENDIF}
    
    Local_TCP_HeaderStart := Local_IP_HeaderStart + Local_IP_HeaderSize;
    Local_TCP_HeaderSize := ((ReadFromEthMem(Local_TCP_HeaderStart + TCP_HEADER_LENGTH_RELATIVE_OFFSET)) shr 4) * MAX_ETHERNET_HEADERLINE_BYTES;
    Local_TCP_DataSize := Local_PacketSize - Local_IP_HeaderSize - Local_TCP_HeaderSize;   // Calculate the Data Size in the TCP Payload
    Local_TCP_PacketSize := Local_TCP_HeaderSize + Local_TCP_DataSize;

    CopyEthMemToRam(Local_TCP_HeaderStart, @Header, Local_TCP_HeaderSize);      // Read in the entire TCP Header
    Hi(CheckSum) := Header[4][0];                                               // Extract TCP CheckSum
    Lo(CheckSum) := Header[4][1];
    Hi(SourcePort) := Header[0][0];
    Lo(SourcePort) := Header[0][1];
    Hi(TargetPort) := Header[0][2];
    Lo(TargetPort) := Header[0][3];

    // Need to corrupt the receive buffer by packing the data in front of the TCP header to create the Psudo Header to calcuate the Checksum
    CopyRamToEthMem(@SourceAddress, Local_TCP_HeaderStart - 12, 4);
    CopyRamToEthMem(@TargetAddress, Local_TCP_HeaderStart - 8, 4);
    WriteToEthMem(Local_TCP_HeaderStart - 4, 0);
    Eth_PutByte(Local_IP_Protocol);
    Eth_PutByte( Hi(Local_TCP_PacketSize));
    Eth_PutByte( Lo(Local_TCP_PacketSize));
    WriteToEthMem(Local_TCP_HeaderStart + TCP_CHECKSUM_RELATIVE_OFFSET, $00);      // Put $0000 in for the Checksum
    Eth_PutByte($00);
    
    {$IFDEF TRACE_ETHERNET_RX}
    WordToStr(Local_TCP_HeaderStart, s1);
    UART1_Write_Text('TCP Header Start: ' + s1 + LF);
    WordToStr(Local_TCP_HeaderSize, s1);
    UART1_Write_Text('TCP Header Size: ' + s1 + LF);
    WordToStr(Local_TCP_DataSize, s1);
    UART1_Write_Text('TCP Data Size: ' + s1 + LF);
    WordToStr(Local_TCP_PacketSize, s1);
    UART1_Write_Text('Total TCP Packet Size: ' + s1 + LF);
    ByteToStr(Local_IP_Protocol, s1);
    UART1_Write_Text('IP Protocol: ' + s1 + LF);
    UART1_Write_Text('TCP Header: ' + LF);
    PrintHeader(Header, Local_TCP_HeaderSize div MAX_ETHERNET_HEADERLINE_BYTES);                 
    WordToHex(CheckSum, s1);
    UART1_Write_Text('CheckSum: 0x' + s1 + LF);
    {$ENDIF}

    if Checksum = Eth_Cksum(Local_TCP_HeaderStart - 12, 12 + Local_TCP_PacketSize) then
    begin
      {$IFDEF TRACE_ETHERNET_RX}UART1_Write_Text('TCP Checksum Valid' + LF);{$ENDIF}
      iSocket := TCP_Find_Any_Connection(SourceAddress, SourcePort);                 // This is with respect to the source that sent this message
      if iSocket > -1 then
      begin
        {$IFDEF TRACE_ETHERNET_SOCKET_RX}UART1_Write_Text('Found Socket!' + LF);{$ENDIF}
        Socket := @SocketManager.Socket[iSocket];
        Socket^.TCPReceivedFlags := Socket^.TCPReceivedFlags or (Header[3][1] and $003F);  // Only support first 6 bits of flags
        Socket^.SequenceReceived := HeaderLineToDWord(Header[1]);               // The other end tells us how many bytes it has sent, statemachine will handle it.
        Socket^.AckReceived := HeaderLineToDWord(Header[2]);                    // The other end tells us how many bytes it has received from us
        // Make the decision here if we call the User TCP Handler
        // if IsUserTCPCall then
        //    Call UserTCP
      end
    end
  end
end;

// *****************************************************************************
// TCP_Process_TestForResend
//   Parmeters: Socket: Connection that is being handled in the statemachine
//              ResendState: The state to jump to if the socket needs to resend the message
//   Results:
//   Description: Helper function for TCP_Process_Stack
// *****************************************************************************
procedure TCP_Process_TestForResend(var Socket: TSocket; ResendState: Word);
begin
  if Socket.ResendTimeCount > MAX_TCP_RESEND_TIMEOUT then
    if Socket.ResendAttempts < MAX_TCP_RESEND_ATTEMPTS then
    begin
     {$IFDEF TRACE_SOCKET_STATE}WordToStr(Socket.ResendAttempts, s1);UART1_Write_Text('Trying a Resend, attempt: ' + s1 + LF);{$ENDIF}
      Socket.ExpireTimeCount := 0;
      Socket.ResendTimeCount := 0;
      Inc(Socket.ResendAttempts);
      Socket.iStateMachine := ResendState                   // Resend
    end else
    begin
      {$IFDEF TRACE_SOCKET_STATE}UART1_Write_Text('Out of Resends giving up' + LF);{$ENDIF}
      Socket.iStateMachine := SOCKET_STATE_RESET            // IF CONNECTED THIS SHOULD SEND A FIN-ACK AND GIVE UP
    end;
end;

// *****************************************************************************
// TCP_Process_ClearTimers
//   Parmeters: Socket: Connection that is being handled in the statemachine
//   Results:
//   Description: Helper function for TCP_Process_Stack, clears the Timers in the Socket
// *****************************************************************************
procedure TCP_Process_ClearTimers(var Socket: TSocket);
begin
  {$IFDEF TRACE_SOCKET_STATE}UART1_Write_Text('TCP_Process_ClearTimers' + LF);{$ENDIF}
  Socket.ExpireTimeCount := 0;
  Socket.ResendTimeCount := 0;
end;

// *****************************************************************************
// TCP_Process_ClearTimersAndResendAttempts
//   Parmeters: Socket: Connection that is being handled in the statemachine
//   Results:
//   Description: Helper function for TCP_Process_Stack, clears the Timers in the Socket
//                and resets the Resend Attempts field
// *****************************************************************************
procedure TCP_Process_ClearTimersAndResendAttempts(var Socket: TSocket);
begin
  {$IFDEF TRACE_SOCKET_STATE}UART1_Write_Text('TCP_Process_ClearTimersAndResendAttempts' + LF);{$ENDIF}
  Socket.ExpireTimeCount := 0;
  Socket.ResendTimeCount := 0;
  Socket.ResendAttempts := 0;
end;

// *****************************************************************************
// TCP_Process_Stack
//   Parmeters:
//   Results:
//   Description: Runs the Statemachine for each Socket in the Socket Stack
// *****************************************************************************
procedure TCP_Process_Stack;
var
  Socket: ^TSocket;
begin
  Socket := @SocketManager.Socket[SocketManager.iLastProcessedSocket];
  
  if Socket^.TCPReceivedFlags.SOCKET_FLAG_RECEIVED_RST then
    Socket^.iStateMachine := SOCKET_STATE_RESET;
    
  case Socket^.iStateMachine of
    SOCKET_STATE_DISCONNECTED :
        begin

        end;
    SOCKET_STATE_CONNECT :
        begin   
          {$IFDEF TRACE_SOCKET_STATE}UART1_Write_Text(LF+LF+ 'SOCKET_STATE_CONNECT' + LF);{$ENDIF}
          TCP_Process_ClearTimersAndResendAttempts(Socket^); 
          Socket^.ResendAttempts := 1;                                          // First Try
          Socket^.iStateMachine := SOCKET_STATE_CONNECT_SEND;
        end;
    SOCKET_STATE_CONNECT_SEND :
        begin
          if TCP_TryLoadTransmitterAndSend(Socket^, SYN_S, TXSTART) then
          begin
            {$IFDEF TRACE_SOCKET_STATE}UART1_Write_Text('SOCKET_STATE_CONNECT_SEND' + LF);{$ENDIF}
            TCP_Process_ClearTimers(Socket^);
            Socket^.iStateMachine := SOCKET_STATE_WAITING_FOR_SYN_ACK;
          end;
        end;
    SOCKET_STATE_WAITING_FOR_SYN_ACK :
        begin 
          if Socket^.TCPReceivedFlags.SOCKET_FLAG_RECEIVED_ACK = 1 then                    // Client will send an ACK then a SYN flag (or both at the same time)
          begin
            {$IFDEF TRACE_SOCKET_STATE}UART1_Write_Text('SOCKET_STATE_WAITING_FOR_SYN_ACK' + LF);{$ENDIF}
            Socket^.TCPReceivedFlags.SOCKET_FLAG_RECEIVED_ACK := 0;                        // Clear the ACK flag
          //  Socket^.AckReceived should be equal to Socket^.SequenceNumber + 1 here,  what to do if not??????
            TCP_Process_ClearTimersAndResendAttempts(Socket^);
            Socket^.iStateMachine := SOCKET_STATE_WAITING_FOR_SYN;
          end else
            TCP_Process_TestForResend(Socket^, SOCKET_STATE_CONNECT_SEND);
        end;
    SOCKET_STATE_WAITING_FOR_SYN :
        begin 
          if Socket^.TCPReceivedFlags.SOCKET_FLAG_RECEIVED_SYN = 1 then
          begin
            {$IFDEF TRACE_SOCKET_STATE}UART1_Write_Text('SOCKET_STATE_WAITING_FOR_SYN' + LF);{$ENDIF}
            Socket^.TCPReceivedFlags.SOCKET_FLAG_RECEIVED_SYN := 0;
            Socket^.AckNumber := Socket^.SequenceReceived + 1;                  // Get in syn with the destination nodes sequence number then add one and reply
            TCP_Process_ClearTimersAndResendAttempts(Socket^);
            Socket^.iStateMachine := SOCKET_STATE_SENDING_SYN_ACK;
          end else
            TCP_Process_TestForResend(Socket^, SOCKET_STATE_CONNECT);
        end;
    SOCKET_STATE_SENDING_SYN_ACK :
        begin
          if TCP_TryLoadTransmitterAndSend(Socket^, ACK_S, TXSTART) then
          begin
            {$IFDEF TRACE_SOCKET_STATE}UART1_Write_Text('SOCKET_STATE_SENDING_SYN_ACK' + LF);{$ENDIF}
            TCP_Process_ClearTimers(Socket^);
            Socket^.StateFlags.SOCKET_FLAG_CONNECTED := 1;
            Socket^.iStateMachine := SOCKET_STATE_CONNECTED;
          end;
        end;
    SOCKET_STATE_CONNECTED :
        begin
          if Socket^.Stop_addr - Socket^.Start_addr > 0 then                    // Do we have some data to send?
          begin
            Socket^.ExpireTimeCount := 0;                                              // Reset Expiration time
            if TCP_TryLoadTransmitterAndSend(Socket^, PSH_S + ACK_S, TXSTART) then
            begin
              // Send the data here.....
              if not Socket^.Keep_Alive then
              begin
                TCP_Process_ClearTimersAndResendAttempts(Socket^);
                Socket^.iStateMachine := SOCKET_STATE_DISCONNECT;
              end
            end
          end else
          begin
            if (Socket^.StateFlags.SOCKET_FLAG_FINISH = 1) or (Socket^.ExpireTimeCount > Socket^.ExpireTimeMax) then
            begin
              TCP_Process_ClearTimersAndResendAttempts(Socket^);
              Socket^.iStateMachine := SOCKET_STATE_DISCONNECT;
            end
          end;
        end;
    SOCKET_STATE_DISCONNECT :
        begin
          if TCP_TryLoadTransmitterAndSend(Socket^, FIN_S, TXSTART) then
          begin 
            {$IFDEF TRACE_SOCKET_STATE}UART1_Write_Text('SOCKET_STATE_DISCONNECT' + LF);{$ENDIF}
            Socket^.TCPReceivedFlags.SOCKET_FLAG_RECEIVED_FIN := 0;
            Socket^.TCPReceivedFlags.SOCKET_FLAG_RECEIVED_ACK := 0;
            Socket^.iStateMachine := SOCKET_STATE_WAITING_FOR_FIN_ACK;
          end
        end;
    SOCKET_STATE_WAITING_FOR_FIN_ACK :
        begin
          // We have FIN'ed so we can't send anymore but we can receive until we receive a FIN
          if Socket^.TCPReceivedFlags.SOCKET_FLAG_RECEIVED_ACK = 1 then
          begin    
            {$IFDEF TRACE_SOCKET_STATE}UART1_Write_Text('SOCKET_STATE_WAITING_FOR_FIN_ACK' + LF);{$ENDIF}
            // Update the Acknowledge field here
            Socket^.iStateMachine := SOCKET_STATE_WAITING_FOR_FIN;
          end else
            TCP_Process_TestForResend(Socket^, SOCKET_STATE_DISCONNECT);
        end;
    SOCKET_STATE_WAITING_FOR_FIN :
        begin 
          if Socket^.TCPReceivedFlags.SOCKET_FLAG_RECEIVED_FIN = 1 then
          begin         
            {$IFDEF TRACE_SOCKET_STATE}UART1_Write_Text('SOCKET_STATE_WAITING_FOR_FIN');{$ENDIF}
            Socket^.iStateMachine := SOCKET_STATE_SENDING_FIN_ACK;
          end
        end;
    SOCKET_STATE_SENDING_FIN_ACK :
        begin
          if TCP_TryLoadTransmitterAndSend(Socket^, ACK_S, TXSTART) then
          begin
            {$IFDEF TRACE_SOCKET_STATE}UART1_Write_Text('SOCKET_STATE_SENDING_FIN_ACK' + LF);{$ENDIF}
            Socket^.TCPReceivedFlags := 0;
            Socket^.Start_addr := 0;
            Socket^.Stop_addr := 0;
            Socket^.SequenceNumber := 0;
            Socket^.AckReceived := 0;
            Socket^.SequenceReceived := 0;
            Socket^.AckNumber := 0;
            Socket^.StateFlags.SOCKET_FLAG_CONNECTED := 0;
            Socket^.TCPReceivedFlags := 0;
            Socket^.iStateMachine := SOCKET_STATE_DISCONNECTED;
          end
        end;
    SOCKET_STATE_ERROR :
        begin
          if TCP_TryLoadTransmitterAndSend(Socket^, FIN_S + ACK_S, TXSTART) then
          begin
            {$IFDEF TRACE_SOCKET_STATE}UART1_Write_Text('SOCKET_STATE_ERROR' + LF);{$ENDIF}
            Socket^.iStateMachine := SOCKET_STATE_RESET;
          end;
        end;
    SOCKET_STATE_RESET :
        begin 
          {$IFDEF TRACE_SOCKET_STATE}UART1_Write_Text('SOCKET_STATE_RESET' + LF);{$ENDIF}     
          Socket^.TCPReceivedFlags := 0;                                        // Reset any flags to start over
          Socket^.Start_addr := 0;
          Socket^.Stop_addr := 0;
          Socket^.iStateMachine := SOCKET_STATE_CONNECT;
        end;
  end;

  // Loop around if necessary
  Inc(SocketManager.iLastProcessedSocket);
  if SocketManager.iLastProcessedSocket >= MAX_SOCKET then
    SocketManager.iLastProcessedSocket := 0;
end;

end.