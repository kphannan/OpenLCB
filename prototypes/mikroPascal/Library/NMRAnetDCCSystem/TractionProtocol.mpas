unit TractionProtocol;

{$I Options.inc}

uses
  NMRAnetDCC,
  NMRAnetAppDefines,
  NMRAnetUtilities,
  NMRAnetBufferPools,
  Float16,
  NMRAnetNode,
  CANStorage,
  NMRAnetDefinesShared,
  NMRAnetDefines;
  
type
  TOverCurrent = record
    OverCurrentSampleLimit: Integer;                                            // Number of 5ms cycles to run before making an overcurrent decision
    OverCurrentSampleCount: Word;                                               // Current 5ms Index looking for the OverCurrentSampleLimit
    BitValue: Word;                                                             // Last ADC value of the current.
    OverCurrentLimit: Word;                                                     // The value defined as overcurrent converted from Amps to ADC Bits
    OverCurrentCounter: Integer;                                                // OC Filtered Flag
  end;

type
  TTrainProxyRamData = record                                                   // Structure stored in RAM on a node and vnode basis
    State: Byte;                                                                // State of the Proxy Node
    Speed: Word;                                                                // Float 16 so negative is reverse (including -0)
    SpeedSteps: Byte;                                                           // TEMPORARY - PUT IN CONFIGURATION
    Functions: DWord;                                                           // Function State (F0..F28)
    Address: Word;                                                              // DCC Address
  end;
  PTrainProxyRamData = ^TTrainProxyRamData;

const
  ADC_SAMPLE_INTERRUPT_TIME          = 5.5;                                     // milliseconds between ADC interrupts
  
  TRACTION_SPEED_DIR                 = $00;
  TRACTION_FUNCTION                  = $01;
  TRACTION_E_STOP                    = $02;
  TRACTION_QUERY_SPEED               = $10;
  TRACTION_QUERY_FUNCTION            = $11;
  TRACTION_MANAGE_PROXY              = $80;

  TRACTION_ATTACH_NODE               = $01;
  TRACTION_DETACH_NODE               = $02;
  TRACTION_ATTACH_DCC_ADDRESS        = $81;
  TRACTION_DETACH_DCC_ADDRESS        = $82;

  TRACTION_QUERY_SPEED_REPLY         = $10;
  TRACTION_QUERY_FUNCTION_REPLY      = $11;
  TRACTION_MANAGE_PROXY_REPLY        = $80;

  TRACTION_ATTACH_NODE_REPLY         = $01;
  TRACTION_DETACH_NODE_REPLY         = $02;
  TRACTION_ATTACH_DCC_ADDRESS_REPLY  = $81;
  TRACTION_DETACH_DCC_ADDRESS_REPLY  = $82;
  
  
{
  TRACTION_PROTOCOL_MASK             = $F0;
  TRACTION_OLCB                      = $00;
  TRACTION_OLCB_QUERY                = $10;
  TRACTION_DCC                       = $80;

  TRACTION_OP_MASK                   = $0F;
  TRACTION_OP_SPEED_DIR              = $00;
  TRACTION_OP_FUNCTION               = $01;
  TRACTION_OP_E_STOP                 = $02;

  TRACTION_OP_PROXY_MGMT             = $00;

  DCC_ALLOCATE_ADDRESS               = $01;
  DCC_DEALLOCATE_ADDRESS             = $02;
  DCC_FUNCTION_28                    = $00;
  DCC_FUNCTION_32k                   = $01;
  
  DCC_ALLOCATE_REPLY_FAIL_TEMPORARY  = $02;
  DCC_ALLOCATE_REPLY_FAIL_PERMENENT  = $03;    }
  
  STR_LOCO_NOT_FOUND                 = 'Loco not detected' + #0;                     // 60 characters limit
  STR_SHORT_CIRCUIT                  = 'Overcurrent detected' + #0;                  // 60 characters limit
  STR_INVALID_PROGRAMMING_METHOD     = 'Programming method not compatible' + #0;     // 60 characters limit
  
  NMRA_LONGADDRESS_MASK_BYTE         = $C0;
  NMRA_LONGADDRESS_MASK_WORD         = $C000;
  
const
  _28_STEP_TABLE: array[0..28] of Byte = (
    %00000000,    // Stop
    %00000010,    // Step 1
    %00010010,    // Step 2
    %00000011,    // Step 3
    %00010011,    // Step 4
    %00000100,    // Step 5
    %00010100,    // Step 6
    %00000101,    // Step 7
    %00010101,    // Step 8
    %00000110,    // Step 9
    %00010110,    // Step 10
    %00000111,    // Step 11
    %00010111,    // Step 12
    %00001000,    // Step 13
    %00011000,    // Step 14
    %00001001,    // Step 15
    %00011001,    // Step 16
    %00001010,    // Step 17
    %00011010,    // Step 18
    %00001011,    // Step 19
    %00011011,    // Step 20
    %00001100,    // Step 21
    %00011100,    // Step 22
    %00001101,    // Step 23
    %00011101,    // Step 24
    %00001110,    // Step 25
    %00011110,    // Step 26
    %00001111,    // Step 27
    %00011111     // Step 28
  );

  _14_STEP_TABLE: array[0..14] of Byte = (
    %00000000,    // Stop
    %00000010,    // Step 1
    %00000011,    // Step 3
    %00000100,    // Step 5
    %00000101,    // Step 7
    %00000110,    // Step 9
    %00000111,    // Step 11
    %00001000,    // Step 13
    %00001001,    // Step 15
    %00001010,    // Step 17
    %00001011,    // Step 19
    %00001100,    // Step 21
    %00001101,    // Step 23
    %00001110,    // Step 25
    %00001111     // Step 27
  );

const
  PS_DCC_ADDRESS_ALLOCATED        = $01;                                        // The Proxy is Allocated

  MSG_SEND_DCC_ADDRESS_ALLOCATED   = $01;                                       // Need to send a Message for the DCC Address was Allocated
  
type
  TCommandStationRamData = record
    EnableAutoAllocateProxy: Byte;                                              // For Debugging
    AllocateProxy: Word;                                                        // Running count of how many proxies to allocate
  end;
  PCommandStationRamData = ^TCommandStationRamData;

  TRepeatFunctionPacketArray = array[0..27] of Byte;

  TCommandStationConfigurationInRam = record                                    // This mirrors the EEPROM values for fast lookup in real time
    OutputMode: Byte;
    ProgrammingMode: Byte;
    DccBusMode: Byte;
    RailComEnable: Byte;
    OverCurrentLevel: Word;                                                     // In milliAmps
    OverCurrentTime: Word;                                                      // In milliSeconds
    OverloadDetected: Byte;                                                     // 0 = Normal; 1 = Overloaded
    RepeatSpeedPacket: Byte;
    RepeatFunctions: TRepeatFunctionPacketArray;
    DebugAutoAllocate: Byte;                                                    // Start of EEPROM_DEBUG memory space
  end;
  
  procedure NMRAnetTractionProtocol_RunProtocol(Node: PNMRAnetNode; DataBuffer: PDataBuffer);
  function NMRAnetTractionProtocol_ExtractTrainProxyRamData(Node: PNMRAnetNode): PTrainProxyRamData;
  function NMRAnetTractionProtocol_FindFirstNonDCCAllocatedNode: PNMRAnetNode;
  
  function NMRABusTxBufferAvailable: Boolean; external;
  function TransmitNMRABusLayerMsg(Node: PNMRAnetNode; Buffer: PCANBuffer; MTI: DWord; DestinationAlias: Word; DataCount: Byte; DataBytes: PCAN_DataBytes; AliasInHeader: Boolean; UpperNibbleFlagMask: Word): Boolean; external;
  function CANBusBufferAvailable: Boolean; external;
  function TransmitCANLayerMsg(Node: PNMRAnetNode; Buffer: PCANBuffer; VariableField: DWord): Boolean; external;
  
var
  CommandStationConfigurationInRam: TCommandStationConfigurationInRam;
  CommandStationRamData: TCommandStationRamData;
  OverCurrent: TOverCurrent;
  
  // Array of records that contain Volatile Data (RAM only) for each Node.  The address of the record is assigned to the
  // node in the AssignRAMAddress function below
  TrainProxyRamData: array[0..MAX_NODE_COUNT - 1] of TTrainProxyRamData;   // Easier to allocate 1 extra but not use it for the CS node

implementation

// *****************************************************************************
//  procedure UpdateFunctionsAndSendDCCMessage;
//
//  Parameters:
//
//  Result:
//
//  Description:
// *****************************************************************************
procedure UpdateFunctionsAndSendDCCMessage(AddressHi, AddressLo, FunctionAddress, FunctionValue: Byte; var DCCPacket: TDCCPacket; ProxyData: PTrainProxyRamData);
var
  WideFunctionMask: DWord;
  FunctionMask, FunctionExtendedCode: Byte;
begin
  WideFunctionMask := $00000001;
  WideFunctionMask := WideFunctionMask shl FunctionAddress;   // Set the correct Function Bit
  ProxyData^.Functions := ProxyData^.Functions and not WideFunctionMask; // Clear the bit
  if FunctionValue > 0 then
  ProxyData^.Functions := ProxyData^.Functions or WideFunctionMask;      // Set the bit if needed

  if FunctionAddress < 29 then
  begin
    if FunctionAddress < 5 then
    begin
      FunctionMask := (ProxyData^.Functions shr 1) and $0F;
      FunctionMask.4 := ProxyData^.Functions.0;
      FunctionMask := FunctionMask or %10000000;                    // Opcode bits
    end else
    if FunctionAddress < 9 then
    begin
      FunctionMask := (ProxyData^.Functions shr 5) and $0F;
      FunctionMask := FunctionMask or %10110000;                    // Opcode bits
    end else
    if FunctionAddress < 13 then
    begin
      FunctionMask := (ProxyData^.Functions shr 9) and $0F;
      FunctionMask := FunctionMask or %10100000;                    // Opcode bits
    end else
    if FunctionAddress < 21 then
    begin
      FunctionMask := ProxyData^.Functions shr 13;
      FunctionExtendedCode := %11011110
    end
  end else
  begin
    FunctionMask := ProxyData^.Functions shr 21;
    FunctionExtendedCode := %11011111
  end;

  // Now create the DCC Packet
  if AddressHi and NMRA_LONGADDRESS_MASK_BYTE = NMRA_LONGADDRESS_MASK_BYTE then
  begin    // UART1_Write_Text('Long Address'+LF);
    if FunctionAddress < 13 then
      NMRA_DCC_LoadPacket(@DCCPacket, AddressHi, AddressLo, FunctionMask, 0, 0, 3)
    else
      NMRA_DCC_LoadPacket(@DCCPacket, AddressHi, AddressLo, FunctionExtendedCode, FunctionMask, 0, 4)
  end else
  begin
    if FunctionAddress < 13 then
      NMRA_DCC_LoadPacket(@DCCPacket, AddressLo, FunctionMask, 0, 0, 0, 3)
    else
      NMRA_DCC_LoadPacket(@DCCPacket, AddressLo, FunctionExtendedCode, FunctionMask, 0, 0, 4)
  end;

  NMRA_DCC_QueuePacket(@Track, @DCCPacket, False);
end;


// *****************************************************************************
//  procedure NMRAnetTractionProtocol_FindFirstNonDCCAllocatedNode;
//
//  Parameters:
//
//  Result:
//
//  Description:
//                READ ME:
//                   Currently this uses a dog slow search.
// *****************************************************************************
function NMRAnetTractionProtocol_FindFirstNonDCCAllocatedNode: PNMRAnetNode;
var
  i: Integer;
  TrainProxyRamData: PTrainProxyRamData;
begin
  Result := nil;
  i := Nodes.AllocatedCount - 1;
  while (i > -1) do
  begin
    if NMRAnetNode_TestStateFlag(Nodes.AllocatedList[i], NS_VIRTUAL) then
    begin
      TrainProxyRamData := NMRAnetTractionProtocol_ExtractTrainProxyRamData(Nodes.AllocatedList[i]);
      if TrainProxyRamData^.State and PS_DCC_ADDRESS_ALLOCATED = 0 then
      begin
        Result := Nodes.AllocatedList[i];
        Break;
      end
    end;
    Dec(i);
  end;
end;

// *****************************************************************************
//  procedure NMRAnetTractionProtocol_RunProtocol;
//
//  Parameters:
//
//  Result:
//
//  Description:
//                READ ME:
//                   Currently this uses a dog slow search.
// *****************************************************************************
procedure NMRAnetTractionProtocol_RunProtocol(Node: PNMRAnetNode; DataBuffer: PDataBuffer);
var
  ProxyData: PTrainProxyRamData;
  FunctionAddress: DWord;
  FunctionValue: Word;
  AbsoluteSpeed: real;
  SpeedStep: Word;
  DCCPacket: TDCCPacket;
  AddressHi, AddressLo: Byte;
  IsForward, ReleaseBuffer: Boolean;
  CANBuffer: TCANBuffer;
  i: Integer;
  Half: THalfFloat;
  Bytes: TCAN_DataBytes;
begin
  case DataBuffer^.mCode of
    BMC_TRACTION :
        begin
          ReleaseBuffer := True;
          ProxyData := NMRAnetTractionProtocol_ExtractTrainProxyRamData(Node);
          AddressHi := (ProxyData^.Address shr 8) and $00FF;     // Split the address to make clear when loading bytes
          AddressLo := ProxyDAta^.Address and $00FF;
          // First 2 bytes are Alias
          case DataBuffer^.Bytes[2] of
              TRACTION_SPEED_DIR :
                begin
                  ProxyData^.Speed := (DataBuffer^.Bytes[3] shl 8) or (DataBuffer^.Bytes[4]);
                  IsForward := ProxyData^.Speed and $8000 <> $8000;
                  AbsoluteSpeed := HalfToFloat(ProxyData^.Speed and not $8000);
                  case ProxyData^.SpeedSteps of
                    14  : begin
                            AbsoluteSpeed := (14/100) * AbsoluteSpeed;
                            SpeedStep := Word( AbsoluteSpeed);
                            SpeedStep := _14_STEP_TABLE[SpeedStep];
                            if IsForward then
                              SpeedStep := SpeedStep or $60
                            else
                              SpeedStep := SpeedStep or $40;
                            if AddressHi and NMRA_LONGADDRESS_MASK_BYTE = NMRA_LONGADDRESS_MASK_BYTE then
                              NMRA_DCC_LoadPacket(@DCCPacket, AddressHi, AddressLo, SpeedStep, 0, 0, 3)
                            else
                              NMRA_DCC_LoadPacket(@DCCPacket, AddressLo, SpeedStep, 0, 0, 0, 2);
                            NMRA_DCC_QueuePacket(@Track, @DCCPacket, False);
                          end;
                    28  : begin
                            AbsoluteSpeed := (28/100) * AbsoluteSpeed;
                            SpeedStep := Word( AbsoluteSpeed);
                            SpeedStep := _28_STEP_TABLE[SpeedStep];
                            if IsForward then
                              SpeedStep := SpeedStep or $60
                            else
                              SpeedStep := SpeedStep or $40;
                            if AddressHi and NMRA_LONGADDRESS_MASK_BYTE = NMRA_LONGADDRESS_MASK_BYTE then
                              NMRA_DCC_LoadPacket(@DCCPacket, AddressHi, AddressLo, SpeedStep, 0, 0, 3)
                            else
                              NMRA_DCC_LoadPacket(@DCCPacket, AddressLo, SpeedStep, 0, 0, 0, 2);
                            NMRA_DCC_QueuePacket(@Track, @DCCPacket, False);
                          end;
                    128 : begin
                            AddressHi := AddressHi or NMRA_LONGADDRESS_MASK_BYTE;    // Allow a mistaken short address to work here by adding the $C0  Per Tim
                            AbsoluteSpeed := (127/100) * AbsoluteSpeed;
                            SpeedStep := Word( AbsoluteSpeed);
                            if SpeedStep > 0 then
                              Inc(SpeedStep);   // 1 = EStop
                            if IsForward then
                              SpeedStep := SpeedStep or $80;
                            NMRA_DCC_LoadPacket(@DCCPacket, AddressHi, AddressLo, %00111111, SpeedStep, 0, 4);
                            NMRA_DCC_QueuePacket(@Track, @DCCPacket, False);
                          end;
                  end;
                end;
              TRACTION_FUNCTION :
                begin
                  FunctionAddress := (DWord( DataBuffer^.Bytes[3]) shl 16) or (DWord( DataBuffer^.Bytes[4]) shl 8) or DWord( DataBuffer^.Bytes[5]);
                  FunctionValue := (DWord( DataBuffer^.Bytes[6]) shl 8) or DWord( DataBuffer^.Bytes[7]);
                  UpdateFunctionsAndSendDCCMessage(AddressHi, AddressLo, Byte( FunctionAddress), Byte( FunctionValue), DCCPacket, ProxyData);
                end;
              TRACTION_E_STOP :
                begin
                  IsForward := ProxyData^.Speed and $8000 <> $8000;
                  if IsForward then
                    ProxyData^.Speed := $0000
                  else
                    ProxyData^.Speed := $8000;
                  case ProxyData^.SpeedSteps of
                    14, 28 :
                      begin
                        SpeedStep := $01;
                        if IsForward then
                          SpeedStep := SpeedStep or $60
                        else
                          SpeedStep := SpeedStep or $40;
                        if AddressHi and NMRA_LONGADDRESS_MASK_BYTE = NMRA_LONGADDRESS_MASK_BYTE then
                          NMRA_DCC_LoadPacket(@DCCPacket, AddressHi, AddressLo, SpeedStep, 0, 0, 3)
                        else
                          NMRA_DCC_LoadPacket(@DCCPacket, AddressLo, SpeedStep, 0, 0, 0, 2);
                        NMRA_DCC_QueuePacket(@Track, @DCCPacket, False);
                      end;
                    128 :
                      begin
                        SpeedStep := $01;
                        if IsForward then
                          SpeedStep := SpeedStep or $80;
                        NMRA_DCC_LoadPacket(@DCCPacket, AddressHi, AddressLo, %00111111, SpeedStep, 0, 4);
                        NMRA_DCC_QueuePacket(@Track, @DCCPacket, False);
                      end;
                  end
                end;
              TRACTION_QUERY_SPEED :
                begin
                  if NMRABusTxBufferAvailable then
                  begin
                    case DataBuffer^.StateMachine of
                        0 :
                          begin
                            ReleaseBuffer := False;
                            DataBuffer^.StateMachine := 1;
                            Bytes[0] := TRACTION_QUERY_SPEED_REPLY;
                            Bytes[1] := Hi( ProxyData^.Speed);
                            Bytes[2] := Lo( ProxyData^.Speed);
                            Bytes[3] := $00;                // Result Reply
                            Bytes[4] := $FF;                // Not a Number (NaN) for Commanded Speed
                            Bytes[5] := $FF;
                            TransmitNMRABusLayerMsg(Node, @CANBuffer, MTI_TRACTION_REPLY, DataBuffer^.Alias, 6, @Bytes, False, $10);
                          end;
                        1 :
                          begin
                            Bytes[0] := $FF;                // Not a Number (NaN) for Actual Speed
                            Bytes[1] := $FF;
                            TransmitNMRABusLayerMsg(Node, @CANBuffer, MTI_TRACTION_REPLY, DataBuffer^.Alias, 2, @Bytes, False, $20);
                          end;
                    end;
                  end else
                    ReleaseBuffer := False
                end;
              TRACTION_QUERY_FUNCTION :
                begin
                  if NMRABusTxBufferAvailable then
                  begin
                    FunctionAddress := (DWord( DataBuffer^.Bytes[3]) shl 16) or (DWord( DataBuffer^.Bytes[4]) shl 8) or DWord( DataBuffer^.Bytes[5]);
                    Bytes[0] := TRACTION_QUERY_FUNCTION_REPLY;
                    Bytes[1] := DataBuffer^.Bytes[3];
                    Bytes[2] := DataBuffer^.Bytes[4];
                    Bytes[3] := DataBuffer^.Bytes[5];
                    Bytes[4] := 0;
                    Bytes[5] := Byte( (ProxyData^.Functions shr FunctionAddress) and $00000001);
                    TransmitNMRABusLayerMsg(Node, @CANBuffer, MTI_TRACTION_REPLY, DataBuffer^.Alias, 6, @Bytes, False, $00);
                  end else
                    ReleaseBuffer := False
                end;
              TRACTION_MANAGE_PROXY :
                begin
                  case DataBuffer^.Bytes[3] of
                      TRACTION_ATTACH_NODE :
                        begin
                        end;
                      TRACTION_DETACH_NODE :
                        begin
                        end;
                      TRACTION_ATTACH_DCC_ADDRESS :
                        begin
                          if NMRABusTxBufferAvailable then
                          begin
                            if ProxyData^.State and PS_DCC_ADDRESS_ALLOCATED = 0 then
                            begin
                              ProxyData^.State := ProxyData^.State or PS_DCC_ADDRESS_ALLOCATED;
                              Node^.MsgFlagsUserDefined := Node^.MsgFlagsUserDefined or MSG_SEND_DCC_ADDRESS_ALLOCATED;     // Changed State so notify the system
                              NMRAnetNode_SetPCER_Flag(Node, EVENT_TRAIN_DCC_INUSE_INDEX, False);                           // Changed State so notify the system
                              ProxyData^.SpeedSteps := DataBuffer^.Bytes[6];                                                // TO DO: NEED TO WRITE TO CONFIGURATION
                              ProxyData^.Address := Word ((DataBuffer^.Bytes[4] shl 8)) or DataBuffer^.Bytes[5];            // This is in NMRA DCC format for short/long address
                              if CommandStationRamData.EnableAutoAllocateProxy = 0 then
                                Inc(CommandStationRamData.AllocateProxy);                                                   // Set the flag to allocate a new proxy since we used the last one
                              Bytes[0] := DataBuffer^.Bytes[2];                                                             // First two bytes are Alias
                              Bytes[1] := DataBuffer^.Bytes[3];
                              Bytes[2] := DataBuffer^.Bytes[4];
                              Bytes[3] := DataBuffer^.Bytes[5];
                              Bytes[4] := DataBuffer^.Bytes[6];
                              Bytes[5] := 0;                       // Reply Code when decided upon
                            end else
                            begin
                              // some kind of error code as we are already attached
                            end;
                            TransmitNMRABusLayerMsg(Node, @CANBuffer, MTI_TRACTION_REPLY, DataBuffer^.Alias, 5, @Bytes, False, $00);
                          end else
                            ReleaseBuffer := False;
                        end;
                      TRACTION_DETACH_DCC_ADDRESS :
                        begin
                          if NMRABusTxBufferAvailable then
                          begin
                            ProxyData^.State := ProxyData^.State and not PS_DCC_ADDRESS_ALLOCATED;
                            Node^.MsgFlagsUserDefined := Node^.MsgFlagsUserDefined and not MSG_SEND_DCC_ADDRESS_ALLOCATED;     // Changed State so notify the system
                            NMRAnetNode_SetPCER_Flag(Node, EVENT_TRAIN_DCC_IDLE_INDEX, False);                                 // Changed State so notify the system
                            Bytes[0] := DataBuffer^.Bytes[2];                                                             // First two bytes are Alias
                            Bytes[1] := DataBuffer^.Bytes[3];
                            Bytes[2] := DataBuffer^.Bytes[4];
                            Bytes[3] := DataBuffer^.Bytes[5];
                            Bytes[4] := 0;                       // Reply Code when decided upon
                              
                            for i := 2 to 6 do                                                                            // First two bytes are Alias
                              DataBuffer^.Bytes[i-2] := DataBuffer^.Bytes[i];
                            TransmitNMRABusLayerMsg(Node, @CANBuffer, MTI_TRACTION_REPLY, DataBuffer^.Alias, 4, @Bytes, False, $00);
                            NMRAnetNode_MarkForRelease(Node);
                          end else
                            ReleaseBuffer := False;
                        end;
                  end
                end;
          end;
          if ReleaseBuffer then
          begin
            NMRAnetUtilities_DataBufferUnLink(Node, DataBuffer);
            NMRAnetBufferPools_ReleaseDataBuffer(DataBuffer);
          end
        end;
  end;
end;

function NMRAnetTractionProtocol_ExtractTrainProxyRamData(Node: PNMRAnetNode): PTrainProxyRamData;
begin
  Result := nil;
  if Node <> nil then
    Result := PTrainProxyRamData( Node^.RAMAddress);
end;

end.