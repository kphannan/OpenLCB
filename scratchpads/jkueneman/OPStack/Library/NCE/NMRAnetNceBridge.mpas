// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2014.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2011-01-28:   Created
//     2012-10-07:   Version 1.0
//
// * Description:
//    Defines the interface between OLCB and the NCE Bus
//
// ******************************************************************************

unit NMRAnetNceBridge;

{.$DEFINE DEBUG_MAIN_STATEMACHINE}


uses
  opstacknode,
  opstackdefines,
  template_node,
  opstackcore_traction,
  NMRAnetNceBridgeDefines;

procedure NceBusStateMachine_Process(NodeBuffer: PNMRAnetNode);
//procedure NceBusStateMachine_ProcessNextUserCommand(Node: PNMRAnetNode);
procedure NceBusStateMachine_Initialize;
procedure NceBusStateMachine_UART_RX_StateMachine(NceCab: PNceCab; ReceivedByte: Byte);

function NceKeyPressToString(KeyPress: Byte): string[$FFFF];


implementation

// *****************************************************************************
//  procedure ExtractUserData
//     Parameters: : Node : Pointer to the node that needs to be initilized to its intial value
//     Returns     : Pointer to the defined User Data type
//     Description : Nice helper function to type cast the user data generic pointer
//                   to a pointer to the actual data type
// *****************************************************************************
function ExtractNceCab(Node: PNMRAnetNode): PNceCab;
begin
  Result := PNceCab( Node^.UserData)
end;

procedure NceBusStateMachine_Initialize;
begin
  NceBridge.Discovering := False;
  NceBridge.iDiscoveryCabID := 0;
  NceBridge.iStateMachine := 0;
end;

function NceKeyPressToString(KeyPress: Byte): string[$FFFF];
begin
  case KeyPress of
    NCE_CAB_SELECT_LOCO       : Result := 'Select Loco';
    NCE_CAB_ENTER             : Result := 'Enter';
    NCE_CAB_DIR_TOGGLE        : Result := 'Direction Toggle';
    NCE_HORN_KEY_DOWN         : Result := 'Horn Key Down';
    NCE_CAB_ONE_STEP_FASTER   : Result := 'One Step Faster';
    NCE_CAB_ONE_STEP_SLOWER   : Result := 'One Step Slower';
    NCE_CAB_EMERGENCY_STOP    : Result := 'Emergency Stop';
    NCE_CAB_BELL              : Result := 'Cab Bell';
    NCE_CAB_TOGGLE_F0_0       : Result := '0/Toggle F0';
    NCE_CAB_TOGGLE_F1_1       : Result := '1/Toggle F1';
    NCE_CAB_TOGGLE_F2_2       : Result := '2/Toggle F2';
    NCE_CAB_TOGGLE_F3_3       : Result := '3/Toggle F3';
    NCE_CAB_TOGGLE_F4_4       : Result := '4/Toggle F4';
    NCE_CAB_TOGGLE_F5_5       : Result := '5/Toggle F5';
    NCE_CAB_TOGGLE_F6_6       : Result := '6/Toggle F6';
    NCE_CAB_TOGGLE_F7_7       : Result := '7/Toggle F7';
    NCE_CAB_TOGGLE_F8_8       : Result := '8/Toggle F8';
    NCE_CAB_9                 : Result := '9';
    NCE_HORN_KEY_UP           : Result := 'Horn Key Up';
    NCE_CAB_FIVE_STEPS_FASTER : Result := '5 Speed Steps Faster';
    NCE_CAB_FIVE_STEPS_SLOWER : Result := '5 Speed Steps Slower';
    NCE_CAB_SELECT_MACRO      : Result := 'Macro';
    NCE_CAB_DIR_FORWARD       : Result := 'Forward Direction';
    NCE_CAB_DIR_REVERSE       : Result := 'Reverse Direction'
  else
    Result := 'Unknown Command';
  end;
end;

// ****************************************************************************
// *****************************************************************************
function NextAvailableDevice(Node: PNMRAnetNode): PNMRAnetNode;
var
  i: Integer;
begin
  Result := nil;
  if NodePool.AllocatedCount < 2 then Exit;         // No Cab Nodes created

  i := 1;
  while i < NodePool.AllocatedCount do
  begin
    if Node = NodePool.AllocatedList[i] then
    begin
      Inc(i);
      if i >= NodePool.AllocatedCount then
        i := 1;                 

      if NodePool.AllocatedList[i]^.State and NS_PERMITTED then
        if ExtractNceCab( NodePool.AllocatedList[i])^.State and CS_DEVICE_ACTIVE <> 0 then
        begin
          Result := NodePool.AllocatedList[i];
          Exit
        end
    end;
    Inc(i)
  end;
end;

// ****************************************************************************
// *****************************************************************************
function FirstActiveDevice: PNMRAnetNode;
var
  i: Integer;
  Node: PNMRAnetNode;
begin
  Result := nil;
  
  i := 0;
  while i < NodePool.AllocatedCount do
  begin
    Node := NodePool.AllocatedList[i];
    if Node^.State and NS_PERMITTED = NS_PERMITTED then
      if ExtractNceCab(Node)^.State and CS_DEVICE_ACTIVE <> 0 then
      begin
        Result := Node;
        Exit;
      end;
    Inc(i)
  end;
end;



// *****************************************************************************
// *****************************************************************************
procedure DetectDeviceResponse(CabData: PNceCab; CabID: Word; DetectedState, NoDetectedState: Word);
var
  Node: PNMRAnetNode;
begin
  if (U2STA.RIDLE = 0) or (U2STA.URXDA = 1) then  // Did we detect a Device starting to transmit on the UART?
  begin
    if CabData = nil then                                                  // Does the Device have a Node assigned to it?
    begin
   //   Node := CreateCab(CabID);
  //    if Node <> nil then
  //      CabData := PNceCab( Node^.UserData);
    end;
    CabData^.MissedPingCount := 0;
  end else
  begin 
    // If a Device has nothing to say we can fall into this branch it is not a signal
    // the device is has disappeared
  //  if Device^.State and DS_NCEBUS_DEVICE_ACTIVE = DS_NCEBUS_DEVICE_ACTIVE then
  //  begin
     { Inc(Device^.MissedPingCount);
      if Device^.MissedPingCount > MAX_MISSED_PINGS_TO_REMOVE_FROM_BUS then
      begin
        Node := Device^.Node;                                                   // Copy the address of the node for later use
        NodeData := GetDeviceData(Device^.Node);
        NodeData^.DeviceID := ID_NO_DEVICE;                                     // Unlink the Device from the Node
        Device^.Node := nil;                                                    // Unlink the Node from the Device
        NMRAnetNode_MarkForRelease(Node);                                       // Unallocate the node
        Device^.State := Device^.State and not XDS_NCEBUS_DEVICE_ACTIVE or XDS_NCEBUS_DEVICE_INACTIVE;  // Set the Device Inactive
      end;    }
  //  end;
  //  CabData^.IncomingMsg.iRxStateMachine := NoDetectedState;
  end;
end;

// *****************************************************************************
// *****************************************************************************
procedure NceBusStateMachine_UART_RX_StateMachine(NceCab: PNceCab; ReceivedByte: Byte);
var
  Error: Byte;
  i: Integer;
begin            {
  Inc(NceBusBuffer^.RS485.ReplyCount);  // Should only have 2
  
  if NceBusBuffer^.RS485.NceBusData.Bytes[0] = NCE_NO_KEY_TO_REPORT then Exit;
  if NceBusBuffer^.RS485.NceBusData.Bytes[0] = NCE_NO_SPEED_TO_REPORT then Exit;

  case NceBusBuffer^.RS485.NceBusData.StateMachineIndex of
    STATE_RS485_READ_CAB_KEY_PRESS :
      begin
        NceBusBuffer^.RS485.NceBusData.DataCount := 1;
        NceBusBuffer^.RS485.NceBusData.Bytes[0] := ReceivedByte;
        NceBusBuffer^.RS485.NceBusData.StateMachineIndex := STATE_RS485_READ_CAB_SPEED
      end;
    STATE_RS485_READ_CAB_SPEED :
      begin
        Inc(NceBusBuffer^.RS485.NceBusData.DataCount);
        NceBusBuffer^.RS485.NceBusData.Bytes[1] := ReceivedByte;
        if NceBusBuffer^.RS485.NceBusData.Bytes[0] <> NCE_NO_KEY_TO_REPORT then
        begin
          case NceBusBuffer^.RS485.NceBusData.Bytes[0] of
            NCE_CAB_SELECT_MACRO,
            NCE_CAB_SELECT_LOCO : 
              begin                                                             // User needs to enter more data
                WriteByte(NCE_CMD_CURSOR_ON);
                NceBusBuffer^.RS485.NceBusData.StateMachineIndex := STATE_RS485_CONTINUE_INPUT
              end
            else begin
              NceBusBuffer^.RS485.NceBusData.StateMachineIndex := STATE_RS485_FULL;
              NceBusBuffer^.RS485.Done := True;                           // Must be cleared in the main program
            end;
          end;
        end
      end;
    STATE_RS485_CONTINUE_INPUT :
      begin
        if ReceivedByte = NCE_CAB_ENTER then
        begin
          WriteByte(NCE_CMD_CURSOR_OFF);
          NceBusBuffer^.RS485.NceBusData.StateMachineIndex := STATE_RS485_FULL;
          NceBusBuffer^.RS485.Done := True;                           // Must be cleared in the main program
        end else
        begin
          if Inc(NceBusBuffer^.RS485.NceBusData.DataCount) < NCEBUS_MAX_DATA_BYTE then
          begin
            NceBusBuffer^.RS485.NceBusData.Bytes[NceBusBuffer^.RS485.NceBusData.DataCount] := ReceivedByte;
            Inc(NceBusBuffer^.RS485.NceBusData.DataCount);
          end
        end
      end;
    STATE_RS485_FULL :
      begin                                                                     // Spin here until the system resets the statemachine

      end;
  end     }
end;

// *****************************************************************************
// *****************************************************************************
procedure NceBusStateMachine_Process(Node: PNMRAnetNode);
begin

end;

// *****************************************************************************
// procedure HandleDeviceInstruction(NceBusMessage: PNceBusMessage; iDevice: Byte);
//
//  Parameters:
//              NceBusMessage: Global structure to hold the message information
//              iDevice: The device ID that has the open window to send an Inquiry, send ID_PC_DEVICE to send to the RS485 PC link
//
//  Description:
//              Dispatches the instruction sent by the Device, the UART reception parses the input
//              so the contents of the Message are a complete sequence of bytes (if a special command
//              such as assign loco, macro, etc)
//
// *****************************************************************************
{

procedure NceBus_HandleDeviceInstruction(NceBusMessage: PNceBusMessage; iDevice: Byte);
var
  i: Integer;
  Node: PNMRAnetNode;
begin
  Node := NceBusStateMachineInfo.DeviceList[iDevice].Node;
  if Node <> nil then
  begin
    if NceBusMessage^.Bytes[0] <> NCE_NO_KEY_TO_REPORT then
    begin
      case NceBusMessage^.Bytes[0] of 
        NCE_CAB_SELECT_LOCO :
          begin
            if NceBusMessage^.Bytes[0] = NCE_CAB_SELECT_MACRO then
              UART1_Write_Text('Select Loco: 0x');
            for i := 2 to NceBusMessage^.DataCount - 1 do
            begin
              ByteToHex(NceBusMessage^.Bytes[i], s1);
              UART1_Write_Text(s1);
            end;
            UART1_Write_Text(LF);
          end;
        NCE_CAB_SELECT_MACRO :
          begin    // This was a multi key press message
            if NceBusMessage^.Bytes[0] = NCE_CAB_SELECT_MACRO then
              UART1_Write_Text('Macro: 0x');
            for i := 2 to NceBusMessage^.DataCount - 1 do
            begin
              ByteToHex(NceBusMessage^.Bytes[i], s1);
              UART1_Write_Text(s1);
            end;
            UART1_Write_Text(LF);
          end 
        else begin
          s1 := NceKeyPressToString(NceBusMessage^.Bytes[0]);
          UART1_Write_Text(s1);
        end;
      end;
    end;
    
    ByteToHex(iDevice, s1);
    UART1_Write_Text(', CabID = ' + s1 + LF);
    
    if NceBusMessage^.Bytes[1] <> NCE_NO_SPEED_TO_REPORT then
    begin
      ByteToStr(NceBusMessage^.Bytes[1] and NCE_SPEED_MASK, s1);
      UART1_Write_Text('Speed: ' + s1 + LF);
    end;

  end
end;
 }
end.