// ******************************************************************************
//
// * Copyright:
//     (c) Mustangpeak Software 2014.
//
//     The contents of this file are subject to the GNU GPL v3 licence/ you maynot use
//     this file except in compliance with the License. You may obtain a copy of the
//     License at http://www.gnu.org/licenses/gpl.html
//
// * Revision History:
//     2011-01-28:   Created
//     2012-10-07:   Version 1.0
//
// * Description:
//    Defines global constants for NCE Bus Bridge
//
// ******************************************************************************
unit NMRAnetNceBridgeDefines;

uses
  opstackdefines,
  template_node;

const
  NCEBUS_MAX_DATA_BYTE = 12;                                                    // Max number of databytes in a NCE message
  
  //  NCE bus statemachine
  STATE_BUILD_INITIAL_CABS        = 0;
  STATE_DISCOVERDEVICES           = 1;
  STATE_DISCOVERNEXTDEVICE        = 2;
  STATE_SENDDEVICEINQUIRY         = 3;
  STATE_SENDDEVICESYNC            = 4;
  STATE_HANDLEMESSAGE             = 5;
  STATE_TESTFORDISCOVERYMODE      = 6;
  STATE_ENUMERATEACTIVEDEVICES    = 7;
  STATE_WAITFORDEVICEMESSAGE      = 8;
  
  // Olcb bus statemachine
  STATE_WAIT_FOR_USER_MESSAGE     = 0;

  STATE_RS485_READ_CAB_KEY_PRESS   = 0;  // State machine states for the RS485 receiver
  STATE_RS485_READ_CAB_SPEED       = 1;
  STATE_RS485_CONTINUE_INPUT       = 2;
  STATE_RS485_FULL                 = 3;

  ID_NO_DEVICE                         = $FE;
  ID_MIN_DEVICE                        = 2;
  ID_MAX_DEVICE                        = 63;   // 63 Devices on NceBus bus allowed not including ID = 0 or 1
  ID_PC_DEVICE                         = $FF;  // PC Device = $FF
  NCEBUS_PING                          = %10000000;   // P10A AAAA
  MAX_MISSED_PINGS_TO_REMOVE_FROM_BUS  = 12;          // not supported as NCE cabs can't be on the bus alone they need pings to other cabs to work.....bit 4/7/2013
  NCE_CAB_BUS_PADDING                  = 8;          // How many fixed Cab objects to always have on the bus to Ping, NCE Cabs can't be on the bus alone and a NCE CS has 8 always available.

  NCEBUS_BUS_HUNG_COUNT = 3;      // ~525ms counts and the bus is declared hung. (added 1 since we can't be sure when in the timer we started this covers if the timer interrupts right after we set the flag to 0) See: StartNceBusHungWatchdog for analysis of the max time of a device transaction
  REDISCOVERY_TIME         = 4;    // = Slow timer count (~525ms * REDISCOVERY_TIME = time to rescan for new Devices)
  NCEBUS_OLCB_BUS_TIMEOUT = 6;   // how long to count before giving up on a OLCB reply (~525ms steps)
  
  DS_NCEBUS_DEVICE_INACTIVE                            = $00;  // not Active, not Acknowledging
  DS_NCEBUS_DEVICE_ACTIVE                              = $01;  // Indicates the Device is active on the bus
  
  NCE_NO_SPEED_TO_REPORT    = %01111111;              // $7F
  NCE_NO_KEY_TO_REPORT      = %01111101;              // $7D
  NCE_SPEED_MASK            = %01111111;              // $7F
  
  NCE_CAB_SELECT_LOCO       = $48;   // 72
  NCE_CAB_ENTER             = $40;   // 64   
  NCE_CAB_DIR_TOGGLE        = $43;
  NCE_HORN_KEY_DOWN         = $49;
  NCE_CAB_ONE_STEP_FASTER   = $4A;
  NCE_CAB_ONE_STEP_SLOWER   = $4B;
  NCE_CAB_EMERGENCY_STOP    = $4C;
  NCE_CAB_BELL              = $4D;
  NCE_CAB_TOGGLE_F0_0       = $50;
  NCE_CAB_TOGGLE_F1_1       = $51;
  NCE_CAB_TOGGLE_F2_2       = $52;
  NCE_CAB_TOGGLE_F3_3       = $53;
  NCE_CAB_TOGGLE_F4_4       = $54;
  NCE_CAB_TOGGLE_F5_5       = $55;
  NCE_CAB_TOGGLE_F6_6       = $56;
  NCE_CAB_TOGGLE_F7_7       = $57;
  NCE_CAB_TOGGLE_F8_8       = $58;
  NCE_CAB_9                 = $59;
  NCE_HORN_KEY_UP           = $5F;
  NCE_CAB_FIVE_STEPS_FASTER = $5A;
  NCE_CAB_FIVE_STEPS_SLOWER = $5B;
  NCE_CAB_SELECT_MACRO      = $5C;
  NCE_CAB_DIR_FORWARD       = $6A;
  NCE_CAB_DIR_REVERSE       = $6B;

  
  NCE_CMD_CURSOR_ON         = $CF;  // 207
  NCE_CMD_CURSOR_OFF        = $CE;  // 206

type
  TNceMessage = record
    DataBytes: array[0..NCEBUS_MAX_DATA_BYTE] of Byte;
    Count: Byte;                                      // Number of valid bytes in the array
    Full: Boolean;                                    // True if the message is ready to be process
    iRxStateMachine: Byte;                            // Statemachine for the UART RX input
  end;

  TNceCab = record
    IncomingMsg: TNceMessage;                        // Structure to hold the info for an incoming message from the CAb
    MissedPingCount: Byte;                           // Number of times we tried to Ping the Cab and it did not reply, used to decide to remove cab from NCE bus
  end;
  PNceCab = ^TNceCab;

  // Array of User Data for all Nodes
  TNceCabArray = array[0..USER_MAX_NODE_COUNT-1] of TNceCab;
  
  TNceBridge = record
    NodePinged: PNMRAnetNode;                    // Pointer to the Cab Node that is currently Pinging the NCE bus
    iNodePinged: Word;                           // Index in the Allocated Node Array of the NodePinged
    Discovering: Boolean;                        // The bridge is pinging all Cab IDs looking for newly added Cabs
    DiscoveryCount: Byte;                        // The index of the Cab while discovering
    Watchdog: Byte;                              // Watches for a hang while pinging the cabs
  end;

var
  NceCabArray: TNceCabArray;
  NceBridge: TNceBridge;

implementation

end.