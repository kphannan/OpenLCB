unit template_userstatemachine;


{$I Options.inc}

uses
  Float16,
  opstacktypes,
  opstackdefines,
  template_node,
  opstack_api,
  nmranetdefines,
  NMRAnetCabBridgeDefines,
  NMRAnetCabBridge,
  NMRAnetXpressnet,
  nmranetutilities;

procedure UserStateMachine_Initialize;
procedure AppCallback_UserStateMachine_Process(Node: PNMRAnetNode);
procedure AppCallback_NodeInitialize(Node: PNMRAnetNode);
procedure UART_RX_StateMachine;

// Called every 100ms typically from another thread so only use to update flags
procedure AppCallback_Timer_100ms;

// These message are called from the mainstatemachine loop.  They have been stored in
// internal storage buffers.  See the notes to understand the implications of this and how to use them correctly
procedure AppCallback_SimpleNodeInfoReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
procedure AppCallBack_ProtocolSupportReply(Node: PNMRAnetNode; AMessage: POPStackMessage);  // This could be 2 replies per call.. read docs
procedure AppCallback_RemoteButtonReply(Node: PNMRAnetNode; var Source: TNodeInfo; DataBytes: PSimpleBuffer);
{$IFDEF SUPPORT_TRACTION}
procedure AppCallback_TractionProtocol(Node: PNMRAnetNode; AMessage: POPStackMessage);
procedure AppCallback_TractionProtocolReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
procedure AppCallback_SimpleTrainNodeInfoReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
{$ENDIF}
{$IFDEF SUPPORT_TRACTION_PROXY}
function AppCallback_TractionProxyProtocol(Node: PNMRAnetNode; AMessage: POPStackMessage; SourceHasLock: Boolean): Boolean;
procedure AppCallback_TractionProxyProtocolReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
{$ENDIF}

// These messages are called directly from the hardware receive buffer.  See the notes to understand the
// implications of this and how to use them correctly
procedure AppCallback_InitializationComplete(var Source: TNodeInfo; NodeID: PNodeID);
procedure AppCallback_VerifiedNodeID(var Source: TNodeInfo; NodeID: PNodeID);
procedure AppCallback_ConsumerIdentified(var Source: TNodeInfo; MTI: Word; EventID: PEventID);
procedure AppCallback_ProducerIdentified(var Source: TNodeInfo; MTI: Word; EventID: PEventID);
procedure AppCallback_LearnEvent(var Source: TNodeInfo; EventID: PEventID);
procedure AppCallBack_PCEventReport(var Source: TNodeInfo; EventID: PEventID);

  procedure Hardware_EnableInterrupts; external;
  procedure Hardware_DisableInterrupts; external;

const
  FUNCTION_HORN = 1;
  FUNCTION_BELL = 2;

const
  CONFIG_OFFSET_SPEED_STEP     = 128;
  CONFIG_OFFSET_ADDRESS_TYPE   = 129;

const
  STATE_CAB_IDLE             = 1;
  STATE_CAB_SELECT_LOCO      = 2;
  STATE_CAB_RUN_MACRO        = 3;
  STATE_CAB_RUN_CMD          = 4;
  STATE_CAB_CLEAR_MSG        = 5;


  STATE_CAB_SELECT_LOCO_SEND_PROXY_MANAGE_LOCK               = 1;
  STATE_CAB_SELECT_LOCO_SEND_PROXY_ALLOCATE                  = 2;
  STATE_CAB_SELECT_LOCO_SEND_PROXY_MANAGE_UNLOCK             = 3;
  STATE_CAB_SELECT_LOCO_SEND_TRACTION_MANAGE_LOCK            = 4;
  STATE_CAB_SELECT_LOCO_SEND_TRACTION_ASSIGN_CONTROLLER      = 5;
  STATE_CAB_SELECT_LOCO_SEND_TRACTION_QUERY_SPEED            = 6;
  STATE_CAB_SELECT_LOCO_SEND_TRACTION_QUERY_FUNCTIONS        = 7;
  STATE_CAB_SELECT_LOCO_SEND_TRACTION_MANAGE_UNLOCK          = 8;
  STATE_CAB_SELECT_LOCO_GENERIC_REPLY_WAIT                   = 20;
  STATE_CAB_SELECT_LOCO_GENERIC_TIMEOUT_PROXY_UNLOCK         = 21;
  STATE_CAB_SELECT_LOCO_GENERIC_TIMEOUT_TRACTION_UNLOCK      = 22;

implementation

const
  STATE_RS485_READ_HEADER_BYTE  = 0;  // State machine states for the RS485 receiver
  STATE_RS485_READ_MESSAGE_BYTE = 1;
  STATE_RS485_READ_XOR_BYTE     = 2;
  STATE_RS485_FULL              = 3;

var
  ProxyNode: TNodeInfo;
  GlobalTimer: Word;

// *****************************************************************************
// Called from the UART RX Interrupt
// The Pin Change Interrupt stopped the Timeout Timer so we are free to handle
// the UART RX at our leasure
// *****************************************************************************
procedure UART_RX_StateMachine;
var
  ReceivedByte, ErrorByte: Byte;
  i: Integer;
begin
  while (URXDA_U2STA_bit = 1) do
  begin
    ReceivedByte := U2RXREG;
    case CabBridge.iIncomingStateMachine of
      STATE_RS485_READ_HEADER_BYTE :
        begin
          CabBridge.iIncomingCount := ReceivedByte;                             // Use only the lower nibble for the count, upper is instruction
          CabBridge.iIncomingByteIndex := 0;
          if CabBridge.iIncomingCount and $0F = 0 then                          // If the count is 0 then jump to the XOR byte state, only the lower nibble is the couny
            CabBridge.iIncomingStateMachine := STATE_RS485_READ_XOR_BYTE
          else
            CabBridge.iIncomingStateMachine := STATE_RS485_READ_MESSAGE_BYTE;
        end;
      STATE_RS485_READ_MESSAGE_BYTE :
        begin
          CabBridge.IncomingBuffer[CabBridge.iIncomingByteIndex] := ReceivedByte;
          Inc(CabBridge.iIncomingByteIndex);
          if CabBridge.iIncomingByteIndex >= CabBridge.iIncomingCount and $0F then
            CabBridge.iIncomingStateMachine := STATE_RS485_READ_XOR_BYTE
        end;
      STATE_RS485_READ_XOR_BYTE :
        begin
          ErrorByte := CabBridge.iIncomingCount;
          for i := 0 to (CabBridge.iIncomingCount and $0F) - 1 do
            ErrorByte := ErrorByte xor CabBridge.IncomingBuffer[i];
          if ErrorByte <> ReceivedByte then
            CabBridge.iStateMachine := STATE_SUB_BRIDGE_NEXT_CAB                           // Throw it away
          else
            CabBridge.iStateMachine := STATE_SUB_BRIDGE_CAB_REPLIED;                       // Tell cab what the message was
          CabBridge.iIncomingStateMachine := STATE_RS485_FULL;
        end;
      STATE_RS485_FULL :
        begin                                                                     // Spin here until the system resets the statemachine

        end;
    end
  end;
end;

// *****************************************************************************
// *****************************************************************************
function HandleCabBusReply(CabNode: PNMRAnetNode): Boolean;
var
  CabData: PCab;
  i: Integer;
begin
  Result := False;

  CabData := PCab( CabNode^.UserData);

  // If we get a new message before the previous one was processed, throw it awa
  if CabData^.IncomingMsg.Full then
    Exit;

  // Move it into the Cab buffer to be processed when it is free
  for i := 0 to CabBridge.iIncomingCount - 1 do
  begin
    CabData^.IncomingMsg.DataBytes[i] := CabBridge.IncomingBuffer[i];
    CabData^.IncomingMsg.Count := CabBridge.iIncomingCount;
    CabData^.IncomingMsg.Full := True;
    Result := True;
  end;
end;

// *****************************************************************************
// *****************************************************************************
function DispatchMessage(CabNode: PNMRAnetNode): Boolean;
var
  i: Integer;
  Cab: PCab;
  DataCount, Instruction: Byte;
begin         
  Result := False;
  if CabNode <> nil then
  begin
    Cab := PCab( PByte( CabNode^.UserData));
    DataCount := Cab^.IncomingMsg.Count and $0F;
    Instruction := Cab^.IncomingMsg.Count and $F0;
    // Divide and Conquer
    case Instruction of       // Extract the Instruction
      %00100000:  // 0010 xxxx {$2x}
        begin
          case DataCount of    // Extract the Count
            1: begin
                 case Cab^.IncomingMsg.DataBytes[0] of
                   %10000001 (*$81*): Result := ResumeOperationsRequest(@Cab^.IncomingMsg);                       // 2.2.2  Resume operations request
                   %10000000 (*$80*): Result := StopOperationsRequest(@Cab^.IncomingMsg);                         // 2.2.3  Stop operations request (emergency off)
                   %00010000 (*$10*): Result := ServiceModeResultsRequest(Cab^.ID);                              // 2.2.10 Request for Service Mode results;
                   %00100001 (*$21*): Result := CommandStationSoftwareVersionRequest(@Cab^.IncomingMsg, Cab^.ID); // 2.2.14 Command station software-version request
                   %00100100 (*$24*): Result := CommandStationStatusRequest(@Cab^.IncomingMsg, Cab^.ID)           // 2.2.15 Command station status request
                 else
                   Result := Send_InstructionNotSupported(Cab^.ID);
                 end;
               end;
            2: begin
                 case Cab^.IncomingMsg.DataBytes[0] of
                   %00010001 (*$11*): RegisterModeReadRequest(@XpressNetMessage^.Bytes, iDevice);      // 2.2.7  Register Mode read request (Register Mode)
                   %00010101,(*$15*)                                                                   // 2.2.8  Direct Mode CV read request (CV mode)
                   %00011000,(*$18*)                                                                   // 4-Byte-Format (CV 1-255 und CV1024) (v3.6)
                   %00011001,(*$19*)                                                                   // 4-Byte-Format (CV 256-511)) (v3.6)
                   %00011010,(*$1A*)                                                                   // 4-Byte-Format (CV 512-767) (v3.6)
                   %00011011 (*$1B*): DirectModeReadRequest(@XpressNetMessage^.Bytes, iDevice);        // 4-Byte-Format (CV 768-1023) (v3.6)
                   %00010100 (*$14*): PagedModeReadRequest(@XpressNetMessage^.Bytes, iDevice);         // 2.2.9  Paged Mode read request (Paged Mode)
                   %00100010 (*$22*): SetCommandStationPowerUpMode(XpressNetMessage, iDevice)          // 2.2.16 Set command station power-up mode
                 else
                   Result := Send_InstructionNotSupported(Cab^.ID);
                 end;
               end;
            3: begin
                 case Cab^.IncomingMsg.DataBytes[0] of
                   %00010010 (*$12*): RegisterModeWriteRequest(@XpressNetMessage^.Bytes, iDevice);     // 2.2.11 Register Mode write request (Register Mode)
                   %00011100,(*$16*)                                                                   // 2.2.12 Direct Mode write request (CV Mode) (CV 1-255) and 256)
                   %00011111,(*$1C*)                                                                   // 4-Byte-Format (CV 1-255 and CV1024) (v3.6)
                   %00011110,(*$1D*)                                                                   // 4-Byte-Format (CV 256-511)) (v3.6)
                   %00011101,(*$1E*)                                                                   // 4-Byte-Format (CV 512-767) (v3.6)
                   %00010110 (*$1F*): DirectModeWriteRequest(@XpressNetMessage^.Bytes, iDevice);       // 4-Byte-Format (CV 768-1023) (v3.6)
                   %00010111 (*$17*): PagedModeWriteRequest(@XpressNetMessage^.Bytes, iDevice)         // 2.2.13 Register Mode write request (Paged Mode)
                 else
                   Result := Send_InstructionNotSupported(Cab^.ID);
                 end;
               end
            else
              Result := Send_InstructionNotSupported(Cab^.ID);
          end;
        end;
      %10000000:  // 1000 xxxx {$8x}
        begin
          case DataCount of                                // Extract the Count
            0: StopAllLocomotivesRequest(XpressNetMessage, iDevice)                                   // 2.2.4  Stop all locomotives request (emergency stop)
          else
            Result := Send_InstructionNotSupported(Cab^.ID);
          end
        end;
      %10010000:  // 1001 xxxx {$9x}
        begin
          case DataCount of
            1: EmergencyStopLocomotiveRequestV2_Down(iDevice);                                         // 2.2.5.1 Emergency stop a locomotive (X-Bus V1 and V2)
            2: EmergencyStopLocomotiveRequestV3(XpressNetMessage, iDevice)                             // 2.2.5.2 Emergency stop a locomotive (XpressNet)
          else
            Result := Send_InstructionNotSupported(Cab^.ID);
          end;
        end;
      %10100000:  // 1010 xxxx {$Ax}
        begin
          case DataCount of
            1: LocomotiveInformationRequestV1(iDevice);                                                // 2.2.19.1 Locomotive information requests (X-Bus V1)
            2: LocomotiveInformationRequestV2(iDevice)                                                 // 2.2.19.2 Locomotive information requests (X-Bus V1 and V2)
          else
            Result := Send_InstructionNotSupported(Cab^.ID);
          end;
        end;
      %11100000:  // 1110 xxxx {$Ex}
        begin
          case DataCount of
            3: begin
                 case Cab^.IncomingMsg.DataBytes[0] of
                   %00000000 (*$00*): LocomotiveInformationRequestV3(XpressNetMessage, iDevice);       // 2.2.19.3 Locomotive information requests (XpressNet only) [QUERIES the Function on/off State state (F0-F12)]
                   %00000111 (*$07*): FunctionStatusRequest(XpressNetMessage, iDevice);                // 2.2.19.4 Function momentary/continious status request (XpressNet only)  [QUERIES the momentary or on/off state] [QUERIES the momentary or on/off state (F0-F12)]
                   %00001000 (*$08*): FunctionStateRequestEx(XpressNetMessage, iDevice);               // 2.2.19.5 Function momentary/continious status request (XpressNet only v3.6; 2.2.25.2 in the German document)    [QUERIES the momentary or on/off state (F13-F28)]
                   %00001001 (*$09*): FunctionOperationRequestEx(XpressNetMessage, iDevice);           // 2.2.19.6 Function on/off status request (XpressNet only v3.6; 2.2.25.3 in the German document)    [QUERIES the Function State state (F13-F28)]
                   %00000101, %00000110 (*$05, $06*): AddressInquiryLocoStack(XpressNetMessage, iDevice, XpressNetMessage^.Bytes[0] = %00000110);  // 2.2.25.3 Address inquiry locomotive at command station stack request
                   %01000100 (*$68*): AddressInquiryLocoDeleteFromStack(XpressNetMessage, iDevice)     // 2.2.26 Delete locomotive from command station stack request
                 else
                  Result := Send_InstructionNotSupported(Cab^.ID);
                 end;
               end;
            4: begin
                 case Cab^.IncomingMsg.DataBytes[0] of
                   %00010000, (*$10*) // 14 Step
                   %00010001, (*$11*) // 27 Step
                   %00010010, (*$12*) // 28 Step
                   %00010011: (*$13*) // 128 Step
                     SetLocomotiveSpeedAndDirectionRequest(XpressNetMessage, iDevice, Node);                 // 2.2.20.3  Format - Speed and direction instruction
                   %00100000, (*$20*)   // Set Function Operation on Group 1 ( on/off )
                   %00100001, (*$21*)   // Set Function Operation on Group 1 ( on/off )
                   %00100010, (*$22*)   // Set Function Operation on Group 1 ( on/off )
                   %00100011, (*$23*)   // Set Function Operation on Group 1 ( on/off )
                   %00101000: (*$28*)   // Set Function Operation on Group 1 ( on/off )
                      SetFunctionOperationRequest(XpressNetMessage, iDevice);                          // 2.2.20.4 Format - Function instruction group 1-5:  [SETS the momentary or on/off state]
                   %00100100, (*$24*)  // Set Function State on Group 1 ( momentary/continious )
                   %00100101, (*$25*)  // Set Function State on Group 2 ( momentary/continious )
                   %00100110, (*$26*)  // Set Function State on Group 3 ( momentary/continious )
                   %00100111, (*$27*)  // Set Function State on Group 4 ( momentary/continious )
                   %00101100: (*$2C*)  // Set Function State on Group 5 ( momentary/continious )
                     SetFunctionStateRequest(XpressNetMessage, iDevice);                               // 2.2.20.5 Format - Set Function state group 5: (XpressNet only v3.6; 2.2.26.4 in the German document) [SETS the Function State]
                   %01000000, %01000001 (*$40, $41*): AddLocomotiveToMU_Request(XpressNetMessage, iDevice, XpressNetMessage^.Bytes[0] = %01000001);  // 2.2.24.1 Add a locomotive to a multi-unit request [SETS the Function State]
                   %01000010 (*$42*): RemoveLocomotiveFromMU_Request(XpressNetMessage, iDevice);                    // 2.2.24.2 Remove a locomotive from a Multi-unit request
                   %00000001, %00000010: AddressInquiryOfMember_MU_Request(XpressNetMessage, iDevice, XpressNetMessage^.Bytes[0] = %00000010);       // 2.2.25.1 Address inquiry member of a Multi-unit request
                   %00000011, %00000100: AddressInquiryOf_MU_Request(XpressNetMessage, iDevice, XpressNetMessage^.Bytes[0] = %00000100)              // 2.2.25.2 Address inquiry Multi-unit request
                 else
                   Result := Send_InstructionNotSupported(Cab^.ID);
                 end;
               end;
            5: begin
                 case Cab^.IncomingMsg.DataBytes[0] of
                   %01000011 (*$43*):
                     begin
                       if (Cab^.IncomingMsg.DataBytes[3] = 0) and (Cab^.IncomingMsg.DataBytes[4] = 0) then
                         DissolveDoubleHeaderV3(XpressNetMessage, iDevice)            // 2.2.22.2 Dissolve Double Header
                       else
                         EstablishDoubleHeaderV3(XpressNetMessage, iDevice)           // 2.2.22.1 Establish Double Header
                     end;
                   %00101111 (*$2F*): FunctionRefreshMode(XpressNetMessage, iDevice) // ?????? ?????  (XpressNet only v3.6; 2.2.26.5 in the German document)
                 else
                   Result := Send_InstructionNotSupported(Cab^.ID);
                 end;
               end;
            6: begin
                 case Cab^.IncomingMsg.DataBytes[0] of
                   %00110000 (*$30*): OperationsModeRequest(XpressNetMessage,  iDevice) // 2.2.23.1  Operations Mode Programming
                   else
                     Result := Send_InstructionNotSupported(Cab^.ID);
                 end;
               end
            else
              Result := Send_InstructionNotSupported(Cab^.ID);
          end;
        end;
      %10110000:  // 1011 xxxx {$Bx}
        begin
          case DataCount of
            3: LocomotiveOperationRequestV1(iDevice);            // 2.2.20.1 Locomotive operations (X-Bus V1)
            4: LocomotiveOperationRequestV2(iDevice)             // 2.2.20.2 Locomotive operations (X-Bus V2)
          else
            Result := Send_InstructionNotSupported(Cab^.ID);
          end;
        end;
      %01000000:  // 0100 xxxx {$4x}
        begin
          case DataCount of
            2: begin
                 AccessoryInformationRequest(XpressNetMessage, iDevice);           // 2.2.17 Accessory Decoder information request
                 AccessoryOperationRequest(XpressNetMessage, iDevice)              // 2.2.18 Accessory Decoder operation request
               end
          else
            Result := Send_InstructionNotSupported(Cab^.ID);
          end;
        end;
      %11000000:  // 1100 xxxx {$Cx}
        begin
          case DataCount of
            3: begin
                 case Cab^.IncomingMsg.DataBytes[0] of
                   %00000101: EstablishDoubleHeaderV2(iDevice);  // 2.2.21.1 Establish Double Header
                   %00000100: DisolveDoubleHeaderV2(iDevice)     // 2.2.21.2 Dissolve Double Header
                 else
                   Result := Send_InstructionNotSupported(Cab^.ID);
                 end;
               end
            else
              Result := Send_InstructionNotSupported(iDevice);
          end;
        end;
      %11110000:  // 1111 xxxx {$Fx}   // Sent by the PC interface for information about the PC to XpressBus interface (LI101F)
        begin
          case DataCount of
            0: PC_Interface_VersionNumber(XpressNetMessage, iDevice);              // 1.5.4 Determining the Version number of the LI100F and LI101
            2: begin
                 case XpressNetMessage^.Bytes[0] of
                   1: PC_Interface_SetAddress(XpressNetMessage, iDevice);                 // 1.5.5 Determing and changing the XpressNet address for the LI101
                   2: PC_Interface_SetBaudRate(XpressNetMessage, iDevice)                 // 1.5.6 Determing and changing the Baud Rate for the LI101
                 else
                   Result := Send_InstructionNotSupported(Cab^.ID);
                 end;
              end
           else
             Result := Send_InstructionNotSupported(Cab^.ID);
           end;
        end
      else
        Result := Send_InstructionNotSupported(Cab^.ID);
    end
  end
end;

// *****************************************************************************
//  procedure UserStateMachine_Initialize
//     Parameters: : None
//     Returns     : None
//     Description : Called once when the library is starting.  Use to initalize
//                   variables, etc
// *****************************************************************************
procedure UserStateMachine_Initialize;
begin
  NMRAnetCabBridge_Initialize;
  ProxyNode.ID[0] := 0;
  ProxyNode.ID[1] := 0;
  ProxyNode.AliasID := 0;
  GlobalTimer := 0;
end;

// *****************************************************************************
//  procedure AppCallback_UserStateMachine_Process
//     Parameters: : None
//     Returns     : None
//     Description : Called as often as possible to run the user statemachine
// *****************************************************************************
procedure AppCallback_UserStateMachine_Process(Node: PNMRAnetNode);
var
  i: Integer;
  CabData: PCab;
  Address: Word;
  SpeedStep, AddressType: Byte;
  NewSpeed: THalfFloat;
begin
  if Node = GetPhysicalNode then
  begin
    case Node^.iUserStateMachine of
      STATE_BRIDGE_USER_START :  // Create the minimum number of Pings to put on the NCE bus to make it happy
          begin
            if Node^.State and NS_PERMITTED <> 0 then
            begin
              GlobalTimer := 0;
              if TrySendIdentifyProducer(Node^.Info, @EVENT_IS_PROXY) then
                Node^.iUserStateMachine := STATE_BRIDGE_FIND_PROXY;
            end;
            Exit;
          end;
      STATE_BRIDGE_FIND_PROXY :   // Find the Proxy node (Command Station) on the network before progressing
          begin
            if (ProxyNode.AliasID > 0) or (ProxyNode.ID[0] > 0) or (ProxyNode.ID[1] > 0) then
              Node^.iUserStateMachine := STATE_BRIDGE_CREATE_REQUIRED_CABS
            else begin
              if GlobalTimer > 10 then
                Node^.iUserStateMachine := STATE_BRIDGE_USER_START                     // Try again
            end;
            Exit;
          end;
      STATE_BRIDGE_CREATE_REQUIRED_CABS :
          begin
            for i := ID_MIN_DEVICE_NCE to ID_MIN_DEVICE_NCE + NCE_CAB_BUS_PADDING - 1 do
              CreateCab(i);                                                     // Build and assign cabs 2 - N so make the throttle hardware happy
            Node^.iUserStateMachine := STATE_BRIDGE_DISCOVERDEVICES;
            Exit;
          end;
      STATE_BRIDGE_DISCOVERDEVICES :
          begin
            case CabBridge.iStateMachine of   // I could use the Train Data machine for this if I wanted
              STATE_SUB_BRIDGE_INITIALIZE :
                  begin
                    {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_DISCOVER_INITIALIZE'+LF); {$ENDIF}
                    CabBridge.iDiscoveryCabID := ID_MIN_DEVICE_NCE;
                    CabBridge.iStateMachine := STATE_SUB_BRIDGE_SEND_PING;
                    Exit;
                  end;
              STATE_SUB_BRIDGE_SEND_PING :
                  begin  // The node replied and
                    {$IFDEF DEBUG_DISCOVER_STATEMACHINE} IntToStr(CabBridge.iDiscoveryCabID, s1); UART1_Write_Text('STATE_DISCOVER_SEND_PING: ' + s1+LF); {$ENDIF}
                    CabBridge.ExistingCab := FindCab(CabBridge.iDiscoveryCabID);
                    FlushUartReceiver;
                    CabBridge.iIncomingCount := 0;
                    CabBridge.LastPortRead := PortB;
                    CNIE_bit := 1;                                                        // Pin Change Interrupt enable
                    Hardware_EnableInterrupts;    // It is safe to enable the CAN interrupts here... I think
                    SendXpressnetInquiryMessage(CabBridge.iDiscoveryCabID);                  // Ping the Cab ID
                    Hardware_DisableInterrupts;    // It is safe to enable the CAN interrupts here... I think
                    EnableCabBusTimer(3840);          // 31.25ns * 3840 = 120us
                    CabBridge.iStateMachine := STATE_SUB_BRIDGE_WAIT_FOR_RESPONSE;
                    Exit;
                  end;
              STATE_SUB_BRIDGE_WAIT_FOR_RESPONSE :
                  begin   // Waiting for the Timer to expire or we detect a reply....
                    // See CabBus_Timeout function for the Timeout or CabBus_UART_RX_StateMachine for a reply and what the next state is
                    {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_DISCOVER_WAIT_FOR_RESPONSE'+LF); {$ENDIF}
                    Exit;
                  end;
              STATE_SUB_BRIDGE_TIMEOUT :
                  begin
                    {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_DISCOVER_TIMEOUT'+LF); {$ENDIF}
                    // Need to search the Allocated Cab List to find the CabBridge.iDiscoveryCabID matching Node to pull this
                    CabBridge.iStateMachine := STATE_SUB_BRIDGE_NEXT_CAB;
                    Exit;
                  end;
              STATE_SUB_BRIDGE_CAB_REPLIED :
                  begin
                    {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_DISCOVER_CAB_REPLIED'+LF); {$ENDIF}
                    if CabBridge.ExistingCab = nil then
                    begin
                      CreateCab(CabBridge.iDiscoveryCabID);
                      CabBridge.iStateMachine := STATE_SUB_BRIDGE_NEXT_CAB
                    end else
                    begin
                      if HandleCabBusReply(CabBridge.ExistingCab) then
                        CabBridge.iStateMachine := STATE_SUB_BRIDGE_DISPATCH_MESSAGE
                      else
                        CabBridge.iStateMachine := STATE_SUB_BRIDGE_NEXT_CAB
                    end;
                    Exit;
                  end;
              STATE_SUB_BRIDGE_DISPATCH_MESSAGE :
                  begin
                    {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_SUB_BRIDGE_DISPATCH_MESSAGE'+LF); {$ENDIF}
                    // Xpressnet is fully handled in the Cab local statemachine and is set up in the previous HandleCabBusRely
                    CabBridge.iStateMachine := STATE_SUB_BRIDGE_NEXT_CAB;
                    Exit;
                  end;
              STATE_SUB_BRIDGE_NEXT_CAB :
                  begin
                    {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_DISCOVER_NEXT_CAB'+LF); {$ENDIF}
                    Inc(CabBridge.iDiscoveryCabID);
                    if CabBridge.iDiscoveryCabID > ID_MAX_DEVICE_NCE then
                    begin
                      CabBridge.Discovering := False;
                      CabBridge.DiscoverTimer := 0;
                      CabBridge.iStateMachine := STATE_SUB_BRIDGE_INITIALIZE;                        // Get ready for the next Discovery Mode
                      Node^.iUserStateMachine := STATE_BRIDGE_KNOWNDEVICES;                      // Go back to pinging only known Cabs
                    end else
                      CabBridge.iStateMachine := STATE_SUB_BRIDGE_SEND_PING;
                    Exit;
                  end;
            end;
            Exit;
          end;
      STATE_BRIDGE_KNOWNDEVICES    :
          begin
             case CabBridge.iStateMachine of
                STATE_SUB_BRIDGE_INITIALIZE :
                    begin
                      if (CabBridge.iAssignedCabCount = 0) or (CabBridge.DiscoverTimer >= REDISCOVERY_TIME) then
                      begin
                        Node^.iUserStateMachine := STATE_BRIDGE_DISCOVERDEVICES;
                        CabBridge.iStateMachine := STATE_SUB_BRIDGE_INITIALIZE;
                      end else
                      begin
                       {$IFDEF DEBUG_KNOWNDEVICES_STATEMACHINE} UART1_Write_Text('STATE_SUB_BRIDGE_INITIALIZE'+LF); {$ENDIF}
                       CabBridge.iStateMachine := STATE_SUB_BRIDGE_SEND_PING;
                      end;
                      Exit;
                    end;
                STATE_SUB_BRIDGE_SEND_PING :
                    begin  // The node replied and
                      {$IFDEF DEBUG_KNOWNDEVICES_STATEMACHINE} UART1_Write_Text('STATE_SUB_BRIDGE_SEND_PING: ' + s1+LF); {$ENDIF}
                      FlushUartReceiver;
                      CabBridge.iIncomingCount := 0;
                      CabBridge.LastPortRead := PortB;
                      CNIE_bit := 1;                                            // Pin Change Interrupt enable
                      Hardware_EnableInterrupts;    // It is safe to enable the CAN interrupts here... I think
                      SendXpressnetInquiryMessage(PCab( CabBridge.AssignedCabs[CabBridge.iActiveCab]^.UserData)^.ID);                  // Ping the Cab ID
                      Hardware_DisableInterrupts;    // It is safe to enable the CAN interrupts here... I think
                      EnableCabBusTimer(3840);          // 31.25ns * 3840 = 120us
                      CabBridge.iStateMachine := STATE_SUB_BRIDGE_WAIT_FOR_RESPONSE;
                      Exit;
                    end;
                STATE_SUB_BRIDGE_WAIT_FOR_RESPONSE :
                    begin   // Waiting for the Timer to expire or we detect a reply....
                      // See CabBus_Timeout function for the Timeout or CabBus_UART_RX_StateMachine for a reply and what the next state is
                      {$IFDEF DEBUG_KNOWNDEVICES_STATEMACHINE} UART1_Write_Text('STATE_SUB_BRIDGE_WAIT_FOR_RESPONSE'+LF); {$ENDIF}
                    end;
                STATE_SUB_BRIDGE_TIMEOUT :
                    begin
                      {$IFDEF DEBUG_KNOWNDEVICES_STATEMACHINE} UART1_Write_Text('STATE_SUB_BRIDGE_TIMEOUT'+LF); {$ENDIF}
                      // This should only happen if the throttle was unplugged
                      CabBridge.iStateMachine := STATE_SUB_BRIDGE_NEXT_CAB;
                      Exit;
                    end;
                STATE_SUB_BRIDGE_CAB_REPLIED :
                    begin
                      {$IFDEF DEBUG_KNOWNDEVICES_STATEMACHINE} UART1_Write_Text('STATE_SUB_BRIDGE_CAB_REPLIED'+LF); {$ENDIF}
                      if HandleCabBusReply(CabBridge.AssignedCabs[CabBridge.iActiveCab]) then
                        CabBridge.iStateMachine := STATE_SUB_BRIDGE_DISPATCH_MESSAGE
                      else
                        CabBridge.iStateMachine := STATE_SUB_BRIDGE_NEXT_CAB;
                      Exit;
                    end;
                STATE_SUB_BRIDGE_DISPATCH_MESSAGE :
                    begin
                      {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_SUB_BRIDGE_DISPATCH_MESSAGE'+LF); {$ENDIF}
                      // Xpressnet is fully handled in the Cab local statemachine and is set up in the previous HandleCabBusRely
                      CabBridge.iStateMachine := STATE_SUB_BRIDGE_NEXT_CAB;
                      Exit;
                    end;
                STATE_SUB_BRIDGE_NEXT_CAB :
                    begin
                      {$IFDEF DEBUG_KNOWNDEVICES_STATEMACHINE} UART1_Write_Text('STATE_SUB_BRIDGE_NEXT_CAB'+LF); {$ENDIF}
                      Inc(CabBridge.iActiveCab);
                      if CabBridge.iActiveCab >= CabBridge.iAssignedCabCount then
                      begin
                        CabBridge.iStateMachine := STATE_SUB_BRIDGE_INITIALIZE;
                        CabBridge.iActiveCab := 0;
                      end else
                        CabBridge.iStateMachine := STATE_SUB_BRIDGE_SEND_PING;
                      Exit;
                    end;
              end;
            Exit
          end;
    end;
  end else
  begin
    // Cab Nodes, These states are entered by key presses and set by the Physical
    // node's interaction with the Cab Bus
    CabData := PCab( Node^.UserData);
    case Node^.iUserStateMachine of
      STATE_BRIDGE_USER_START :
          begin
            if Node^.State and NS_PERMITTED <> 0 then
              Node^.iUserStateMachine := STATE_CAB_IDLE;
            Exit;
          end;
      STATE_CAB_IDLE :
          begin
            // Nothing going on....
            if CabData^.IncomingMsg.Full then
            begin
              if DispatchMessage(Node) then
                CabData^.IncomingMsg.Full := False;
            end;
            Exit;
          end;
      STATE_CAB_CLEAR_MSG :
          begin {$IFDEF DEBUG_STATE_CAB_STATEMACHINE} UART1_Write_Text('STATE_CAB_CLEAR_MSG'+LF); {$ENDIF}
            CabData^.IncomingMsg.Full := False;
            CabData^.State := CabData^.State and not (CS_MACRO_MESSAGE or CS_LOCO_SELECT);
            CabData^.IncomingMsg.Count := 0;
            Node^.iUserStateMachine := STATE_CAB_IDLE; // We are done....
            CabData^.iStateMachine := STATE_SUB_BRIDGE_INITIALIZE;  // Reset
          end;
    end;
  end;
end;

// *****************************************************************************
//  procedure AppCallback_NodeInitialize
//     Parameters: : Node : Pointer to the node that needs to be initilized to its intial value
//     Returns     : None
//     Description : Typically called when a node is being intialized to be
//                   logged into the network.  It is possible the node can be
//                   discarded then reused so it may be called more than once for
//                   virtual nodes
// *****************************************************************************
procedure AppCallback_NodeInitialize(Node: PNMRAnetNode);
begin
  // Assign the user data record to the Node for future use
   Node^.UserData := @CabArray[Node^.iIndex];
   Node^.iUserStateMachine := STATE_BRIDGE_USER_START;

   // Initialize the data, every time the node is reused!
   ZeroizeNceCabData( PCab (Node^.UserData))
end;

{$IFDEF SUPPORT_TRACTION}
// *****************************************************************************
//  procedure AppCallback_TractionControlReply
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   Dest   : Full Node ID (and Alias if on CAN) of the dest node for the message
//                   DataBytes: pointer to the raw data bytes
//     Returns     : None
//     Description : Called when a Traction Protocol request comes in
// *****************************************************************************
procedure AppCallback_TractionProtocol(Node: PNMRAnetNode; AMessage: POPStackMessage);
var
 MultiFrameBuffer: PMultiFrameBuffer;
begin
  MultiFrameBuffer := PMultiFrameBuffer( PByte( AMessage^.Buffer));
  case MultiFrameBuffer^.DataArray[0] of
    TRACTION_CONTROLLER_CONFIG :
        begin
          case MultiFrameBuffer^.DataArray[1] of
            TRACTION_CONTROLLER_CONFIG_NOTIFY :
                begin

                end;
          end;
        end;
  end;
end;

// *****************************************************************************
//  procedure AppCallback_TractionProtocolReply
//     Parameters: : Node           : Pointer to the node that the traction protocol has been called on
//                   ReplyMessage   : The Reply Message that needs to be allocated, populated and returned so it can be sent
//                   RequestingMessage    : Message that was sent to the node containing the requested information
//     Returns     : True if the RequestingMessage is handled and the ReplyMessage is ready to send
//                   False if the request has not been completed due to no available buffers or waiting on other information
//     Description : Called in response to a Traction Protcool request
// *****************************************************************************
procedure AppCallback_TractionProtocolReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
var
 MultiFrameBuffer: PMultiFrameBuffer;
 CabData: PCab;
begin
  MultiFrameBuffer := PMultiFrameBuffer( PByte( AMessage^.Buffer));
  CabData := PCab( Node^.UserData);
  case MultiFrameBuffer^.DataArray[0] of
    TRACTION_QUERY_SPEED :
        begin
          Node^.TrainData.SpeedDir := (MultiFrameBuffer^.DataArray[1] shl 8) or MultiFrameBuffer^.DataArray[2];
          CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_SEND_TRACTION_QUERY_FUNCTIONS
        end;
    TRACTION_QUERY_FUNCTION :
        begin
         // Node^.TrainData.Functions......
         CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_SEND_TRACTION_MANAGE_UNLOCK
        end;
    TRACTION_CONTROLLER_CONFIG :
        begin
          case MultiFrameBuffer^.DataArray[1] of
            TRACTION_CONTROLLER_CONFIG_ASSIGN :
                begin
                  if MultiFrameBuffer^.DataArray[2] = TRACTION_CONTROLLER_ASSIGN_REPLY_OK then
                    CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_SEND_TRACTION_QUERY_SPEED
                  else
                    CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_GENERIC_TIMEOUT_PROXY_UNLOCK   // Can't reserve now go back to normal polling
                end;
          end;
        end;
    TRACTION_CONSIST :
        begin
          case MultiFrameBuffer^.DataArray[1] of
            TRACTION_CONSIST_ATTACH :
                begin
                end;
            TRACTION_CONSIST_DETACH :
                begin
                end;
            TRACTION_CONSIST_QUERY :
                begin
                end;
          end // case
        end;
    TRACTION_MANAGE :
        begin
          case MultiFrameBuffer^.DataArray[1] of
            TRACTION_MANAGE_RESERVE :
                begin
                  if MultiFrameBuffer^.DataArray[2] = TRACTION_MANAGE_RESERVE_REPLY_OK then
                    CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_SEND_TRACTION_ASSIGN_CONTROLLER
                  else
                    CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_GENERIC_TIMEOUT_PROXY_UNLOCK   // Can't reserve now go back to normal polling
                end;
          end
        end;
    end;
end;
{$ENDIF}

{$IFDEF SUPPORT_TRACTION_PROXY}
// *****************************************************************************
//  procedure AppCallback_TractionProtocol
//     Parameters: : Node           : Pointer to the node that the traction protocol has been called on
//                   ReplyMessage   : The Reply Message that needs to be allocated, populated and returned so it can be sent
//                   RequestingMessage    : Message that was sent to the node containing the requested information
//     Returns     : True if the RequestingMessage is handled and the ReplyMessage is ready to send
//                   False if the request has not been completed due to no available buffers or waiting on other information
//     Description : Called when a Traction Protocol message is received
// *****************************************************************************
function AppCallback_TractionProxyProtocol(Node: PNMRAnetNode; AMessage: POPStackMessage; SourceHasLock: Boolean): Boolean;
begin
  Result := False;
end;

// *****************************************************************************
//  procedure AppCallback_TractionProxyProtocolReply
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   Dest   : Full Node ID (and Alias if on CAN) of the dest node for the message
//                   DataBytes: pointer to the raw data bytes
//     Returns     : None
//     Description : Called in response to a Traction Proxy request
// *****************************************************************************
procedure AppCallback_TractionProxyProtocolReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
var
  MultiFrameBuffer: PMultiFrameBuffer;
  CabData: PCab;
  i: Integer;
begin
  MultiFrameBuffer := PMultiFrameBuffer( PByte(AMessage^.Buffer));
  CabData := PCab( Node^.UserData);
  case AMessage^.Buffer^.DataArray[0] of
    TRACTION_PROXY_MANAGE :
        begin
          if AMessage^.Buffer^.DataArray[1] = TRACTION_PROXY_MANAGE_RESERVE then
          begin
             if AMessage^.Buffer^.DataArray[2] = 0 then
               CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_SEND_PROXY_ALLOCATE         // Move to next state after reserving
             else
               CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_GENERIC_TIMEOUT_PROXY_UNLOCK   // Can't reserve now go back to normal polling
          end;
          Exit;
        end;
    TRACTION_PROXY_ALLOCATE :
        begin
          Node^.TrainData.LinkedNode.AliasID := (MultiFrameBuffer^.DataArray[11] shl 8) or (MultiFrameBuffer^.DataArray[12]);
          NMRAnetUtilities_Load48BitNodeIDWithSimpleData(Node^.TrainData.LinkedNode.ID, PSimpleDataArray( PByte( @MultiFrameBuffer^.DataArray[5]))^);
          CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_SEND_PROXY_MANAGE_UNLOCK;    // Now need to unlock the Proxy
          Exit;
        end;
  end; // case
end;
{$ENDIF}

// *****************************************************************************
//  procedure AppCallBack_ProtocolSupportReply
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   Dest   : Full Node ID (and Alias if on CAN) of the dest node for the message
//                   DataBytes: pointer Raw data bytes, Byte 0 and 1 are the Alias
//     Returns     : None
//     Description : Called in response to a Protocol Support Request
// *****************************************************************************
procedure AppCallBack_ProtocolSupportReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
begin

end;

// *****************************************************************************
//  procedure AppCallback_ConsumerIdentified
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   Dest   : Full Node ID (and Alias if on CAN) of the dest node for the message
//                   MTI    : MTI of the message
//                   EventID: pointer to the Event ID for the message
//     Returns     : None
//     Description : This is called directly from the Hardware receive buffer.  Do
//                   not do anything here that stalls the call.  This is called
//                   Asyncronously from the Statemachine loop and the Statemachine loop
//                   is stalled until this returns.  Set a flag and move on is the
//                   best stratagy or store info in a buffer and process in the
//                   main statemachine.
// *****************************************************************************
procedure AppCallback_ConsumerIdentified(var Source: TNodeInfo; MTI: Word; EventID: PEventID);
begin

end;

// *****************************************************************************
//  procedure AppCallback_ProducerIdentified
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   Dest   : Full Node ID (and Alias if on CAN) of the dest node for the message
//                   MTI    : MTI of the message
//                   EventID: pointer to the Event ID for the message
//     Returns     : None
//     Description : This is called directly from the Hardware receive buffer.  Do
//                   not do anything here that stalls the call.  This is called
//                   Asyncronously from the Statemachine loop and the Statemachine loop
//                   is stalled until this returns.  Set a flag and move on is the
//                   best stratagy or store info in a buffer and process in the
//                   main statemachine.
// *****************************************************************************
procedure AppCallback_ProducerIdentified(var Source: TNodeInfo; MTI: Word; EventID: PEventID);
begin
  if NMRAnetUtilities_EqualEventID(EventID, @EVENT_IS_PROXY) then
    ProxyNode := Source;
end;

// *****************************************************************************
//  procedure AppCallback_LearnEvent
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   EventID: pointer to the Event ID for the message
//     Returns     : None
//     Description : This is called directly from the Hardware receive buffer.  Do
//                   not do anything here that stalls the call.  This is called
//                   Asyncronously from the Statemachine loop and the Statemachine loop
//                   is stalled until this returns.  Set a flag and move on is the
//                   best stratagy or store info in a buffer and process in the
//                   main statemachine.
// *****************************************************************************
procedure AppCallback_LearnEvent(var Source: TNodeInfo; EventID: PEventID);
begin

end;

// *****************************************************************************
//  procedure AppCallBack_PCEventReport
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   EventID: pointer to the Event ID for the message
//     Returns     : None
//     Description : This is called directly from the Hardware receive buffer.  Do
//                   not do anything here that stalls the call.  This is called
//                   Asyncronously from the Statemachine loop and the Statemachine loop
//                   is stalled until this returns.  Set a flag and move on is the
//                   best stratagy or store info in a buffer and process in the
//                   main statemachine.
// *****************************************************************************
procedure AppCallBack_PCEventReport(var Source: TNodeInfo; EventID: PEventID);
begin

end;

// *****************************************************************************
//  procedure AppCallback_RemoteButtonReply
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   Dest   : Full Node ID (and Alias if on CAN) of the dest node for the message
//                   DataBytes: pointer to the raw data bytes
//     Returns     : None
//     Description : Called in response to a Remote Button request
// *****************************************************************************
procedure AppCallback_RemoteButtonReply(Node: PNMRAnetNode; var Source: TNodeInfo; DataBytes: PSimpleBuffer);
begin

end;

{$IFDEF SUPPORT_TRACTION}
// *****************************************************************************
//  procedure AppCallback_SimpleTrainNodeInfoReply
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   Dest   : Full Node ID (and Alias if on CAN) of the dest node for the message
//                   TrainNodeInfo: pointer to the null terminated strings
//     Returns     : None
//     Description : Called in response to a STNIP request
// *****************************************************************************
procedure AppCallback_SimpleTrainNodeInfoReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
begin

end;
{$ENDIF}

// *****************************************************************************
//  procedure AppCallback_Timer_100ms
//     Parameters: : None
//     Returns     : None
//     Description : Typcally called from another thread or interrupt, only use
//                   to update asyncronous flags
// *****************************************************************************
procedure AppCallback_Timer_100ms;
var
  i: Integer;
  Cab: PCab;
begin
  Inc(GlobalTimer);

   // Count up to the time out then freeze.  The Timer Count will be reset after the
  // main loop is done rediscovering
  if CabBridge.DiscoverTimer < REDISCOVERY_TIME then
    Inc(CabBridge.DiscoverTimer);

  for i := 0 to CabBridge.iAssignedCabCount - 1 do
  begin
    Cab := PCab( CabBridge.AssignedCabs[i]^.UserData);
    Inc( Cab^.WatchDog);
  end;
end;

// *****************************************************************************
//  procedure AppCallback_SimpleNodeInfoReply
//     Parameters: : Source   : Full Node ID (and Alias if on CAN) of the source node for the message
//                   Dest     : Full Node ID (and Alias if on CAN) of the dest node for the message
//                   NodeInfo : pointer to the null terminated strings
//     Returns     : None
//     Description : Called in response to a SNIP Request
// *****************************************************************************
procedure AppCallback_SimpleNodeInfoReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
begin

end;

// *****************************************************************************
//  procedure AppCallback_VerifiedNodeID
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   EventID: pointer to the Event ID for the message
//     Returns     : None
//     Description : This is called directly from the Hardware receive buffer.  Do
//                   not do anything here that stalls the call.  This is called
//                   Asyncronously from the Statemachine loop and the Statemachine loop
//                   is stalled until this returns.  Set a flag and move on is the
//                   best stratagy or store info in a buffer and process in the
//                   main statemachine.
// *****************************************************************************
procedure AppCallback_VerifiedNodeID(var Source: TNodeInfo; NodeID: PNodeID);
begin

end;

// *****************************************************************************
//  procedure AppCallback_InitializationComplete
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   EventID: pointer to the Event ID for the message
//     Returns     : None
//     Description : This is called directly from the Hardware receive buffer.  Do
//                   not do anything here that stalls the call.  This is called
//                   Asyncronously from the Statemachine loop and the Statemachine loop
//                   is stalled until this returns.  Set a flag and move on is the
//                   best stratagy or store info in a buffer and process in the
//                   main statemachine.
// *****************************************************************************
procedure AppCallback_InitializationComplete(var Source: TNodeInfo; NodeID: PNodeID);
begin

end;

end.