program PIC32MX_Basic;

{.$DEFINE DEBUG_UART}

uses
  template_userstatemachine,
  MCU_Setup_PIC32MXxxx,
  opstackcore;

{ Declarations section }

var
  iNextSocketWithOutgoingData: Integer;
  UI_RefreshTimeout: Boolean;
  presTmr: word;

function Trim(var str: string[256]): string[256];
var
  i, iResult: Integer;
begin
  i := 0;
  iResult := 0;
  Result[0] := #0;
  while (str[i] <> #0) and (i < 256) do
  begin
    if (str[i] > #32) and (str[i] < #127) then // Greater than " " and less than "~"
    begin
      Result[iResult] := str[i];
      Inc(iResult);
    end;
    Inc(i);
  end;
  Result[iResult] := #0;  // Add null
end;

function IP_ToStr(var IP: array[4] of byte): string[15];
var
  TempStr: string[3];
  i: Integer;
begin
  ByteToStr(IP[0], TempStr);
  Result := Trim(TempStr) + '.';
  ByteToStr(IP[1], TempStr);
  Result := Result + Trim(TempStr) + '.';
  ByteToStr(IP[2], TempStr);
  Result := Result + Trim(TempStr) + '.';
  ByteToStr(IP[3], TempStr);
  Result := Result + Trim(TempStr)
end;

procedure OPStack_100ms_Timer(); iv IVT_TIMER_5;
begin
  OPStackCore_Timer;  
  T5IF_bit := 0;
end;

procedure Timer1_interrupt(); iv IVT_TIMER_1;
begin
  Inc(presTmr);                                   // increment prescaler
  if (presTmr mod 5 = 0) then                      // timer1 overflows 5 times per second
    Inc(Net_Ethernet_Intern_UserTimerSec);        // increment ethernet library counter
  if(presTmr mod 25 = 0) then                      // timer1 overflows 25 times per 5 seconds
    UI_RefreshTimeout := True;
  T1IF_bit := 0;                                 // clear timer0 overflow flag
end;

procedure Net_Ethernet_Intern_UserTCP(socket : ^SOCKET_Intern_Dsc);
begin
  {$IFDEF DEBUG_UART}UART2_Write_Text('UserTCP' + LF);UART2_Write_Text('Dest: ' + IP_ToStr(myIpAddr) + ':');WordToStr(socket^.destPort, s1);UART2_Write_Text(s1 + LF);{$ENDIF}
  {$IFDEF DEBUG_UART}UART2_Write_Text('Remote: ' + IP_ToStr(socket^.remoteIP) + ':');WordToStr(socket^.remotePort, s1);UART2_Write_Text(s1 + LF);{$ENDIF}
  {$IFDEF DEBUG_UART}s1 := '';for i := 0 to socket^.dataLength - 1 do s1 := s1 + Char( Net_Ethernet_Intern_getByte);UART2_Write_Text(s1 + LF);{$ENDIF}
  
  if iNextSocketWithOutgoingData > -1 then                                       // Handle outgoing messages, assume Count > 0 if this is not -1
  begin {$IFDEF DEBUG_UART}UART2_Write_Text('Outgoing' + LF);{$ENDIF}
    Hardware_DisableInterrupts;                                                  // Don't let the CAN access the buffer while modifing it...
    repeat                           // I am assuming there is room for all bytes here.....
      Net_Ethernet_Intern_putByteTCP( CircularBuffers_RemoveByte(CircularBufferOfByte256RecArray[iNextSocketWithOutgoingData]), socket);
    until CircularBufferOfByte256RecArray[iNextSocketWithOutgoingData].Count = 0;
    Hardware_EnableInterrupts;
  end;
end;

function Net_Ethernet_Intern_UserUDP(udpDsc : ^UDP_Intern_Dsc) : word;
begin
//  UART2_Write_Text('UserUDP' + #13+#10);
  result := 0;
end;

function NextSocketWithOutgoingData(var iNextSocketOutgoing: Integer): Boolean;
var
  i: Integer;
begin
  Result := False;
  Inc(iNextSocketOutgoing);
  i := 0;
  while i < NUM_OF_SOCKET_Intern do
  begin
    if iNextSocketOutgoing >= NUM_OF_SOCKET_Intern then
      iNextSocketOutgoing := 0;
      
    if CircularBufferOfByte256RecArray[iNextSocketOutgoing].Count > 0 then
    begin
      Result := True;
      Break
    end;
    Inc(iNextSocketOutgoing);
    Inc(i)
  end;
end;
  
var
  Node: PNMRAnetNode;
  i: Integer;
  
  GlobalGridConnectStr: TGridConnectString;
  NodeInfo: TNodeInfo;
  NodeID: TNodeID;
  
begin
  { Main program }
  
  NRP_Initialize;
  NodeInfo.ID[0] := $0004;
  NodeInfo.ID[1] := $0500;
  NodeInfo.AliasID := 123;
  NRP_Add(NodeInfo);
  NodeInfo.ID[0] := $0005;
  NodeInfo.ID[1] := $0500;
  NodeInfo.AliasID := 124;
  NRP_Add(NodeInfo);
  NodeInfo.ID[0] := $0010;
  NodeInfo.ID[1] := $0500;
  NodeInfo.AliasID := 333;
  NRP_Add(NodeInfo);
  NodeInfo.ID[0] := $0004;
  NodeInfo.ID[1] := $0700;
  NodeInfo.AliasID := 1234;
  NRP_Add(NodeInfo);
  
  NRP_FindByNodeAlias(333);
  
  NodeID[0] := $0010;
  NodeID[1] := $0500;
  NRP_FindByNodeID(NodeID);

  NRP_RemoveByNodeID(NodeID);
  NRP_RemoveByAliasID(333);
  NRP_RemoveByAliasID(123);
  
  NodeInfo.ID[0] := $0020;
  NodeInfo.ID[1] := $0500;
  NodeInfo.AliasID := 223;
  NRP_Add(NodeInfo);
  
 {
  CircularBuffers_Initialize(@CircularBuffer256Array[0], 3, CircularBufferOfByte256RecArray[i]);

  GlobalGridConnectStr := ':X';

  CircularBuffers_Add(CircularBufferOfByte256RecArray[0], @GlobalGridConnectStr[0], strlen(GlobalGridConnectStr));
  
  repeat
    GlobalGridConnectStr[0] := CircularBuffers_RemoveByte(CircularBufferOfByte256RecArray[0]);
  until CircularBufferOfByte256RecArray[0].Count = 0;

  CircularBuffers_Add(CircularBufferOfByte256RecArray[0], @GlobalGridConnectStr[0], strlen(GlobalGridConnectStr));

  repeat
    GlobalGridConnectStr[0] := CircularBuffers_RemoveByte(CircularBufferOfByte256RecArray[0]);
  until CircularBufferOfByte256RecArray[0].Count = 0;
    }
    
  TRISF12_bit := 0;
  LATF12_bit := 0;
  TRISF13_bit := 0;
  LATF13_bit := 0;

  UI_RefreshTimeout := True;
  iNextSocketWithOutgoingData := -1;
  presTmr := 0;
  
  Start_TP;
  OPStackCore_Initialize;
  MCU_Setup_Initialize;
  MCU_EnableSerialFlash;
  MCU_EnableUARTA;
  MCU_Enable100msTimer;
  MCU_Enable1sTimer;
  MCU_EnableCAN;
  EnableInterrupts;
  MCU_EnableEthernet;
  
  TFT_Fill_Screen($0000);
  TFT_Write_Text('Logged in', 4, 10);
  
  UART2_Write_Text('Configured' + LF);
  while True do
  begin
    Node := OPStackCore_Process;
    Net_Ethernet_Intern_doPacket();                                             // Look for incoming packets
    
    if NextSocketWithOutgoingData(iNextSocketWithOutgoingData) then
    begin
      {$IFDEF DEBUG_UART}UART2_Write_Text('Net_Ethernet_Intern_startSendTCP' + LF);{$ENDIF}
      Net_Ethernet_Intern_startSendTCP(@socket_Intern[iNextSocketWithOutgoingData]);
    end;
    
    if UI_RefreshTimeout then
    begin
      TFT_Fill_Screen($0000);
      TFT_Write_Text('Buffers', 4, 20);
      for i := 0 to NUM_OF_SOCKET_Intern - 1 do
      begin
        WordToStr(CircularBufferOfByte256RecArray[i].Count, s1);
        TFT_Write_Text('Count: ' + s1, 4, (20 * i) + 40);
        WordToStr(CircularBufferOfByte256RecArray[i].MaxCount, s1);
        TFT_Write_Text('MaxCount: ' + s1, 150, (20 * i) + 40);
      end;
      UI_RefreshTimeout := False;
    end;


    LATF13_bit := not LATF13_bit;

    if UART2_Data_Ready = 1 then
    begin
      case UART2_Read of
        '1' : begin
                ON__T5CON_bit := not ON__T5CON_bit;
              end;
        '2' : begin
                ON__T5CON_bit := 1;
                OPStackCore_Initialize;
                OPStackCore_Enable(True);
              end;
        '3' : begin
                ON__T5CON_bit := 0;
                OPStackCore_Enable(False);
              end;
        '4' : begin
                PIC32MX_CAN_PrintRegisters(2);
                PIC32MX_CAN_RequestTransmit(2, 0);
                PIC32MX_CAN_PrintRegisters(2);
              end;
      end;
    end;
  end;
end.