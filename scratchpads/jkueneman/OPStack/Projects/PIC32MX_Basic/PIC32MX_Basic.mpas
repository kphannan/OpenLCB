program PIC32MX_Basic;

{.$DEFINE DEBUG_UART}
{.$DEFINE TRACK_BRIDGE_MESSAGES}

uses
  template_userstatemachine,
  MCU_Setup_PIC32MXxxx,
  opstackcore;

{ Declarations section }

var
  iNextSocketWithOutgoingData: Integer;
  NextSocketWithOutgoingProcessing: Boolean;
  UI_RefreshTimeout: Boolean;
  presTmr: word;

function Trim(var str: string[256]): string[256];
var
  i, iResult: Integer;
begin
  i := 0;
  iResult := 0;
  Result[0] := #0;
  while (str[i] <> #0) and (i < 256) do
  begin
    if (str[i] > #32) and (str[i] < #127) then // Greater than " " and less than "~"
    begin
      Result[iResult] := str[i];
      Inc(iResult);
    end;
    Inc(i);
  end;
  Result[iResult] := #0;  // Add null
end;

function IP_ToStr(var IP: array[4] of byte): string[15];
var
  TempStr: string[3];
  i: Integer;
begin
  ByteToStr(IP[0], TempStr);
  Result := Trim(TempStr) + '.';
  ByteToStr(IP[1], TempStr);
  Result := Result + Trim(TempStr) + '.';
  ByteToStr(IP[2], TempStr);
  Result := Result + Trim(TempStr) + '.';
  ByteToStr(IP[3], TempStr);
  Result := Result + Trim(TempStr)
end;

procedure OPStack_100ms_Timer(); iv IVT_TIMER_5;
begin
//  OPStackCore_Timer;
  T5IF_bit := 0;
end;

procedure Timer1_interrupt(); iv IVT_TIMER_1;
begin
  Inc(presTmr);                                   // increment prescaler
  if (presTmr mod 5 = 0) then                      // timer1 overflows 5 times per second
    Inc(Net_Ethernet_Intern_UserTimerSec);        // increment ethernet library counter
  if(presTmr mod 25 = 0) then                      // timer1 overflows 25 times per 5 seconds
    UI_RefreshTimeout := True;
  T1IF_bit := 0;                                 // clear timer0 overflow flag
end;

procedure Net_Ethernet_Intern_UserTCP(socket : ^SOCKET_Intern_Dsc);
var
  sx: string[1];
  i, iSocket: Integer;
begin
  {$IFDEF DEBUG_UART}UART2_Write_Text('UserTCP' + LF);UART2_Write_Text('Dest: ' + IP_ToStr(myIpAddr) + ':');WordToStr(socket^.destPort, s1);UART2_Write_Text(s1 + LF);{$ENDIF}
  {$IFDEF DEBUG_UART}UART2_Write_Text('Remote: ' + IP_ToStr(socket^.remoteIP) + ':');WordToStr(socket^.remotePort, s1);UART2_Write_Text(s1 + LF);{$ENDIF}
  {$IFDEF DEBUG_UART}s1 := '';for i := 0 to socket^.dataLength - 1 do s1 := s1 + Char( Net_Ethernet_Intern_getByte);UART2_Write_Text(s1 + LF);{$ENDIF}
  
  // Look for data in the Ethernet Outgoing Circular Buffers
  if NextSocketWithOutgoingProcessing and (iNextSocketWithOutgoingData > -1) then // Handle outgoing messages, assume Count > 0 if this is not -1
  begin
    {$IFDEF TRACK_BRIDGE_MESSAGES}UART2_Write_Text('TCP Outgoing (removing bytes)' + LF);{$ENDIF}
    repeat                           // I am assuming there is room for all bytes here.....
      Net_Ethernet_Intern_putByteTCP( CircularBuffers_RemoveByte(CircularBufferOfByte256RecArray[iNextSocketWithOutgoingData]), socket);
    until CircularBufferOfByte256RecArray[iNextSocketWithOutgoingData].Count = 0;
    NextSocketWithOutgoingProcessing := False;
    {$IFDEF TRACK_BRIDGE_MESSAGES}UART2_Write_Text('..' + LF + LF);{$ENDIF}
  end;

  // Look for data in the Ethernet Incoming Circular Buffers
  if socket^.dataLength > 0 then
  begin  
   {$IFDEF TRACK_BRIDGE_MESSAGES}UART2_Write_Text('TCP Incoming to Buffer (adding bytes)' + LF);{$ENDIF}
 {  WordToStr(socket^.dataLength, s1); UART2_Write_Text('Incoming: ' + s1 + LF); WordToStr(socket^.MyWin, s1); UART2_Write_Text('Window: ' + s1 + LF);     }
    
    iSocket := 0;
    while iSocket < NUM_OF_SOCKET_Intern do
    begin
      if @socket_Intern[iSocket] = socket then Break else Inc(iSocket)          // Find the socket in the list
    end;

    IntTostr(iSocket, s1);
    {$IFDEF TRACK_BRIDGE_MESSAGES}UART2_Write_Text('iSocket: ' + s1 + LF);{$ENDIF}
    
    for i := 0 to socket^.dataLength - 1 do
      CircularBuffers_AddByte(CircularBufferOfByte1024RecArray[iSocket], Net_Ethernet_Intern_getByte);
    
    socket^.myWin := CircularBufferOfByte1024RecArray[iSocket].Size - CircularBufferOfByte1024RecArray[iSocket].Count;
    {$IFDEF TRACK_BRIDGE_MESSAGES}UART2_Write_Text('..' + LF + LF);{$ENDIF}
  end;
  
end;

function Net_Ethernet_Intern_UserUDP(udpDsc : ^UDP_Intern_Dsc) : word;
begin
//  UART2_Write_Text('UserUDP' + #13+#10);
  result := 0;
end;

function NextSocketWithOutgoingData(var iNextSocketOutgoing: Integer): Boolean;
var
  i: Integer;
begin
  Result := False;
  Inc(iNextSocketOutgoing);
  i := 0;
  while i < NUM_OF_SOCKET_Intern do
  begin
    if iNextSocketOutgoing >= NUM_OF_SOCKET_Intern then
      iNextSocketOutgoing := 0;
      
    if CircularBufferOfByte256RecArray[iNextSocketOutgoing].Count > 0 then
    begin
      Result := True;
      Break
    end;
    Inc(iNextSocketOutgoing);
    Inc(i)
  end;
  if not Result then
    iNextSocketOutgoing := -1
end;
  
var
  Node: PNMRAnetNode;
  i, iSocket, j: Integer;
  
  GlobalGridConnectStr: PGridConnectString;
  NMRAnetCanBuffer: TNMRAnetCanBuffer;
  SourceNode, DestNode: PNMRAnetNode;
  OPStackMessage: POPStackMessage;
  NodeInfo: TNodeInfo;
  NodeID: TNodeID;
  
begin
  { Main program }
    
  TRISF12_bit := 0;
  LATF12_bit := 0;
  TRISF13_bit := 0;
  LATF13_bit := 0;

  UI_RefreshTimeout := True;
  iNextSocketWithOutgoingData := -1;
  NextSocketWithOutgoingProcessing := False;
  presTmr := 0;
  
  Start_TP;
  OPStackCore_Initialize;
  MCU_Setup_Initialize;
  MCU_EnableSerialFlash;
  MCU_EnableUARTA;
  MCU_Enable100msTimer;
  MCU_Enable1sTimer;
  MCU_EnableCAN;
  EnableInterrupts;
  MCU_EnableEthernet;
  
  TFT_Fill_Screen($0000);
  TFT_Write_Text('Logged in', 4, 10);
  
  UART2_Write_Text('Configured' + LF);
  while True do
  begin
  //  Node := OPStackCore_Process;
    
    Hardware_DisableInterrupts;                                                // Don't let the CAN access the buffer while modifing it...
    Net_Ethernet_Intern_doPacket();                                             // Look for incoming packets
    Hardware_EnableInterrupts;
    
    if NextSocketWithOutgoingData(iNextSocketWithOutgoingData) and not NextSocketWithOutgoingProcessing then
    begin
      {$IFDEF TRACK_BRIDGE_MESSAGES}UART2_Write_Text('Start Sending TCP set flag ..' + LF + LF);{$ENDIF}
      NextSocketWithOutgoingProcessing := True;
      Net_Ethernet_Intern_startSendTCP(@socket_Intern[iNextSocketWithOutgoingData]);
    end;
    
    iSocket := 0;
    
    if IsOutgoingBufferAvailable then
    begin
      j := CircularBufferOfByte1024RecArray[0].Count;
      if j > 0 then
      begin   
        {$IFDEF TRACK_BRIDGE_MESSAGES}UART2_Write_Text('Incoming TCP Relayed to CAN (removing bytes): ');{$ENDIF}
        for i := 0 to j - 1 do
        begin
          if GridConnect_DecodeMachine( CircularBuffers_RemoveByte( CircularBufferOfByte1024RecArray[0]), GlobalGridConnectStr) then
          begin
            GridConnectStr_ToCanBuffer(GlobalGridConnectStr, @NMRAnetCanBuffer);
            PIC32MX_StartTransmission(@NMRAnetCanBuffer, True);
            Break
          end;
        end;
        {$IFDEF TRACK_BRIDGE_MESSAGES}UART2_Write_Text('..' + LF + LF);{$ENDIF}
        socket_Intern[0].myWin := CircularBufferOfByte1024RecArray[0].Size - CircularBufferOfByte1024RecArray[0].Count;
      end;
    end;

    if UI_RefreshTimeout then
    begin
      TFT_Fill_Screen($0000);
      TFT_Write_Text('Buffers', 4, 20);
      for i := 0 to NUM_OF_SOCKET_Intern - 1 do
      begin
        WordToStr(CircularBufferOfByte256RecArray[i].Count, s1);
        TFT_Write_Text('Count: ' + s1, 4, (20 * i) + 40);
        WordToStr(CircularBufferOfByte256RecArray[i].MaxCount, s1);
        TFT_Write_Text('MaxCount: ' + s1, 150, (20 * i) + 40);
      end;
      UI_RefreshTimeout := False;
    end;


    LATF13_bit := not LATF13_bit;

    if UART2_Data_Ready = 1 then
    begin
      case UART2_Read of
        '1' : begin
                ON__T5CON_bit := not ON__T5CON_bit;
              end;
        '2' : begin
                ON__T5CON_bit := 1;
                OPStackCore_Initialize;
                OPStackCore_Enable(True);
              end;
        '3' : begin
                ON__T5CON_bit := 0;
                OPStackCore_Enable(False);
              end;
        '4' : begin
                PIC32MX_CAN_PrintRegisters(2);
                PIC32MX_CAN_RequestTransmit(2, 0);
                PIC32MX_CAN_PrintRegisters(2);
              end;
        '5' : begin
                if NextSocketWithOutgoingData(iNextSocketWithOutgoingData) then
                  Net_Ethernet_Intern_startSendTCP(@socket_Intern[iNextSocketWithOutgoingData]);  // This sets a flag and DoTCP is called from the Net_Ethernet_Intern_doPacket call
              end;
        '6' : begin
                socket_Intern[0].myWin := 30;  // This sets a flag and DoTCP is called from the Net_Ethernet_Intern_doPacket call
              end;
      end;
    end;
  end;
end.