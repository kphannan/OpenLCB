unit template_userstatemachine;

{$I Options.inc}

uses
  Float16,
  opstacktypes,
  opstackdefines,
  template_node,
  opstack_api,
  nmranetdefines,
  NMRAnetCabBridgeDefines,
  NMRAnetCabBridge,
  nmranetutilities;

procedure UserStateMachine_Initialize;
procedure AppCallback_UserStateMachine_Process(Node: PNMRAnetNode);
procedure AppCallback_NodeInitialize(Node: PNMRAnetNode);
procedure UART_RX_StateMachine;

// Called every 100ms typically from another thread so only use to update flags
procedure AppCallback_Timer_100ms;

// These message are called from the mainstatemachine loop.  They have been stored in
// internal storage buffers.  See the notes to understand the implications of this and how to use them correctly
procedure AppCallback_SimpleNodeInfoReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
procedure AppCallBack_ProtocolSupportReply(Node: PNMRAnetNode; AMessage: POPStackMessage);  // This could be 2 replies per call.. read docs
procedure AppCallback_RemoteButtonReply(Node: PNMRAnetNode; var Source: TNodeInfo; DataBytes: PSimpleBuffer);
{$IFDEF SUPPORT_TRACTION}
procedure AppCallback_TractionProtocol(Node: PNMRAnetNode; AMessage: POPStackMessage);
procedure AppCallback_TractionProtocolReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
procedure AppCallback_SimpleTrainNodeInfoReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
{$ENDIF}
{$IFDEF SUPPORT_TRACTION_PROXY}
function AppCallback_TractionProxyProtocol(Node: PNMRAnetNode; AMessage: POPStackMessage; SourceHasLock: Boolean): Boolean;
procedure AppCallback_TractionProxyProtocolReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
{$ENDIF}

// These messages are called directly from the hardware receive buffer.  See the notes to understand the
// implications of this and how to use them correctly
procedure AppCallback_InitializationComplete(var Source: TNodeInfo; NodeID: PNodeID);
procedure AppCallback_VerifiedNodeID(var Source: TNodeInfo; NodeID: PNodeID);
procedure AppCallback_ConsumerIdentified(var Source: TNodeInfo; MTI: Word; EventID: PEventID);
procedure AppCallback_ProducerIdentified(var Source: TNodeInfo; MTI: Word; EventID: PEventID);
procedure AppCallback_LearnEvent(var Source: TNodeInfo; EventID: PEventID);
procedure AppCallBack_PCEventReport(var Source: TNodeInfo; EventID: PEventID);

  procedure Hardware_EnableInterrupts; external;
  procedure Hardware_DisableInterrupts; external;

const
  FUNCTION_HORN = 1;
  FUNCTION_BELL = 2;

const
  CONFIG_OFFSET_SPEED_STEP     = 128;
  CONFIG_OFFSET_ADDRESS_TYPE   = 129;

const
  STATE_CAB_IDLE             = 1;
  STATE_CAB_SELECT_LOCO      = 2;
  STATE_CAB_RUN_MACRO        = 3;
  STATE_CAB_RUN_CMD          = 4;
  STATE_CAB_CLEAR_MSG        = 5;


  STATE_CAB_SELECT_LOCO_SEND_PROXY_MANAGE_LOCK               = 1;
  STATE_CAB_SELECT_LOCO_SEND_PROXY_ALLOCATE                  = 2;
  STATE_CAB_SELECT_LOCO_SEND_PROXY_MANAGE_UNLOCK             = 3;
  STATE_CAB_SELECT_LOCO_SEND_TRACTION_MANAGE_LOCK            = 4;
  STATE_CAB_SELECT_LOCO_SEND_TRACTION_ASSIGN_CONTROLLER      = 5;
  STATE_CAB_SELECT_LOCO_SEND_TRACTION_QUERY_SPEED            = 6;
  STATE_CAB_SELECT_LOCO_SEND_TRACTION_QUERY_FUNCTIONS        = 7;
  STATE_CAB_SELECT_LOCO_SEND_TRACTION_MANAGE_UNLOCK          = 8;
  STATE_CAB_SELECT_LOCO_GENERIC_REPLY_WAIT                   = 20;
  STATE_CAB_SELECT_LOCO_GENERIC_TIMEOUT_PROXY_UNLOCK         = 21;
  STATE_CAB_SELECT_LOCO_GENERIC_TIMEOUT_TRACTION_UNLOCK      = 22;
  
var
  CabBus_RS485_Select              : sbit; sfr; external;
  CabBus_RS485_Select_Direction    : sbit; sfr; external;

implementation

var
  ProxyNode: TNodeInfo;
  GlobalTimer: Word;

// *****************************************************************************
// Called from the UART RX Interrupt
// The Pin Change Interrupt stopped the Timeout Timer so we are free to handle
// the UART RX at our leasure
// *****************************************************************************
procedure UART_RX_StateMachine;
begin
  while (URXDA_U2STA_bit = 1) do
  begin
    CabBridge.IncomingBuffer[CabBridge.iIncomingCount] := U2RXREG;
    Inc(CabBridge.iIncomingCount);
    if CabBridge.iIncomingCount = 2 then
      CabBridge.iStateMachine := STATE_SUB_BRIDGE_CAB_REPLIED                   // Received both Bytes process them
  end;
end;


// *****************************************************************************
// *****************************************************************************
function HandleCabBusReply(CabNode: PNMRAnetNode): Boolean;
var
  CabData: PCab;
  i: Integer;
begin
  Result := False;

  CabData := PCab( CabNode^.UserData);

  // If the current buffer in the Cab is not processed yet throw this one away as it may be in the middle of a statemachine
  if CabData^.IncomingMsg.Full then
    Exit;

  // NCE interleaves its incoming messages (in some cases) so we need a sub-statemachine to
  // gather them up and then set the Cab Statemachine to the correct task.  This is fast
  // from within the main Cab Ping loop.  The handlers are all local to each nodes
  // statemachine loops
  for i := 0 to CabBridge.iIncomingCount - 1 do
  begin
    case CabBridge.IncomingBuffer[i] of
      NCE_NO_KEY_TO_REPORT : begin end;
      NCE_NO_SPEED_TO_REPORT : begin end;
      NCE_CAB_SELECT_MACRO :
          begin
            {$IFNDEF FPC}WriteByte(NCE_CMD_CURSOR_ON, True);{$ENDIF}
            CabData^.State := CabData^.State or CS_MACRO_MESSAGE;
            CabData^.IncomingMsg.Count := 0;
          end;
      NCE_CAB_SELECT_LOCO :
          begin
            {$IFNDEF FPC}WriteByte(NCE_CMD_CURSOR_ON, True);{$ENDIF}
            CabData^.State := CabData^.State or CS_LOCO_SELECT;
            CabData^.IncomingMsg.Count := 0;
          end;
      NCE_CAB_ENTER :
          begin
            if CabData^.State and (CS_MACRO_MESSAGE or CS_LOCO_SELECT) <> 0 then
            begin
              {$IFNDEF FPC}WriteByte(NCE_CMD_CURSOR_OFF, True);{$ENDIF}
              CabData^.IncomingMsg.Full := True;
              Result := True;
            end;
          end
      else begin
          if CabData^.IncomingMsg.Count < CAB_MAX_DATA_BYTE then
          begin
            CabData^.IncomingMsg.DataBytes[CabData^.IncomingMsg.Count] := CabBridge.IncomingBuffer[i];
            Inc(CabData^.IncomingMsg.Count);
            if CabData^.State and (CS_MACRO_MESSAGE or CS_LOCO_SELECT) = 0 then
            begin
              CabData^.IncomingMsg.Full := True;
              Result := True;
            end;
          end;
        end;
      end; {case}
  end; {if}
end;

// *****************************************************************************
// *****************************************************************************
function DispatchMessage(CabNode: PNMRAnetNode): Boolean;
var
 CabData: PCab;
 i: Integer;
 sss: array[0..128] of char;

begin
  Result := False;
  if CabNode <> nil then
  begin
    CabData := PCab( CabNode^.UserData);

    {$IFDEF LOG_CAB_REPLY}
    UART1_Write_Text('--------'+LF);
    {$ENDIF}
    
    if CabData^.State and CS_LOCO_SELECT <> 0 then
    begin
      // Kick off the statemachine to do this....
      CabNode^.iUserStateMachine := STATE_CAB_SELECT_LOCO;
      CabData^.iStateMachine := STATE_SUB_BRIDGE_INITIALIZE;
      {$IFDEF LOG_CAB_REPLY}
      UART1_Write_Text('Loco Select: ');
      PrintIncomingMsg(CabData^.IncomingMsg);
      {$ENDIF}
    end else
    if CabData^.State and CS_MACRO_MESSAGE <> 0 then
    begin
      // Kick off the statemachine to do this....
      CabNode^.iUserStateMachine := STATE_CAB_RUN_MACRO;
      CabData^.iStateMachine := STATE_SUB_BRIDGE_INITIALIZE;
      {$IFDEF LOG_CAB_REPLY}
      UART1_Write_Text('Macro: ');
      PrintIncomingMsg(CabData^.IncomingMsg);
      {$ENDIF}
    end else
    begin
      CabNode^.iUserStateMachine := STATE_CAB_RUN_CMD;
      CabData^.iStateMachine := STATE_SUB_BRIDGE_INITIALIZE;
      {$IFDEF LOG_CAB_REPLY}
      UART1_Write_Text('Command: ');
      PrintIncomingMsg(CabData^.IncomingMsg);
      UART1_Write_Text('/--------'+LF);
      {$ENDIF}
    end;
  end;

  Result := True;
  Exit;
end;

// *****************************************************************************
//  procedure UserStateMachine_Initialize
//     Parameters: : None
//     Returns     : None
//     Description : Called once when the library is starting.  Use to initalize
//                   variables, etc
// *****************************************************************************
procedure UserStateMachine_Initialize;
begin
  NMRAnetCabBridge_Initialize;
  ProxyNode.ID[0] := 0;
  ProxyNode.ID[1] := 0;
  ProxyNode.AliasID := 0;
  GlobalTimer := 0;
end;

// *****************************************************************************
//  procedure AppCallback_UserStateMachine_Process
//     Parameters: : None
//     Returns     : None
//     Description : Called as often as possible to run the user statemachine
// *****************************************************************************
procedure AppCallback_UserStateMachine_Process(Node: PNMRAnetNode);
var
  i: Integer;
  CabData: PCab;
  Address: Word;
  SpeedStep, AddressType: Byte;
  NewSpeed: THalfFloat;
begin
  if Node = GetPhysicalNode then
  begin
    case Node^.iUserStateMachine of
      STATE_BRIDGE_USER_START :  // Create the minimum number of Pings to put on the NCE bus to make it happy
          begin
            if Node^.State and NS_PERMITTED <> 0 then
            begin
              GlobalTimer := 0;
              if TrySendIdentifyProducer(Node^.Info, @EVENT_IS_PROXY) then
                Node^.iUserStateMachine := STATE_BRIDGE_FIND_PROXY;
            end;
            Exit;
          end;
      STATE_BRIDGE_FIND_PROXY :   // Find the Proxy node (Command Station) on the network before progressing
          begin
            if (ProxyNode.AliasID > 0) or (ProxyNode.ID[0] > 0) or (ProxyNode.ID[1] > 0) then
              Node^.iUserStateMachine := STATE_BRIDGE_CREATE_REQUIRED_CABS
            else begin
              if GlobalTimer > 10 then
                Node^.iUserStateMachine := STATE_BRIDGE_USER_START                     // Try again
            end;
            Exit;
          end;
      STATE_BRIDGE_CREATE_REQUIRED_CABS :
          begin
            for i := ID_MIN_DEVICE_NCE to ID_MIN_DEVICE_NCE + NCE_CAB_BUS_PADDING - 1 do
              CreateCab(i);                                                     // Build and assign cabs 2 - N so make the throttle hardware happy
            Node^.iUserStateMachine := STATE_BRIDGE_POLL_CABS;
            Exit;
          end;
      STATE_BRIDGE_POLL_CABS :
          begin
            case CabBridge.iStateMachine of   // I could use the Train Data machine for this if I wanted
              STATE_SUB_BRIDGE_INITIALIZE :
                  begin
                    {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_DISCOVER_INITIALIZE'+LF); {$ENDIF}
                    FlushUartReceiver;
                    if CabBridge.Discovering or (CabBridge.iAssignedCabCount = 0) then
                      CabBridge.iDiscoveryCabID := ID_MIN_DEVICE_NCE
                    else
                      CabBridge.iDiscoveryCabID := CabBridge.iActiveCab;
                    CabBridge.iIncomingCount := 0;
                    CabBridge.iIncomingByteIndex := 0;
                    CabBridge.iOutGoingCount := 1;
                    CabBridge.iOutGoingByteIndex := 0;
                    CabBridge.OutGoingBuffer[0] := NCEBUS_PING or 0;            // Setup outgoing message (Sync)
                    CabBus_RS485_Select := 1;      // Select the 485 chip to transmit mode
                    LATB4_bit := 1;
                    CabBridge.iStateMachine := STATE_SUB_BRIDGE_SYNC_WAITFOR_HARDWARE_BUFFER_SPACE;
                    Exit;
                  end;
              STATE_SUB_BRIDGE_SYNC_WAITFOR_HARDWARE_BUFFER_SPACE :
                  begin {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_SUB_BRIDGE_SYNC_WAITFOR_HARDWARE_BUFFER_SPACE..............'+LF); {$ENDIF}
                    if U2STA.UTXBF = 0 then      // UARTx Transmit Buffer Full Status bit (read-only)  1 = Transmit buffer is full;  0 = Transmit buffer is not full, at least one more character can be written
                      CabBridge.iStateMachine := STATE_SUB_BRIDGE_SYNC_TRANSMIT_BYTE;
                    Exit;
                  end;
              STATE_SUB_BRIDGE_SYNC_TRANSMIT_BYTE :
                  begin {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_SUB_BRIDGE_SYNC_TRANSMIT_BYTE..............'+LF); {$ENDIF}
                    U2TXREG := CabBridge.OutGoingBuffer[CabBridge.iOutGoingByteIndex];
                    Inc(CabBridge.iOutGoingByteIndex);
                    if CabBridge.iOutGoingByteIndex < CabBridge.iOutGoingCount then
                      CabBridge.iStateMachine := STATE_SUB_BRIDGE_SYNC_WAITFOR_HARDWARE_BUFFER_SPACE   // Stuff in the next byte when possible
                    else
                      CabBridge.iStateMachine := STATE_SUB_BRIDGE_SYNC_WAITFOR_HARDWARE_BUFFER_EMPTY;  // Wait until the last byte is transmitted
                    Exit;
                  end;
              STATE_SUB_BRIDGE_SYNC_WAITFOR_HARDWARE_BUFFER_EMPTY :
                  begin {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_SUB_BRIDGE_SYNC_WAITFOR_HARDWARE_BUFFER_EMPTY..............'+LF); {$ENDIF}
                    if U2STA.TRMT = 0 then    // Transmit Shift Register Empty bit (read-only) 1 = Transmit Shift Register is empty and transmit buffer is empty (the last transmission has completed) ; 0 = Transmit Shift Register is not empty, a transmission is in progress or queued
                    begin
                      CabBus_RS485_Select := 0;      // Select the 485 chip to receive mode
                      LATB4_bit := 0;
                      EnableCabBusTimer(28800);      // 31.25ns * 28800 = 900us      Needs some delay, the cabs are slow microprocessors
                      CabBridge.iStateMachine := STATE_SUB_BRIDGE_WAIT_SYNC_DELAY;
                    end;
                    Exit;
                  end;
              STATE_SUB_BRIDGE_WAIT_SYNC_DELAY :
                  begin  // Waiting for the Timer to Expire and jump us to the next state
                    {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_DISCOVER_WAIT_SYNC_DELAY'+LF); {$ENDIF}
                    Exit;
                  end;
              STATE_SUB_BRIDGE_INITIAIZE_PING :
                  begin
                    FlushUartReceiver;
                    CabBridge.iIncomingCount := 0;
                    CabBridge.iIncomingByteIndex := 0;
                    CabBridge.iOutGoingCount := 1;
                    CabBridge.iOutGoingByteIndex := 0;
                    CabBridge.OutGoingBuffer[0] := NCEBUS_PING or CabBridge.iDiscoveryCabID;     // Setup outgoing message
                    CabBridge.LastPortRead := PortB;
                    CNIE_bit := 1;                                                               // Pin Change Interrupt enable
                    CabBus_RS485_Select := 1;      // Select the 485 chip to transmit mode
                    LATB4_bit := 1;
                    CabBridge.iStateMachine := STATE_SUB_BRIDGE_SYNC_WAITFOR_HARDWARE_BUFFER_SPACE;
                    Exit;
                  end;
              STATE_SUB_BRIDGE_PING_WAITFOR_HARDWARE_BUFFER_SPACE :
                  begin {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_SUB_BRIDGE_SYNC_WAITFOR_HARDWARE_BUFFER_SPACE..............'+LF); {$ENDIF}
                    if U2STA.UTXBF = 0 then      // UARTx Transmit Buffer Full Status bit (read-only)  1 = Transmit buffer is full;  0 = Transmit buffer is not full, at least one more character can be written
                      CabBridge.iStateMachine := STATE_SUB_BRIDGE_SYNC_TRANSMIT_BYTE;
                    Exit;
                  end;
              STATE_SUB_BRIDGE_PING_TRANSMIT_BYTE :
                  begin {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_SUB_BRIDGE_SYNC_TRANSMIT_BYTE..............'+LF); {$ENDIF}
                    U2TXREG := CabBridge.OutGoingBuffer[CabBridge.iOutGoingByteIndex];
                    Inc(CabBridge.iOutGoingByteIndex);
                    if CabBridge.iOutGoingByteIndex < CabBridge.iOutGoingCount then
                      CabBridge.iStateMachine := STATE_SUB_BRIDGE_SYNC_WAITFOR_HARDWARE_BUFFER_SPACE
                    else
                      CabBridge.iStateMachine := STATE_SUB_BRIDGE_SYNC_WAITFOR_HARDWARE_BUFFER_EMPTY;
                    Exit;
                  end;
              STATE_SUB_BRIDGE_PING_WAITFOR_HARDWARE_BUFFER_EMPTY :
                  begin {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_SUB_BRIDGE_SYNC_WAITFOR_HARDWARE_BUFFER_EMPTY..............'+LF); {$ENDIF}
                    if U2STA.TRMT = 0 then    // Transmit Shift Register Empty bit (read-only) 1 = Transmit Shift Register is empty and transmit buffer is empty (the last transmission has completed) ; 0 = Transmit Shift Register is not empty, a transmission is in progress or queued
                    begin
                      CabBus_RS485_Select := 0;      // Select the 485 chip to receive mode
                      LATB4_bit := 0;
                      EnableCabBusTimer(57600);          // 31.25ns * 57600 = 1800us     Needs some delay, the cabs are slow microprocessors
                      CabBridge.iStateMachine := STATE_SUB_BRIDGE_WAIT_FOR_RESPONSE;
                    end;
                    Exit;
                  end;
              STATE_SUB_BRIDGE_WAIT_FOR_RESPONSE :
                  begin   // Waiting for the Timer to expire or we detect a reply....
                    // See CabBus_Timeout function for the Timeout or CabBus_UART_RX_StateMachine for a reply and what the next state is
                    {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_DISCOVER_WAIT_FOR_RESPONSE'+LF); {$ENDIF}
                    Exit;
                  end;
              STATE_SUB_BRIDGE_TIMEOUT :
                  begin
                    {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_DISCOVER_TIMEOUT'+LF); {$ENDIF}
                    // Need to search the Allocated Cab List to find the CabBridge.iDiscoveryCabID matching Node to pull this
                    CabBridge.iStateMachine := STATE_SUB_BRIDGE_NEXT_CAB;
                    Exit;
                  end;
              STATE_SUB_BRIDGE_CAB_REPLIED :
                  begin
                    {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_DISCOVER_CAB_REPLIED'+LF); {$ENDIF}
                    CabBridge.ExistingCab := FindCab(CabBridge.iDiscoveryCabID);  // this may return null when discovering!!!!
                    if CabBridge.ExistingCab = nil then
                    begin
                      CreateCab(CabBridge.iDiscoveryCabID);                     // Throw away this message as it could be corrupted depending on timing of when the cab was plugged in
                      CabBridge.iStateMachine := STATE_SUB_BRIDGE_NEXT_CAB
                    end else
                    begin
                      if HandleCabBusReply(CabBridge.ExistingCab) then
                        CabBridge.iStateMachine := STATE_SUB_BRIDGE_DISPATCH_MESSAGE
                      else
                        CabBridge.iStateMachine := STATE_SUB_BRIDGE_NEXT_CAB
                    end;
                    Exit;
                  end;
              STATE_SUB_BRIDGE_DISPATCH_MESSAGE :
                  begin
                    {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_SUB_BRIDGE_DISPATCH_MESSAGE'+LF); {$ENDIF}
                    if DispatchMessage(CabBridge.ExistingCab) then
                      CabBridge.iStateMachine := STATE_SUB_BRIDGE_NEXT_CAB;
                    Exit;
                  end;
              STATE_SUB_BRIDGE_NEXT_CAB :
                  begin
                    {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_DISCOVER_NEXT_CAB'+LF); {$ENDIF}
                    if CabBridge.Discovering then
                    begin
                      Inc(CabBridge.iDiscoveryCabID);
                      if CabBridge.iDiscoveryCabID > ID_MAX_DEVICE_NCE then
                      begin
                        CabBridge.Discovering := False;
                        CabBridge.DiscoverTimer := 0;
                        CabBridge.iStateMachine := STATE_SUB_BRIDGE_INITIALIZE;       // Start over and send the Sync again
                      end else
                        CabBridge.iStateMachine := STATE_SUB_BRIDGE_INITIAIZE_PING;   // Ping the next one
                    end else
                    begin
                      Inc(CabBridge.iActiveCab);
                      if CabBridge.iActiveCab >= CabBridge.iAssignedCabCount then
                      begin
                        CabBridge.Discovering := CabBridge.DiscoverTimer >= REDISCOVERY_TIME;    // Check to see if we should discover again
                        CabBridge.iStateMachine := STATE_SUB_BRIDGE_INITIALIZE;                  // Start over and send the Sync again
                        CabBridge.iActiveCab := 0;
                      end else
                        CabBridge.iStateMachine := STATE_SUB_BRIDGE_INITIAIZE_PING;  // Ping the next known one
                    end;
                    Exit;
                  end;
            end;
            Exit;
          end;
    end;
  end else
  begin
    // Cab Nodes, These states are entered by key presses and set by the Physical
    // node's interaction with the Cab Bus
    CabData := PCab( Node^.UserData);
    case Node^.iUserStateMachine of
      STATE_BRIDGE_USER_START :
          begin
            if Node^.State and NS_PERMITTED <> 0 then
              Node^.iUserStateMachine := STATE_CAB_IDLE;
            Exit;
          end;
      STATE_CAB_IDLE :
          begin
            // Nothing going on....
            Exit;
          end;
      STATE_CAB_SELECT_LOCO :
          begin
            case CabData^.iStateMachine of
              STATE_SUB_BRIDGE_INITIALIZE :
                  begin {$IFDEF DEBUG_STATE_CAB_SELECT_LOCO_STATEMACHINE} UART1_Write_Text('STATE_SUB_BRIDGE_INITIALIZE'+LF); {$ENDIF}
                     CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_SEND_PROXY_MANAGE_LOCK;
                     Exit;
                  end;
              STATE_CAB_SELECT_LOCO_SEND_PROXY_MANAGE_LOCK :
                  begin {$IFDEF DEBUG_STATE_CAB_SELECT_LOCO_STATEMACHINE} UART1_Write_Text('STATE_CAB_SELECT_LOCO_SEND_PROXY_MANAGE_LOCK'+LF); {$ENDIF}
                    if TrySendTractionProxyManage(Node^.Info, ProxyNode, True) then
                      CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_GENERIC_REPLY_WAIT; // Wait for the Manage Reply Callback
                    CabData^.WatchDog := 0;
                    Exit;
                  end;
              STATE_CAB_SELECT_LOCO_SEND_PROXY_ALLOCATE :
                  begin {$IFDEF DEBUG_STATE_CAB_SELECT_LOCO_STATEMACHINE} UART1_Write_Text('STATE_CAB_SELECT_LOCO_SEND_PROXY_ALLOCATE'+LF); {$ENDIF}

                    Address := CabMessageToTrainAddress(@CabData^.IncomingMsg);

                    {$IFNDEF FPC}
                    WordToStr(Address, s1);
                    UART1_Write_Text('Address = ' + s1 + LF);
                    {$ENDIF}


                    SpeedStep := 28;

              {      AppCallback_ReadConfiguration(CONFIG_OFFSET_SPEED_STEP, 1, @SpeedStep);    // These offsets are into the Physical Nodes configuration address space
                    AppCallback_ReadConfiguration(CONFIG_OFFSET_ADDRESS_TYPE, 1, @AddressType);

                    if AddressType = 1 then
                      Address := Address or $C000;
                    case SpeedStep of
                      0 : SpeedStep := 14;
                      1 : SpeedStep := 28;
                      2 : SpeedStep := 128;
                    end;
                   }
                    if TrySendTractionProxyAllocate(Node^.Info, ProxyNode, TRACTION_PROXY_TECH_ID_DCC, Address, SpeedStep, 0) then
                      CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_GENERIC_REPLY_WAIT;  // Wait for the Allocate Reply Callback
                    CabData^.WatchDog := 0;
                    Exit;
                  end;
              STATE_CAB_SELECT_LOCO_SEND_PROXY_MANAGE_UNLOCK :
                  begin {$IFDEF DEBUG_STATE_CAB_SELECT_LOCO_STATEMACHINE} UART1_Write_Text('STATE_CAB_SELECT_LOCO_SEND_PROXY_MANAGE_UNLOCK'+LF); {$ENDIF}
                    if TrySendTractionProxyManage(Node^.Info, ProxyNode, False) then
                      CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_SEND_TRACTION_MANAGE_LOCK; // No Reply for Unlock
                    CabData^.WatchDog := 0;
                    Exit;
                  end;
              STATE_CAB_SELECT_LOCO_SEND_TRACTION_MANAGE_LOCK :
                  begin {$IFDEF DEBUG_STATE_CAB_SELECT_LOCO_STATEMACHINE} UART1_Write_Text('STATE_CAB_SELECT_LOCO_SEND_TRACTION_MANAGE_LOCK'+LF); {$ENDIF}
                    if TrySendTractionManage(Node^.Info, Node^.TrainData.LinkedNode, True) then
                      CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_GENERIC_REPLY_WAIT;  // Wait for the Lock Reply Callback
                    CabData^.WatchDog := 0;
                    Exit;
                  end;
              STATE_CAB_SELECT_LOCO_SEND_TRACTION_ASSIGN_CONTROLLER :
                  begin {$IFDEF DEBUG_STATE_CAB_SELECT_LOCO_STATEMACHINE} UART1_Write_Text('STATE_CAB_SELECT_LOCO_SEND_TRACTION_ASSIGN_CONTROLLER'+LF); {$ENDIF}
                    if TrySendTractionControllerConfig(Node^.Info, Node^.TrainData.LinkedNode, Node^.Info, True) then
                      CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_GENERIC_REPLY_WAIT;  // Wait for the Lock Reply Callback
                    CabData^.WatchDog := 0;
                    Exit;
                  end;
              STATE_CAB_SELECT_LOCO_SEND_TRACTION_QUERY_SPEED :
                  begin {$IFDEF DEBUG_STATE_CAB_SELECT_LOCO_STATEMACHINE} UART1_Write_Text('STATE_CAB_SELECT_LOCO_SEND_TRACTION_QUERY_SPEED'+LF); {$ENDIF}
                    if TrySendTractionQuerySpeed(Node^.Info, Node^.TrainData.LinkedNode) then
                      CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_GENERIC_REPLY_WAIT;  // Wait for the Lock Reply Callback
                    CabData^.WatchDog := 0;
                    Exit;
                  end;
              STATE_CAB_SELECT_LOCO_SEND_TRACTION_QUERY_FUNCTIONS :
                  begin {$IFDEF DEBUG_STATE_CAB_SELECT_LOCO_STATEMACHINE} UART1_Write_Text('STATE_CAB_SELECT_LOCO_SEND_TRACTION_QUERY_FUNCTIONS'+LF); {$ENDIF}
                    if TrySendTractionQueryFunction(Node^.Info, Node^.TrainData.LinkedNode, 0) then
                      CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_GENERIC_REPLY_WAIT;  // Wait for the Lock Reply Callback
                    CabData^.WatchDog := 0;
                    Exit;
                  end;
              STATE_CAB_SELECT_LOCO_SEND_TRACTION_MANAGE_UNLOCK :
                  begin {$IFDEF DEBUG_STATE_CAB_SELECT_LOCO_STATEMACHINE} UART1_Write_Text('STATE_CAB_SELECT_LOCO_SEND_TRACTION_MANAGE_UNLOCK'+LF); {$ENDIF}
                    if TrySendTractionManage(Node^.Info, Node^.TrainData.LinkedNode, False) then
                      Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG;   // We are done....
                    CabData^.WatchDog := 0;
                    Exit;
                  end;
              STATE_CAB_SELECT_LOCO_GENERIC_REPLY_WAIT :
                  begin
                    // Waiting for the Reply to come into a callback
                    if CabData^.WatchDog > 200 then
                    begin
                      {$IFDEF DEBUG_STATE_CAB_SELECT_LOCO_STATEMACHINE} UART1_Write_Text('STATE_CAB_SELECT_LOCO_SEND_PROXY_MANAGE_REPLY_WAIT'+LF); {$ENDIF}
                      CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_GENERIC_TIMEOUT_PROXY_UNLOCK;    // Force unlocks and exit
                    end;
                    Exit;
                  end;
              STATE_CAB_SELECT_LOCO_GENERIC_TIMEOUT_PROXY_UNLOCK :
                  begin {$IFDEF DEBUG_STATE_CAB_SELECT_LOCO_STATEMACHINE} UART1_Write_Text('STATE_CAB_SELECT_LOCO_GENERIC_TIMEOUT_PROXY_UNLOCK'+LF); {$ENDIF}
                    // Unsure if we are locked or not, just release just in case
                    if TrySendTractionProxyManage(Node^.Info, ProxyNode, False) then
                      CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_SEND_TRACTION_MANAGE_UNLOCK; // No Reply for Unlock, just unlock the Traction Protcol and end
                    Exit;
                  end;
            end;
          end;
      STATE_CAB_RUN_MACRO :
          begin
            if NMRAnetUtilities_NullNodeIDInfo(Node^.TrainData.LinkedNode) then
            begin
              Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG; // We are done....
              Exit;
            end else
            begin
              Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG; // We are done....
              Exit;
            end;
          end;
      STATE_CAB_RUN_CMD :
          begin
            if NMRAnetUtilities_NullNodeIDInfo(Node^.TrainData.LinkedNode) then
            begin
              Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG; // We are done....
              Exit;
            end else
            begin
              case CabData^.IncomingMsg.DataBytes[0] of
                NCE_CAB_DIR_TOGGLE                  :
                  begin
                    if Node^.TrainData.SpeedDir and $8000 <> 0 then
                      Node^.TrainData.SpeedDir := Node^.TrainData.SpeedDir and not $8000
                    else
                      Node^.TrainData.SpeedDir := Node^.TrainData.SpeedDir or $8000;
                    if TrySendTractionSpeedSet(Node^.Info, Node^.TrainData.LinkedNode, Node^.TrainData.SpeedDir) then
                      Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG; // We are done....
                    Exit;
                  end;
                NCE_HORN_KEY_DOWN                   :
                  begin
                    if TrySendTractionFunctionSet(Node^.Info, Node^.TrainData.LinkedNode, FUNCTION_HORN, 1) then
                      Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG; // We are done....
                    Exit;
                  end;
                NCE_CAB_ONE_STEP_FASTER             :
                  begin
                    NewSpeed := ChangeSpeed(Node^.TrainData.SpeedDir, +1);
                    if TrySendTractionSpeedSet(Node^.Info, Node^.TrainData.LinkedNode, NewSpeed) then
                    begin
                      Node^.TrainData.SpeedDir := NewSpeed;
                      Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG; // We are done....
                    end;
                    Exit;
                  end;
                NCE_CAB_ONE_STEP_SLOWER             :
                  begin
                    NewSpeed := ChangeSpeed(Node^.TrainData.SpeedDir, -1);
                    if TrySendTractionSpeedSet(Node^.Info, Node^.TrainData.LinkedNode, NewSpeed) then
                    begin
                      Node^.TrainData.SpeedDir := NewSpeed;
                      Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG; // We are done....
                    end;
                    Exit;
                  end;
                NCE_CAB_EMERGENCY_STOP              :
                  begin
                    if TrySendTractionEmergencyStop(Node^.Info, Node^.TrainData.LinkedNode) then
                      Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG; // We are done....
                    Exit;
                  end;
                NCE_CAB_BELL                        :
                  begin
                    if ToggleFunction(Node, Node^.TrainData.Functions, FUNCTION_BELL) then
                      Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG; // We are done....
                    Exit;
                  end;
                NCE_CAB_TOGGLE_F0_0                 :
                  begin
                    if ToggleFunction(Node, Node^.TrainData.Functions, 0) then
                      Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG; // We are done....
                  end;
                NCE_CAB_TOGGLE_F1_1                 :
                  begin
                    if ToggleFunction(Node, Node^.TrainData.Functions, 1) then
                      Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG; // We are done....
                    Exit;
                  end;
                NCE_CAB_TOGGLE_F2_2                 :
                  begin
                    if ToggleFunction(Node, Node^.TrainData.Functions, 2) then
                      Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG; // We are done....
                    Exit;
                  end;
                NCE_CAB_TOGGLE_F3_3                 :
                  begin
                    if ToggleFunction(Node, Node^.TrainData.Functions, 3) then
                      Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG; // We are done....
                    Exit;
                  end;
                NCE_CAB_TOGGLE_F4_4                 :
                  begin
                    if ToggleFunction(Node, Node^.TrainData.Functions, 4) then
                      Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG; // We are done....
                    Exit;
                  end;
                NCE_CAB_TOGGLE_F5_5                 :
                  begin
                    if ToggleFunction(Node, Node^.TrainData.Functions, 5) then
                      Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG; // We are done....
                    Exit;
                  end;
                NCE_CAB_TOGGLE_F6_6                 :
                  begin
                    if ToggleFunction(Node, Node^.TrainData.Functions, 6) then
                      Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG; // We are done...
                    Exit;
                  end;
                NCE_CAB_TOGGLE_F7_7                 :
                  begin
                    if ToggleFunction(Node, Node^.TrainData.Functions, 7) then
                      Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG; // We are done....
                    Exit;
                  end;
                NCE_CAB_TOGGLE_F8_8                 :
                  begin
                    if ToggleFunction(Node, Node^.TrainData.Functions, 8) then
                      Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG; // We are done....
                    Exit;
                  end;
                NCE_CAB_9                           :
                  begin
                    if ToggleFunction(Node, Node^.TrainData.Functions, 9) then
                      Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG; // We are done....
                    Exit;
                  end;
                NCE_HORN_KEY_UP                     :
                  begin
                    if TrySendTractionFunctionSet(Node^.Info, Node^.TrainData.LinkedNode, FUNCTION_HORN, 0) then
                      Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG; // We are done....
                    Exit;
                  end;
                NCE_CAB_FIVE_STEPS_FASTER           :
                  begin
                    NewSpeed := ChangeSpeed(Node^.TrainData.SpeedDir, +5);
                    if TrySendTractionSpeedSet(Node^.Info, Node^.TrainData.LinkedNode, NewSpeed) then
                    begin
                      Node^.TrainData.SpeedDir := NewSpeed;
                      Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG; // We are done....
                    end;
                    Exit;
                  end;
                NCE_CAB_FIVE_STEPS_SLOWER           :
                  begin
                    NewSpeed := ChangeSpeed(Node^.TrainData.SpeedDir, -5);
                    if TrySendTractionSpeedSet(Node^.Info, Node^.TrainData.LinkedNode, NewSpeed) then
                    begin
                      Node^.TrainData.SpeedDir := NewSpeed;
                      Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG; // We are done....
                    end;
                    Exit;
                  end;
                NCE_CAB_DIR_FORWARD                 :
                  begin
                    if TrySendTractionDirectionSet(Node^.Info, Node^.TrainData.LinkedNode, Node^.TrainData.SpeedDir, True) then
                      Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG; // We are done....
                    Exit;
                  end;
                NCE_CAB_DIR_REVERSE                 :
                  begin
                    if TrySendTractionDirectionSet(Node^.Info, Node^.TrainData.LinkedNode, Node^.TrainData.SpeedDir, False) then
                      Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG; // We are done....
                    Exit;
                  end
              else
                Node^.iUserStateMachine := STATE_CAB_CLEAR_MSG; // We are done....
              end;
            end;
          end;
      STATE_CAB_CLEAR_MSG :
          begin {$IFDEF DEBUG_STATE_CAB_STATEMACHINE} UART1_Write_Text('STATE_CAB_CLEAR_MSG'+LF); {$ENDIF}
            CabData^.IncomingMsg.Full := False;
            CabData^.State := CabData^.State and not (CS_MACRO_MESSAGE or CS_LOCO_SELECT);
            CabData^.IncomingMsg.Count := 0;
            Node^.iUserStateMachine := STATE_CAB_IDLE; // We are done....
            CabData^.iStateMachine := STATE_SUB_BRIDGE_INITIALIZE;  // Reset
          end;
    end;
  end;
end;

// *****************************************************************************
//  procedure AppCallback_NodeInitialize
//     Parameters: : Node : Pointer to the node that needs to be initilized to its intial value
//     Returns     : None
//     Description : Typically called when a node is being intialized to be
//                   logged into the network.  It is possible the node can be
//                   discarded then reused so it may be called more than once for
//                   virtual nodes
// *****************************************************************************
procedure AppCallback_NodeInitialize(Node: PNMRAnetNode);
begin
  // Assign the user data record to the Node for future use
   Node^.UserData := @CabArray[Node^.iIndex];
   Node^.iUserStateMachine := STATE_BRIDGE_USER_START;

   // Initialize the data, every time the node is reused!
   ZeroizeNceCabData( PCab (Node^.UserData))
end;

{$IFDEF SUPPORT_TRACTION}
// *****************************************************************************
//  procedure AppCallback_TractionControlReply
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   Dest   : Full Node ID (and Alias if on CAN) of the dest node for the message
//                   DataBytes: pointer to the raw data bytes
//     Returns     : None
//     Description : Called when a Traction Protocol request comes in
// *****************************************************************************
procedure AppCallback_TractionProtocol(Node: PNMRAnetNode; AMessage: POPStackMessage);
var
 MultiFrameBuffer: PMultiFrameBuffer;
begin
  {$IFDEF FPC}EnterCriticalsection(OPStackCriticalSection);{$ENDIF}
  MultiFrameBuffer := PMultiFrameBuffer( PByte( AMessage^.Buffer));
  case MultiFrameBuffer^.DataArray[0] of
    TRACTION_CONTROLLER_CONFIG :
        begin
          case MultiFrameBuffer^.DataArray[1] of
            TRACTION_CONTROLLER_CONFIG_NOTIFY :
                begin

                end;
          end;
        end;
  end;
  {$IFDEF FPC}LeaveCriticalsection(OPStackCriticalSection);{$ENDIF}
end;

// *****************************************************************************
//  procedure AppCallback_TractionProtocolReply
//     Parameters: : Node           : Pointer to the node that the traction protocol has been called on
//                   ReplyMessage   : The Reply Message that needs to be allocated, populated and returned so it can be sent
//                   RequestingMessage    : Message that was sent to the node containing the requested information
//     Returns     : True if the RequestingMessage is handled and the ReplyMessage is ready to send
//                   False if the request has not been completed due to no available buffers or waiting on other information
//     Description : Called in response to a Traction Protcool request
// *****************************************************************************
procedure AppCallback_TractionProtocolReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
var
 MultiFrameBuffer: PMultiFrameBuffer;
 CabData: PCab;
begin
  MultiFrameBuffer := PMultiFrameBuffer( PByte( AMessage^.Buffer));
  CabData := PCab( Node^.UserData);
  case MultiFrameBuffer^.DataArray[0] of
    TRACTION_QUERY_SPEED :
        begin
          Node^.TrainData.SpeedDir := (MultiFrameBuffer^.DataArray[1] shl 8) or MultiFrameBuffer^.DataArray[2];
          CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_SEND_TRACTION_QUERY_FUNCTIONS
        end;
    TRACTION_QUERY_FUNCTION :
        begin
         // Node^.TrainData.Functions......
         CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_SEND_TRACTION_MANAGE_UNLOCK
        end;
    TRACTION_CONTROLLER_CONFIG :
        begin
          case MultiFrameBuffer^.DataArray[1] of
            TRACTION_CONTROLLER_CONFIG_ASSIGN :
                begin
                  if MultiFrameBuffer^.DataArray[2] = TRACTION_CONTROLLER_ASSIGN_REPLY_OK then
                    CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_SEND_TRACTION_QUERY_SPEED
                  else
                    CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_GENERIC_TIMEOUT_PROXY_UNLOCK   // Can't reserve now go back to normal polling
                end;
          end;
        end;
    TRACTION_CONSIST :
        begin
          case MultiFrameBuffer^.DataArray[1] of
            TRACTION_CONSIST_ATTACH :
                begin
                end;
            TRACTION_CONSIST_DETACH :
                begin
                end;
            TRACTION_CONSIST_QUERY :
                begin
                end;
          end // case
        end;
    TRACTION_MANAGE :
        begin
          case MultiFrameBuffer^.DataArray[1] of
            TRACTION_MANAGE_RESERVE :
                begin
                  if MultiFrameBuffer^.DataArray[2] = TRACTION_MANAGE_RESERVE_REPLY_OK then
                    CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_SEND_TRACTION_ASSIGN_CONTROLLER
                  else
                    CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_GENERIC_TIMEOUT_PROXY_UNLOCK   // Can't reserve now go back to normal polling
                end;
          end
        end;
    end;
end;
{$ENDIF}

{$IFDEF SUPPORT_TRACTION_PROXY}
// *****************************************************************************
//  procedure AppCallback_TractionProtocol
//     Parameters: : Node           : Pointer to the node that the traction protocol has been called on
//                   ReplyMessage   : The Reply Message that needs to be allocated, populated and returned so it can be sent
//                   RequestingMessage    : Message that was sent to the node containing the requested information
//     Returns     : True if the RequestingMessage is handled and the ReplyMessage is ready to send
//                   False if the request has not been completed due to no available buffers or waiting on other information
//     Description : Called when a Traction Protocol message is received
// *****************************************************************************
function AppCallback_TractionProxyProtocol(Node: PNMRAnetNode; AMessage: POPStackMessage; SourceHasLock: Boolean): Boolean;
begin
  Result := False;
end;

// *****************************************************************************
//  procedure AppCallback_TractionProxyProtocolReply
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   Dest   : Full Node ID (and Alias if on CAN) of the dest node for the message
//                   DataBytes: pointer to the raw data bytes
//     Returns     : None
//     Description : Called in response to a Traction Proxy request
// *****************************************************************************
procedure AppCallback_TractionProxyProtocolReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
var
  MultiFrameBuffer: PMultiFrameBuffer;
  CabData: PCab;
  i: Integer;
begin
  MultiFrameBuffer := PMultiFrameBuffer( PByte(AMessage^.Buffer));
  CabData := PCab( Node^.UserData);
  case AMessage^.Buffer^.DataArray[0] of
    TRACTION_PROXY_MANAGE :
        begin
          if AMessage^.Buffer^.DataArray[1] = TRACTION_PROXY_MANAGE_RESERVE then
          begin
             if AMessage^.Buffer^.DataArray[2] = 0 then
               CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_SEND_PROXY_ALLOCATE         // Move to next state after reserving
             else
               CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_GENERIC_TIMEOUT_PROXY_UNLOCK   // Can't reserve now go back to normal polling
          end;
          Exit;
        end;
    TRACTION_PROXY_ALLOCATE :
        begin
          Node^.TrainData.LinkedNode.AliasID := (MultiFrameBuffer^.DataArray[11] shl 8) or (MultiFrameBuffer^.DataArray[12]);
          NMRAnetUtilities_Load48BitNodeIDWithSimpleData(Node^.TrainData.LinkedNode.ID, PSimpleDataArray( PByte( @MultiFrameBuffer^.DataArray[5]))^);
          CabData^.iStateMachine := STATE_CAB_SELECT_LOCO_SEND_PROXY_MANAGE_UNLOCK;    // Now need to unlock the Proxy
          Exit;
        end;
  end; // case
end;
{$ENDIF}

// *****************************************************************************
//  procedure AppCallBack_ProtocolSupportReply
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   Dest   : Full Node ID (and Alias if on CAN) of the dest node for the message
//                   DataBytes: pointer Raw data bytes, Byte 0 and 1 are the Alias
//     Returns     : None
//     Description : Called in response to a Protocol Support Request
// *****************************************************************************
procedure AppCallBack_ProtocolSupportReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
begin

end;

// *****************************************************************************
//  procedure AppCallback_ConsumerIdentified
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   Dest   : Full Node ID (and Alias if on CAN) of the dest node for the message
//                   MTI    : MTI of the message
//                   EventID: pointer to the Event ID for the message
//     Returns     : None
//     Description : This is called directly from the Hardware receive buffer.  Do
//                   not do anything here that stalls the call.  This is called
//                   Asyncronously from the Statemachine loop and the Statemachine loop
//                   is stalled until this returns.  Set a flag and move on is the
//                   best stratagy or store info in a buffer and process in the
//                   main statemachine.
// *****************************************************************************
procedure AppCallback_ConsumerIdentified(var Source: TNodeInfo; MTI: Word; EventID: PEventID);
begin

end;

// *****************************************************************************
//  procedure AppCallback_ProducerIdentified
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   Dest   : Full Node ID (and Alias if on CAN) of the dest node for the message
//                   MTI    : MTI of the message
//                   EventID: pointer to the Event ID for the message
//     Returns     : None
//     Description : This is called directly from the Hardware receive buffer.  Do
//                   not do anything here that stalls the call.  This is called
//                   Asyncronously from the Statemachine loop and the Statemachine loop
//                   is stalled until this returns.  Set a flag and move on is the
//                   best stratagy or store info in a buffer and process in the
//                   main statemachine.
// *****************************************************************************
procedure AppCallback_ProducerIdentified(var Source: TNodeInfo; MTI: Word; EventID: PEventID);
begin
  if NMRAnetUtilities_EqualEventID(EventID, @EVENT_IS_PROXY) then
    ProxyNode := Source;
end;

// *****************************************************************************
//  procedure AppCallback_LearnEvent
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   EventID: pointer to the Event ID for the message
//     Returns     : None
//     Description : This is called directly from the Hardware receive buffer.  Do
//                   not do anything here that stalls the call.  This is called
//                   Asyncronously from the Statemachine loop and the Statemachine loop
//                   is stalled until this returns.  Set a flag and move on is the
//                   best stratagy or store info in a buffer and process in the
//                   main statemachine.
// *****************************************************************************
procedure AppCallback_LearnEvent(var Source: TNodeInfo; EventID: PEventID);
begin

end;

// *****************************************************************************
//  procedure AppCallBack_PCEventReport
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   EventID: pointer to the Event ID for the message
//     Returns     : None
//     Description : This is called directly from the Hardware receive buffer.  Do
//                   not do anything here that stalls the call.  This is called
//                   Asyncronously from the Statemachine loop and the Statemachine loop
//                   is stalled until this returns.  Set a flag and move on is the
//                   best stratagy or store info in a buffer and process in the
//                   main statemachine.
// *****************************************************************************
procedure AppCallBack_PCEventReport(var Source: TNodeInfo; EventID: PEventID);
begin

end;

// *****************************************************************************
//  procedure AppCallback_RemoteButtonReply
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   Dest   : Full Node ID (and Alias if on CAN) of the dest node for the message
//                   DataBytes: pointer to the raw data bytes
//     Returns     : None
//     Description : Called in response to a Remote Button request
// *****************************************************************************
procedure AppCallback_RemoteButtonReply(Node: PNMRAnetNode; var Source: TNodeInfo; DataBytes: PSimpleBuffer);
begin

end;

{$IFDEF SUPPORT_TRACTION}
// *****************************************************************************
//  procedure AppCallback_SimpleTrainNodeInfoReply
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   Dest   : Full Node ID (and Alias if on CAN) of the dest node for the message
//                   TrainNodeInfo: pointer to the null terminated strings
//     Returns     : None
//     Description : Called in response to a STNIP request
// *****************************************************************************
procedure AppCallback_SimpleTrainNodeInfoReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
begin

end;
{$ENDIF}

// *****************************************************************************
//  procedure AppCallback_Timer_100ms
//     Parameters: : None
//     Returns     : None
//     Description : Typcally called from another thread or interrupt, only use
//                   to update asyncronous flags
// *****************************************************************************
procedure AppCallback_Timer_100ms;
var
  i: Integer;
  Cab: PCab;
begin
  Inc(GlobalTimer);

   // Count up to the time out then freeze.  The Timer Count will be reset after the
  // main loop is done rediscovering
  if CabBridge.DiscoverTimer < REDISCOVERY_TIME then
    Inc(CabBridge.DiscoverTimer);

  for i := 0 to CabBridge.iAssignedCabCount - 1 do
  begin
    Cab := PCab( CabBridge.AssignedCabs[i]^.UserData);
    Inc( Cab^.WatchDog);
  end;
end;

// *****************************************************************************
//  procedure AppCallback_SimpleNodeInfoReply
//     Parameters: : Source   : Full Node ID (and Alias if on CAN) of the source node for the message
//                   Dest     : Full Node ID (and Alias if on CAN) of the dest node for the message
//                   NodeInfo : pointer to the null terminated strings
//     Returns     : None
//     Description : Called in response to a SNIP Request
// *****************************************************************************
procedure AppCallback_SimpleNodeInfoReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
begin

end;

// *****************************************************************************
//  procedure AppCallback_VerifiedNodeID
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   EventID: pointer to the Event ID for the message
//     Returns     : None
//     Description : This is called directly from the Hardware receive buffer.  Do
//                   not do anything here that stalls the call.  This is called
//                   Asyncronously from the Statemachine loop and the Statemachine loop
//                   is stalled until this returns.  Set a flag and move on is the
//                   best stratagy or store info in a buffer and process in the
//                   main statemachine.
// *****************************************************************************
procedure AppCallback_VerifiedNodeID(var Source: TNodeInfo; NodeID: PNodeID);
begin

end;

// *****************************************************************************
//  procedure AppCallback_InitializationComplete
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   EventID: pointer to the Event ID for the message
//     Returns     : None
//     Description : This is called directly from the Hardware receive buffer.  Do
//                   not do anything here that stalls the call.  This is called
//                   Asyncronously from the Statemachine loop and the Statemachine loop
//                   is stalled until this returns.  Set a flag and move on is the
//                   best stratagy or store info in a buffer and process in the
//                   main statemachine.
// *****************************************************************************
procedure AppCallback_InitializationComplete(var Source: TNodeInfo; NodeID: PNodeID);
begin

end;

end.