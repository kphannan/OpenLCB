unit template_userstatemachine;

{$IFDEF FPC}
{$mode objfpc}{$H+}

interface
{$ENDIF}

{$I Options.inc}
{.$DEFINE DEBUG_DISCOVER_STATEMACHINE}
{.$DEFINE DEBUG_KNOWNDEVICES_STATEMACHINE}

uses
  Float16,
  opstacktypes,           
  nmranetdefines,
  opstackdefines,
  template_node,
  opstack_api,
  nmranetutilities,
  NMRAnetNceBridgeDefines;

procedure UserStateMachine_Initialize;
procedure AppCallback_UserStateMachine_Process(Node: PNMRAnetNode);
procedure AppCallback_NodeInitialize(Node: PNMRAnetNode);

// Called every 100ms typically from another thread so only use to update flags
procedure AppCallback_Timer_100ms;

// These message are called from the mainstatemachine loop.  They have been stored in
// internal storage buffers.  See the notes to understand the implications of this and how to use them correctly
procedure AppCallback_SimpleNodeInfoReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
procedure AppCallBack_ProtocolSupportReply(Node: PNMRAnetNode; AMessage: POPStackMessage);  // This could be 2 replies per call.. read docs
procedure AppCallback_RemoteButtonReply(Dest: PNMRAnetNode; var Source: TNodeInfo; DataBytes: PSimpleBuffer);
{$IFDEF SUPPORT_TRACTION}
procedure AppCallback_TractionProtocol(Node: PNMRAnetNode; AMessage: POPStackMessage);
procedure AppCallback_TractionProtocolReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
procedure AppCallback_SimpleTrainNodeInfoReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
{$ENDIF}
{$IFDEF SUPPORT_TRACTION_PROXY}
function AppCallback_TractionProxyProtocol(Node: PNMRAnetNode; AMessage: POPStackMessage; SourceHasLock: Boolean): Boolean;
procedure AppCallback_TractionProxyProtocolReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
{$ENDIF}

// These messages are called directly from the hardware receive buffer.  See the notes to understand the
// implications of this and how to use them correctly
procedure AppCallback_InitializationComplete(var Source: TNodeInfo; NodeID: PNodeID);
procedure AppCallback_VerifiedNodeID(var Source: TNodeInfo; NodeID: PNodeID);
procedure AppCallback_ConsumerIdentified(var Source: TNodeInfo; MTI: Word; EventID: PEventID);
procedure AppCallback_ProducerIdentified(var Source: TNodeInfo; MTI: Word; EventID: PEventID);
procedure AppCallback_LearnEvent(var Source: TNodeInfo; EventID: PEventID);
procedure AppCallBack_PCEventReport(var Source: TNodeInfo; EventID: PEventID);

function ExtractNceCab(Node: PNMRAnetNode): PNceCab;
procedure CabBus_Timeout;
procedure UART_RX_StateMachine;
procedure PinChangeInterrupt;


function OPStackNode_Allocate: PNMRAnetNode; external;

var
  CabBus_RS485_Select              : sbit; sfr; external;
  CabBus_RS485_Select_Direction    : sbit; sfr; external;

implementation

const
  STATE_USER_START              = 0;
  STATE_FIND_PROXY              = 1;
  STATE_CREATE_REQUIRED_CABS    = 2;
  STATE_DISCOVERDEVICES         = 3;
  STATE_KNOWNDEVICES            = 4;
  
  STATE_INITIALIZE           = 0;
  STATE_SEND_SYNC            = 1;
  STATE_WAIT_SYNC_DELAY      = 2;
  STATE_SEND_PING            = 3;
  STATE_WAIT_FOR_RESPONSE    = 4;
  STATE_TIMEOUT              = 5;
  STATE_CAB_REPLIED          = 6;
  STATE_DISPATCH_MESSAGE     = 7;
  STATE_NEXT_CAB             = 8;
  
var
  ProxyNode: TNodeInfo;
  GlobalTimer: Word;

// *****************************************************************************
//  procedure ExtractUserData
//     Parameters: : Node : Pointer to the node that needs to be initilized to its intial value
//     Returns     : Pointer to the defined User Data type
//     Description : Nice helper function to type cast the user data generic pointer
//                   to a pointer to the actual data type
// *****************************************************************************
function ExtractNceCab(Node: PNMRAnetNode): PNceCab;
begin
  Result := PNceCab( Node^.UserData)
end;

// ****************************************************************************
// *****************************************************************************
procedure WriteUARTByte(DataByte: Byte; TxReg: ^Word; StatusReg: ^Word; Wait: Boolean);
begin
  TxReg^ := DataByte;
  StatusReg^.UTXEN := 1;          // Force the Register in to the TSR so the Idle check is not "too fast" to start
  if Wait then
  begin
    while StatusReg^.TRMT = 1 do;   // Wait for the UART to start transmitting
    while StatusReg^.TRMT = 0 do;   // Wait for the UART to finsh transmitting to make sure the ENceBus timing is met
  end
end;

// ****************************************************************************
// *****************************************************************************
procedure WriteByte(DataByte: Byte; Wait: Boolean);
begin
  CabBus_RS485_Select := 1;      // Select the 485 chip to transmit mode
  WriteUARTByte(DataByte, @U2TXREG, @U2STA, Wait);
  CabBus_RS485_Select := 0;      // Select the 485 chip to receive mode
end;

// ****************************************************************************
// *****************************************************************************
procedure ZeroizeNceCabData(CabData: PNceCab);
var
  i, j: Integer;
begin
  CabData^.State := 0;
  CabData^.MissedPingCount := 0;
  CabData^.IncomingMsg.Count := 0;
  CabData^.IncomingMsg.Full := False;
  CabData^.ID := 0;
  for j := 0 to NCEBUS_MAX_DATA_BYTE - 1 do
    CabData^.IncomingMsg.DataBytes[j] := 0;
end;

// *****************************************************************************
// *****************************************************************************
function Cab_Allocate: PNceCab;
var
  i: Integer;
begin
  Result := nil;
  i := 0;
  while i < USER_MAX_NODE_COUNT do
  begin
    if NceCabArray[i].State and CS_ALLOCATED = 0 then
    begin
      Result := @NceCabArray[i];
      ZeroizeNceCabData(Result);
      NceCabArray[i].State := NceCabArray[i].State or CS_ALLOCATED;
      Exit;
    end;
    Inc(i)
  end
end;

// *****************************************************************************
// *****************************************************************************
procedure Cab_Free(CabData: PNceCab);
begin
  if CabData <> nil then
    CabData^.State := CabData^.State and not CS_ALLOCATED
end;

// ****************************************************************************
// *****************************************************************************
function CreateCabNode(CabID: Word): PNMRAnetNode;
var
  CabData: PNceCab;
begin
  Result := nil;
  CabData := Cab_Allocate;
  if CabData <> nil then
  begin
    Result := OPStackNode_Allocate;
    if Result <> nil then
    begin
      Result^.UserData := CabData;
      CabData^.ID := CabID;
      CabData^.State := CabData^.State or CS_DEVICE_ACTIVE and not CS_DEVICE_INACTIVE;  // Set the Device Active
    end else
    begin
      Cab_Free(CabData)
    end
  end
end;

// ****************************************************************************
// *****************************************************************************
procedure FlushUartReceiver;
var
  Temp: Word;
begin
  while (URXDA_U2STA_bit = 1) do Temp := U2RXREG;             // Flush the RX Buffer
  U2RXIF_Bit := 0;                                            // Reset the hardware RX statemachine
end;

// ****************************************************************************
// *****************************************************************************
procedure EnableCabBusTimer(Time: Word);
begin       
  TON_T4CON_bit := 0;      // Turn off
  T4IE_bit := 0;           // Disable the Interrupt
  T4IF_bit := 0;           // Clear T1IF
  T4IE_bit := 1;           // Enable the Interrupt
  PR4 := Time;             //
  TMR4 := 0;
  TON_T4CON_bit := 1;      // Turn on
end;

// ****************************************************************************
// *****************************************************************************
procedure DisableCabBusTimer;
begin
  TON_T4CON_bit := 0;      // Turn off
  T4IE_bit := 0;           // Disable the Interrupt
  TON_T4CON_bit := 0;      // Turn off
end;


// *****************************************************************************
//  procedure UserStateMachine_Initialize
//     Parameters: : None
//     Returns     : None
//     Description : Called once when the library is starting.  Use to initalize
//                   variables, etc
// *****************************************************************************
procedure UserStateMachine_Initialize;
var
  i, j: Integer;
begin
  CabBus_RS485_Select := 0;                // Default in Receive
  CabBus_RS485_Select_Direction := 0;      // Output
  for i := 0 to USER_MAX_NODE_COUNT - 1 do
    ZeroizeNceCabData( @NceCabArray[i]);
  NceBridge.Discovering := False;
  NceBridge.iDiscoveryCabID := ID_MIN_DEVICE;
  NceBridge.iStateMachine := STATE_USER_START;
  NceBridge.DiscoverTimer := 0;
  NceBridge.iAssignedCabCount := 0;
  for i := 0 to USER_MAX_NODE_COUNT - 2 do   // no space for physical node
    NceBridge.AssignedCabs[i] := nil;
  NceBridge.iActiveCab := 0;
  ProxyNode.ID[0] := 0;
  ProxyNode.ID[1] := 0;
  ProxyNode.AliasID := 0;
  GlobalTimer := 0;
end;

// *****************************************************************************
// Called from Dynamically set Interrupt timer after 1800us
// *****************************************************************************
procedure CabBus_Timeout;
begin
  // The Ping timed out without a reply from the Cab move to the next state (depends of which wait state we are in)
  DisableCabBusTimer;
  case NceBridge.iStateMachine of
    STATE_WAIT_SYNC_DELAY   : NceBridge.iStateMachine := STATE_SEND_PING;
    STATE_WAIT_FOR_RESPONSE : NceBridge.iStateMachine := STATE_TIMEOUT;
  end;
end;

// *****************************************************************************
// Called from the UART RX Interrupt
// The Pin Change Interrupt stopped the Timeout Timer so we are free to handle
// the UART RX at our leasure
// *****************************************************************************
procedure UART_RX_StateMachine;

begin
  while (URXDA_U2STA_bit = 1) do
  begin
    NceBridge.IncomingBuffer[NceBridge.iIncomingCount] := U2RXREG;
    Inc(NceBridge.iIncomingCount);
    if NceBridge.iIncomingCount = 2 then
    begin
   //   WordToStr(NceBridge.IncomingBuffer[0], s1);
  //    UART1_Write_Text(s1 + ', ');
  //    WordToStr(NceBridge.IncomingBuffer[1], s1);
  //    UART1_Write_Text(s1 + #13);
      NceBridge.iStateMachine := STATE_CAB_REPLIED;                    // Received both Bytes process them
    end else
    begin
      if NceBridge.iIncomingCount > 2 then
        NceBridge.iStateMachine := STATE_TIMEOUT;                    // Something is wrong
    end
  end;
end;

// *****************************************************************************
// *****************************************************************************
function AssignCabToBus(CabID: Word): PNMRAnetNode;
var
  LastAccessedNode: PNMRAnetNode;
  OldestAccessCount: Word;
  Cab: PNceCab;
  i: Integer;
begin
  LastAccessedNode := nil;
  Result := nil;
  Cab := nil;
  
  // Look for it in the Allocated Cab list
  i := 0;
  while i < NceBridge.iAssignedCabCount do
  begin
    Result := NceBridge.AssignedCabs[i];
    Cab := PNceCab( Result^.UserData);
    if Cab^.ID = CabID then
    begin
      Cab^.MissedPingCount := 0;
      Exit;
    end;
    Inc(i);
  end;

  // Did not find it in the list of Allocated Cabs so find a new node to use
  i := 1;
  while i < NodePool.AllocatedCount do
  begin
    Cab := PNceCab( NodePool.AllocatedList[i]^.UserData);
    
    // Find the node with the longest time when last accessed
    if Cab^.MissedPingCount < OldestAccessCount then
    begin
      OldestAccessCount := Cab^.MissedPingCount;
      LastAccessedNode := NodePool.AllocatedList[i];
    end;

    if Cab^.State and CS_DEVICE_INACTIVE <> 0 then
    begin
      Cab^.State := Cab^.State or CS_DEVICE_ACTIVE and not CS_DEVICE_INACTIVE;
      Cab^.ID := CabID;
      Cab^.MissedPingCount := 0;
      Result := NodePool.AllocatedList[i];
      NceBridge.AssignedCabs[NceBridge.iAssignedCabCount] := Result;
      Inc(NceBridge.iAssignedCabCount);
      Exit;
    end;
    Inc(i);
  end;
  
  // Did not find an allocated unassigned Node, create a new node
  Result := CreateCabNode(CabID);
  if Result <> nil then
  begin
    Cab := PNceCab( Result^.UserData);
    Cab^.MissedPingCount := 0;
    NceBridge.AssignedCabs[NceBridge.iAssignedCabCount] := Result;
    Inc(NceBridge.iAssignedCabCount);
    Exit;
  end;
  
  // Could not create a new node so use the one that was used last (it is already allocated and we are highjacking it
  if LastAccessedNode <> nil then
  begin
    Result := LastAccessedNode;
    Cab := PNceCab( Result^.UserData);
    Cab^.ID := CabID;
  end;
end;

// *****************************************************************************
// *****************************************************************************
procedure PinChangeInterrupt;
begin
  CNIE_bit := 0;                                                                // Pin Change Interrupt disabled
  DisableCabBusTimer;
end;

// *****************************************************************************
// *****************************************************************************
function HandleCabBusReply(Node: PNMRAnetNode): Boolean;
var
  CabData: PNceCab;
  i: Integer;
begin
  Result := False;
  if Node <> nil then
  begin
    CabData := PNceCab( Node^.UserData);
    if not CabData^.IncomingMsg.Full then
    begin
      for i := 0 to NceBridge.iIncomingCount - 1 do
      begin
        case NceBridge.IncomingBuffer[i] of
          NCE_NO_KEY_TO_REPORT : begin end;
          NCE_NO_SPEED_TO_REPORT : begin end;
          NCE_CAB_SELECT_MACRO :
              begin
                WriteByte(NCE_CMD_CURSOR_ON, True);
                CabData^.State := CabData^.State or CS_MACRO_MESSAGE;
                CabData^.IncomingMsg.Count := 0;
                CabData^.IncomingMsg.Full := False;
              end;
          NCE_CAB_SELECT_LOCO :
              begin
                WriteByte(NCE_CMD_CURSOR_ON, True);
                CabData^.State := CabData^.State or CS_LOCO_SELECT;
                CabData^.IncomingMsg.Count := 0;
                CabData^.IncomingMsg.Full := False;
              end;
          NCE_CAB_ENTER :
              begin
                if CabData^.State and (CS_MACRO_MESSAGE or CS_LOCO_SELECT) <> 0 then
                begin
                  WriteByte(NCE_CMD_CURSOR_OFF, True);
                  CabData^.IncomingMsg.Full := True;
                end;
              end
          else begin
              if CabData^.IncomingMsg.Count < NCEBUS_MAX_DATA_BYTE then
              begin
                CabData^.IncomingMsg.DataBytes[CabData^.IncomingMsg.Count] := NceBridge.IncomingBuffer[i];
                Inc(CabData^.IncomingMsg.Count);
                if CabData^.State and (CS_MACRO_MESSAGE or CS_LOCO_SELECT) = 0 then
                  CabData^.IncomingMsg.Full := True;
              end;
            end;
          end; {case}
      end; {if}
    end;
    Result := CabData^.IncomingMsg.Full
  end;
end;

// *****************************************************************************
// *****************************************************************************
function DispatchMessage(Node: PNMRAnetNode): Boolean;
var
 Cab: PNceCab;
begin
  Result := False;
  if Node <> nil then
  begin
    Cab := PNceCab( Node^.UserData);
    
    Cab^.IncomingMsg.Full := False;

    if Cab^.State and CS_LOCO_SELECT <> 0 then
    begin

    end else
    if Cab^.State and CS_MACRO_MESSAGE <> 0 then
    begin

    end else
    begin


    end;
  end;
  
  Result := True;
  Exit;
end;

// *****************************************************************************
// *****************************************************************************
procedure DiscoverDevices_Process(Node: PNMRAnetNode);
var
  Cab: PNceCab;
begin
  case NceBridge.iStateMachine of
    STATE_INITIALIZE :
        begin
          {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_DISCOVER_INITIALIZE'+LF); {$ENDIF}
          NceBridge.iDiscoveryCabID := ID_MIN_DEVICE;
          NceBridge.iStateMachine := STATE_SEND_SYNC;
        end;
    STATE_SEND_SYNC :
        begin
          {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_DISCOVER_SEND_SYNC..............'+LF); {$ENDIF}
          FlushUartReceiver;
          WriteByte(NCEBUS_PING or 0, True);                                    // Special Ping with a CabID of 0 to Sync the stream
          EnableCabBusTimer(28800);          // 31.25ns * 28800 = 900us      Needs some delay, the cabs are slow microprocessors                                      //
          NceBridge.iStateMachine := STATE_WAIT_SYNC_DELAY;
        end;
    STATE_WAIT_SYNC_DELAY :
        begin  // Waiting for the Timer to Expire and jump us to the next state
          {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_DISCOVER_WAIT_SYNC_DELAY'+LF); {$ENDIF}
        end;
    STATE_SEND_PING :
        begin  // The node replied and
          {$IFDEF DEBUG_DISCOVER_STATEMACHINE} IntToStr(NceBridge.iDiscoveryCabID, s1); UART1_Write_Text('STATE_DISCOVER_SEND_PING: ' + s1+LF); {$ENDIF}
          FlushUartReceiver;
          NceBridge.iIncomingCount := 0;
          NceBridge.LastPortRead := PortB;
          CNIE_bit := 1;                                                        // Pin Change Interrupt enable
          WriteByte(NCEBUS_PING or NceBridge.iDiscoveryCabID, True);            // Ping the Cab ID
          EnableCabBusTimer(57600);          // 31.25ns * 57600 = 1800us
          NceBridge.iStateMachine := STATE_WAIT_FOR_RESPONSE;
        end;
    STATE_WAIT_FOR_RESPONSE :
        begin   // Waiting for the Timer to expire or we detect a reply....
          // See CabBus_Timeout function for the Timeout or CabBus_UART_RX_StateMachine for a reply and what the next state is
          {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_DISCOVER_WAIT_FOR_RESPONSE'+LF); {$ENDIF}
        end;
    STATE_TIMEOUT :
        begin
          {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_DISCOVER_TIMEOUT'+LF); {$ENDIF}
          Cab := PNceCab( Node^.UserData);
          if (Cab^.MissedPingCount < $FFFF) and (Cab^.State and CS_DEVICE_ACTIVE <> 0) then
            Inc( Cab^.MissedPingCount);
          NceBridge.iStateMachine := STATE_NEXT_CAB
        end;
    STATE_CAB_REPLIED :
        begin
          {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_DISCOVER_CAB_REPLIED'+LF); {$ENDIF}
          if HandleCabBusReply(AssignCabToBus(NceBridge.iDiscoveryCabID)) then
            NceBridge.iStateMachine := STATE_DISPATCH_MESSAGE
          else
            NceBridge.iStateMachine := STATE_NEXT_CAB
        end;
    STATE_DISPATCH_MESSAGE :
        begin 
          {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_DISPATCH_MESSAGE'+LF); {$ENDIF}
          if DispatchMessage(NceBridge.AssignedCabs[NceBridge.iActiveCab]) then
            NceBridge.iStateMachine := STATE_NEXT_CAB
        end;
    STATE_NEXT_CAB :
        begin
          {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_DISCOVER_NEXT_CAB'+LF); {$ENDIF}
          Inc(NceBridge.iDiscoveryCabID);
          if NceBridge.iDiscoveryCabID > ID_MAX_DEVICE then
          begin
            NceBridge.Discovering := False;
            NceBridge.DiscoverTimer := 0;
            NceBridge.iStateMachine := STATE_INITIALIZE;                        // Get ready for the next Discovery Mode
            Node^.iUserStateMachine := STATE_KNOWNDEVICES;                      // Go back to pinging only known Cabs
          end else
            NceBridge.iStateMachine := STATE_SEND_PING;
        end;
  end;
end;

// *****************************************************************************
// *****************************************************************************
procedure KnownDevices_Process(Node: PNMRAnetNode);
var
  CabNode: PNMRAnetNode;
begin
  // Run the Known Devices only
  case NceBridge.iStateMachine of
    STATE_INITIALIZE :
        begin
          if NceBridge.iAssignedCabCount = 0 then
          begin  // Nothing to do jump back to Discover, when ready
            if NceBridge.DiscoverTimer >= REDISCOVERY_TIME then
            begin
              Node^.iUserStateMachine := STATE_DISCOVERDEVICES;
              NceBridge.iStateMachine := STATE_INITIALIZE;
            end;
          end else
          begin
           {$IFDEF DEBUG_KNOWNDEVICES_STATEMACHINE} UART1_Write_Text('STATE_INITIALIZE'+LF); {$ENDIF}
           NceBridge.iStateMachine := STATE_SEND_SYNC;
          end;
        end;
    STATE_SEND_SYNC :
        begin
          LATB4_bit := 1;
        
          {$IFDEF DEBUG_KNOWNDEVICES_STATEMACHINE} UART1_Write_Text('STATE_SEND_SYNC..............'+LF); {$ENDIF}
          FlushUartReceiver;
          WriteByte(NCEBUS_PING or 0, True);                                    // Special Ping with a CabID of 0 to Sync the stream
          EnableCabBusTimer(28800);          // 31.25ns * 28800 = 900us      Needs some delay, the cabs are slow microprocessors                                      //
          NceBridge.iStateMachine := STATE_WAIT_SYNC_DELAY;
          
          LATB4_bit := 0;
          
        end;
    STATE_WAIT_SYNC_DELAY :
        begin  // Waiting for the Timer to Expire and jump us to the next state
          {$IFDEF DEBUG_KNOWNDEVICES_STATEMACHINE} UART1_Write_Text('STATE_WAIT_SYNC_DELAY'+LF); {$ENDIF}
        end;
    STATE_SEND_PING :
        begin  // The node replied and
          {$IFDEF DEBUG_KNOWNDEVICES_STATEMACHINE} UART1_Write_Text('STATE_SEND_PING: ' + s1+LF); {$ENDIF}
          FlushUartReceiver;
          NceBridge.iIncomingCount := 0;
          NceBridge.LastPortRead := PortB;
          CNIE_bit := 1;                                                        // Pin Change Interrupt enable
          WriteByte(NCEBUS_PING or PNceCab( NceBridge.AssignedCabs[NceBridge.iActiveCab]^.UserData)^.ID, True);            // Ping the Cab ID
          EnableCabBusTimer(57600);          // 31.25ns * 57600 = 1800us
          NceBridge.iStateMachine := STATE_WAIT_FOR_RESPONSE;
        end;
    STATE_WAIT_FOR_RESPONSE :
        begin   // Waiting for the Timer to expire or we detect a reply....
          // See CabBus_Timeout function for the Timeout or CabBus_UART_RX_StateMachine for a reply and what the next state is
          {$IFDEF DEBUG_KNOWNDEVICES_STATEMACHINE} UART1_Write_Text('STATE_WAIT_FOR_RESPONSE'+LF); {$ENDIF}
        end;
    STATE_TIMEOUT :
        begin
          {$IFDEF DEBUG_KNOWNDEVICES_STATEMACHINE} UART1_Write_Text('STATE_TIMEOUT'+LF); {$ENDIF}
          // This should only happen if the throttle was unplugged
          NceBridge.iStateMachine := STATE_NEXT_CAB
        end;
    STATE_CAB_REPLIED :
        begin
          {$IFDEF DEBUG_KNOWNDEVICES_STATEMACHINE} UART1_Write_Text('STATE_CAB_REPLIED'+LF); {$ENDIF}
          if HandleCabBusReply(NceBridge.AssignedCabs[NceBridge.iActiveCab]) then
            NceBridge.iStateMachine := STATE_DISPATCH_MESSAGE
          else
            NceBridge.iStateMachine := STATE_NEXT_CAB
        end;
    STATE_DISPATCH_MESSAGE :
        begin
          {$IFDEF DEBUG_DISCOVER_STATEMACHINE} UART1_Write_Text('STATE_DISPATCH_MESSAGE'+LF); {$ENDIF}
          if DispatchMessage(NceBridge.AssignedCabs[NceBridge.iActiveCab]) then
            NceBridge.iStateMachine := STATE_NEXT_CAB
        end;
    STATE_NEXT_CAB :
        begin
          {$IFDEF DEBUG_KNOWNDEVICES_STATEMACHINE} UART1_Write_Text('STATE_NEXT_CAB'+LF); {$ENDIF}
          Inc(NceBridge.iActiveCab);
          if NceBridge.iActiveCab >= NceBridge.iAssignedCabCount then
          begin
            // Only test and change this after a complete cab interaction has ended
            if NceBridge.DiscoverTimer >= REDISCOVERY_TIME then
              Node^.iUserStateMachine := STATE_DISCOVERDEVICES;
            NceBridge.iStateMachine := STATE_INITIALIZE;
            NceBridge.iActiveCab := 0;
          end else
          begin
            NceBridge.iStateMachine := STATE_SEND_PING;
          end
        end;
  end;
end;

// *****************************************************************************
//  procedure AppCallback_UserStateMachine_Process
//     Parameters: : None
//     Returns     : None
//     Description : Called as often as possible to run the user statemachine
// *****************************************************************************
procedure AppCallback_UserStateMachine_Process(Node: PNMRAnetNode);
var
  TempNode: PNMRAnetNode;
  i, j: Integer;
begin 
   if Node = GetPhysicalNode then
  begin
    case Node^.iUserStateMachine of
      STATE_USER_START :  // Create the minimum number of Pings to put on the NCE bus to make it happy
          begin
            if Node^.State and NS_PERMITTED <> 0 then
            begin
              GlobalTimer := 0;
              if TrySendIdentifyProducer(Node^.Info, @EVENT_IS_PROXY) then
                Node^.iUserStateMachine := STATE_FIND_PROXY;
            end
          end;
      STATE_FIND_PROXY :   // Find the Proxy node (Command Station) on the network before progressing
          begin
            if (ProxyNode.AliasID > 0) or (ProxyNode.ID[0] > 0) or (ProxyNode.ID[1] > 0) then
              Node^.iUserStateMachine := STATE_CREATE_REQUIRED_CABS
            else begin
              if GlobalTimer > 10 then
                Node^.iUserStateMachine := STATE_USER_START                     // Try again
            end;
          end;
      STATE_CREATE_REQUIRED_CABS :
          begin
            for i := ID_MIN_DEVICE to ID_MIN_DEVICE + NCE_CAB_BUS_PADDING - 1 do
              AssignCabToBus(i);
        //      CreateCabNode;                                                        // Create the Nodes but don't activate the Cabs
            Node^.iUserStateMachine := STATE_DISCOVERDEVICES;
          end;
      STATE_DISCOVERDEVICES : DiscoverDevices_Process(Node);
      STATE_KNOWNDEVICES    : KnownDevices_Process(Node);
    end;
  end else
  begin
    // Cab Nodes
    case Node^.iUserStateMachine of
      STATE_USER_START :
          begin
            if Node^.State and NS_PERMITTED <> 0 then
            begin
       //       case PNceCab( Node^.UserData)^.IncomingMsg.iRxStateMachine of

      //        end;
            end;
          end;
    end;
  end;

    {
  if Node = GetPhysicalNode then
  begin
    case Node^.iUserStateMachine of
        STATE_USER_START :
            begin              // Find a Proxy
              if Node^.State and NS_INITIALIZED <> 0 then
               begin
                 GlobalTimer := 0;
                 if TrySendIdentifyProducer(Node^.Info, @EVENT_IS_PROXY) then
                   Node^.iUserStateMachine := STATE_USER_1;
               end;
            end;
        STATE_USER_1 :
            begin
              // Find the Proxy node (Command Station) on the network before progressing
              if (ProxyNode.AliasID > 0) or (ProxyNode.ID[0] > 0) or (ProxyNode.ID[1] > 0) then
                Node^.iUserStateMachine := STATE_USER_2
              else begin
                if GlobalTimer > 10 then
                  Node^.iUserStateMachine := STATE_USER_START            // Try again
              end;
            end;
        STATE_USER_2 :
            begin
              // Now the Physical node can be a Throttle Node Server
              EnterCriticalSection(OPStackCriticalSection);
              // Only do something if the number of links has changed
              if Sync.DatabaseChanged then
              begin
                for i := 0 to Sync.NextLink - 1 do     // Look only at active Link Objects
                begin
                  if Sync.Link[i].SyncState <> SYNC_NONE then
                  begin
                    if Sync.Link[i].SyncState and SYNC_THROTTLE_OBJPTR <> 0 then
                    begin
                      if Sync.Link[i].Node.Info.AliasID = 0 then
                      begin // Logging in
                        Sync.Link[i].SyncState := Sync.Link[i].SyncState and not SYNC_THROTTLE_OBJPTR;
                        TempNode := OPStackNode_Allocate;
                        Sync.Link[i].Node.Index := TempNode^.iIndex;
                        // Now need to wait for it to log in
                      end else
                      begin // Logging out
                        if Sync.Link[i].Node.Index > 0 then   // Don't deallocate the physical node if we messed up!
                        begin
                          Sync.Link[i].SyncState := Sync.Link[i].SyncState and not SYNC_THROTTLE_OBJPTR;
                          OPStackNode_MarkForRelease(@NodePool.Pool[Sync.Link[i].Node.Index]);
                          for j := i to (Sync.NextLink - 1) do
                            Sync.Link[j] := Sync.Link[j+1];
                          Dec(Sync.NextLink);
                          ZeroLinkRec(@Sync.Link[Sync.NextLink]);
                        end;
                      end
                    end;
                  end;
                end;
                Sync.DatabaseChanged := False;
              end;
              LeaveCriticalSection(OPStackCriticalSection);
            end
    end;
  end else
  begin
    // Throttle Node (Virtual Node)
    case Node^.iUserStateMachine of
        STATE_USER_START :
            begin
              EnterCriticalSection(OPStackCriticalSection);
              // Don't do anything until it is initialized
              if Node^.State and NS_PERMITTED <> 0 then
              begin
                Link := FindLinkByPoolIndex(Node^.iIndex);     // iIndex 0 is physcial node
                Link^.SyncState := SYNC_NODE_INFO;
                Link^.Node.Info := Node^.Info;
                Node^.iUserStateMachine := STATE_USER_1;
              end;
              LeaveCriticalSection(OPStackCriticalSection);
              Exit;
            end;
        STATE_USER_1 :    // Send message to Reserve the PROXY
            begin
              EnterCriticalSection(OPStackCriticalSection);
              Link := FindLinkByNodeAlias(Node);
              if Link <> nil then                     // May not be found if the node is being freed
              begin
                if Link^.SyncState <> SYNC_NONE then
                begin
                  if Link^.SyncState and (SYNC_STATE_ADDRESS or SYNC_SPEED_STEPS) = (SYNC_STATE_ADDRESS or SYNC_SPEED_STEPS) then
                  begin
                    // This means the throttle want to create a new train node
                    if TrySendTractionProxyManage(Node^.Info, ProxyNode, True) then
                    begin
                      Link^.SyncState := Link^.SyncState and not (SYNC_STATE_ADDRESS or SYNC_SPEED_STEPS);
                      Node^.iUserStateMachine := STATE_USER_10;                 // Wait for the Reserve callback
                    end;
                  end;
                end;
                LeaveCriticalSection(OPStackCriticalSection);
              end;
              Exit;
            end;
        STATE_USER_2 :  // Proxy is Reserved, allocate the Train Node
            begin
              EnterCriticalSection(OPStackCriticalSection);
              Link := FindLinkByNodeAlias(Node);
              if Link <> nil then
              begin
                if TrySendTractionProxyAllocate(Node^.Info, ProxyNode, TRACTION_PROXY_TECH_ID_DCC, Link^.ThrottleState.Address, Link^.ThrottleState.SpeedSteps, 0) then
                  Node^.iUserStateMachine := STATE_USER_10;  // Wait for the Allocate Callback
              end;
              LeaveCriticalSection(OPStackCriticalSection);
              Exit;
            end;
        STATE_USER_3  :     // Train has been created, Lock the Train
            begin
              EnterCriticalSection(OPStackCriticalSection);
              Link := FindLinkByNodeAlias(Node);
              if Link <> nil then
              begin
                if TrySendTractionManage(Node^.Info, Link^.AllocatedNode, True) then
                  Node^.iUserStateMachine := STATE_USER_10;  // Wait for the Throttle allocate callback
              end;
              LeaveCriticalSection(OPStackCriticalSection);
              Exit;
            end;
        STATE_USER_4  :   //  Assign the Throttle to the Train
            begin
              EnterCriticalSection(OPStackCriticalSection);
              Link := FindLinkByNodeAlias(Node);
              if Link <> nil then
              begin
                if TrySendTractionControllerConfig(Node^.Info, Link^.AllocatedNode, Node^.Info, True) then
                  Node^.iUserStateMachine := STATE_USER_10;  // Wait for the Throttle allocate callback
              end;
              LeaveCriticalSection(OPStackCriticalSection);
              Exit;
            end;
        STATE_USER_5  :   // Throttle assigned, unlock it
            begin
              EnterCriticalSection(OPStackCriticalSection);
              Link := FindLinkByNodeAlias(Node);
              if Link <> nil then
              begin
                if TrySendTractionManage(Node^.Info, Link^.AllocatedNode, False) then
                  Node^.iUserStateMachine := STATE_USER_6;  // No callback, just start looping
              end;
              LeaveCriticalSection(OPStackCriticalSection);
              Exit;
            end;
        STATE_USER_6  :
            begin
              // Running with Train
              EnterCriticalSection(OPStackCriticalSection);
              Link := FindLinkByNodeAlias(Node);
              if Link <> nil then
              begin
                if Link^.SyncState and SYNC_CLOSING <> 0 then
                begin
                  if TrySendTractionManage(Node^.Info, Link^.AllocatedNode, True) then
                    Node^.iUserStateMachine := STATE_USER_10;  // Wait for the Throttle allocate callback
                end;
              end;
              LeaveCriticalSection(OPStackCriticalSection);
              Exit;
            end;
        STATE_USER_7  :
            begin
              EnterCriticalSection(OPStackCriticalSection);
              Link := FindLinkByNodeAlias(Node);
              if Link <> nil then
              begin
                if TrySendTractionControllerConfig(Node^.Info, Link^.AllocatedNode, Node^.Info, False) then
                begin
                  Link^.AllocatedNode.AliasID := 0;
                  Link^.AllocatedNode.ID[0] := 0;
                  Link^.AllocatedNode.ID[1] := 0;
                  Link^.TrainAllocated := False;
                  Node^.iUserStateMachine := STATE_USER_8;  // There is no reply for deall
                end
              end;
              LeaveCriticalSection(OPStackCriticalSection);
              Exit;
            end;
        STATE_USER_8  :
            begin
              EnterCriticalSection(OPStackCriticalSection);
              Link := FindLinkByNodeAlias(Node);
              if Link <> nil then
              begin
                if TrySendTractionManage(Node^.Info, Link^.AllocatedNode, False) then
                begin
                  Link^.SyncState := Link^.SyncState and not SYNC_CLOSING or SYNC_CLOSED;
                  Node^.iUserStateMachine := STATE_USER_9;  // No callback, just start looping
                end
              end;
              LeaveCriticalSection(OPStackCriticalSection);
              Exit;
            end;
        STATE_USER_9   :
            begin
              Exit;
            end;
        STATE_USER_10  :
            begin
                // Wait for a callback to be called, this can be for many things
              Exit;
            end
    end
  end     }
end;

// *****************************************************************************
//  procedure AppCallback_NodeInitialize
//     Parameters: : Node : Pointer to the node that needs to be initilized to its intial value
//     Returns     : None
//     Description : Typically called when a node is being intialized to be
//                   logged into the network.  It is possible the node can be
//                   discarded then reused so it may be called more than once for
//                   virtual nodes
// *****************************************************************************
procedure AppCallback_NodeInitialize(Node: PNMRAnetNode);
begin
  // Assign the user data record to the Node for future use
  Node^.UserData := @NceCabArray[Node^.iIndex];
  Node^.iUserStateMachine := STATE_USER_START;

  // Initialize the example data, evertime the node is reused!
  ZeroizeNceCabData(ExtractNceCab(Node))
end;

{$IFDEF SUPPORT_TRACTION}
// *****************************************************************************
//  procedure AppCallback_TractionControlReply
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   Dest   : Full Node ID (and Alias if on CAN) of the dest node for the message
//                   DataBytes: pointer to the raw data bytes
//     Returns     : None
//     Description : Called when a Traction Protocol request comes in
// *****************************************************************************
procedure AppCallback_TractionProtocol(Node: PNMRAnetNode; AMessage: POPStackMessage);
var
 //Link: PLinkRec;
 MultiFrameBuffer: PMultiFrameBuffer;
begin
 // EnterCriticalsection(OPStackCriticalSection);
  //Link := FindLinkByNodeAlias(Node);
  //if Link <> nil then
  begin
    MultiFrameBuffer := PMultiFrameBuffer( PByte( AMessage^.Buffer));
    case MultiFrameBuffer^.DataArray[0] of
      TRACTION_CONTROLLER_CONFIG :
          begin
            case MultiFrameBuffer^.DataArray[1] of
              TRACTION_CONTROLLER_CONFIG_NOTIFY :
                  begin
  //                  Link^.TrainAllocated := False;
  //                  Link^.SyncState := Link^.SyncState or SYNC_CONTROLLER;
  //                  Link^.AllocatedNode.AliasID := 0;
  //                  Link^.AllocatedNode.ID[0] := 0;
  //                  Link^.AllocatedNode.ID[1] := 0;
               //     Node^.iUserStateMachine := STATE_USER_1;   // Reset statemachine to log in
                  end;
            end;
          end;
    end;
  end;
 // LeaveCriticalsection(OPStackCriticalSection);
end;

// *****************************************************************************
//  procedure AppCallback_TractionProtocolReply
//     Parameters: : Node           : Pointer to the node that the traction protocol has been called on
//                   ReplyMessage   : The Reply Message that needs to be allocated, populated and returned so it can be sent
//                   RequestingMessage    : Message that was sent to the node containing the requested information
//     Returns     : True if the RequestingMessage is handled and the ReplyMessage is ready to send
//                   False if the request has not been completed due to no available buffers or waiting on other information
//     Description : Called in response to a Traction Protcool request
// *****************************************************************************
procedure AppCallback_TractionProtocolReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
var
// Link: PLinkRec;
 MultiFrameBuffer: PMultiFrameBuffer;
begin
 // EnterCriticalsection(OPStackCriticalSection);
 // Link := FindLinkByNodeAlias(Node);
 // if Link <> nil then
  begin
    MultiFrameBuffer := PMultiFrameBuffer( PByte( AMessage^.Buffer));
    case MultiFrameBuffer^.DataArray[0] of
      TRACTION_CONTROLLER_CONFIG :
          begin
            case MultiFrameBuffer^.DataArray[1] of
              TRACTION_CONTROLLER_CONFIG_ASSIGN :
                  begin
                    if MultiFrameBuffer^.DataArray[2] = TRACTION_CONTROLLER_ASSIGN_REPLY_OK then
            //        begin
 //                     Link^.TrainAllocated := True;
  //                    Link^.SyncState := Link^.SyncState or SYNC_CONTROLLER;
            //          Node^.iUserStateMachine := STATE_USER_5
             //       end else
             //         Node^.iUserStateMachine := STATE_USER_5 // Release the Train, error try again??????
                  end;
            end;
          end;
      TRACTION_CONSIST :
          begin
            case MultiFrameBuffer^.DataArray[1] of
              TRACTION_CONSIST_ATTACH :
                  begin
                  end;
              TRACTION_CONSIST_DETACH :
                  begin
                  end;
              TRACTION_CONSIST_QUERY :
                  begin
                  end;
            end // case
          end;
      TRACTION_MANAGE :
          begin
            case MultiFrameBuffer^.DataArray[1] of
              TRACTION_MANAGE_RESERVE :
                  begin
 //                   if Link^.SyncState and SYNC_CLOSING <> 0 then       // Run the closing statemachine
                    begin
            //          if MultiFrameBuffer^.DataArray[2] = TRACTION_MANAGE_RESERVE_REPLY_OK then
           //            Node^.iUserStateMachine := STATE_USER_7
            //          else
             //           Node^.iUserStateMachine := STATE_USER_6  // Keep trying to lock it for now
                    end //else
  //                  begin
  //                    if MultiFrameBuffer^.DataArray[2] = TRACTION_MANAGE_RESERVE_REPLY_OK then
  //                      Node^.iUserStateMachine := STATE_USER_4
  //                    else
   //                     Node^.iUserStateMachine := STATE_USER_3 // Keep trying to lock it for now
  //                  end
                  end;
            end
          end;
      end;
  end;
 // LeaveCriticalsection(OPStackCriticalSection);
end;
{$ENDIF}

{$IFDEF SUPPORT_TRACTION_PROXY}
// *****************************************************************************
//  procedure AppCallback_TractionProtocol
//     Parameters: : Node           : Pointer to the node that the traction protocol has been called on
//                   ReplyMessage   : The Reply Message that needs to be allocated, populated and returned so it can be sent
//                   RequestingMessage    : Message that was sent to the node containing the requested information
//     Returns     : True if the RequestingMessage is handled and the ReplyMessage is ready to send
//                   False if the request has not been completed due to no available buffers or waiting on other information
//     Description : Called when a Traction Protocol message is received
// *****************************************************************************
function AppCallback_TractionProxyProtocol(Node: PNMRAnetNode; AMessage: POPStackMessage; SourceHasLock: Boolean): Boolean;
begin

end;

// *****************************************************************************
//  procedure AppCallback_TractionProxyProtocolReply
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   Dest   : Full Node ID (and Alias if on CAN) of the dest node for the message
//                   DataBytes: pointer to the raw data bytes
//     Returns     : None
//     Description : Called in response to a Traction Proxy request
// *****************************************************************************
procedure AppCallback_TractionProxyProtocolReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
var
 // Link: PLinkRec;
  MultiFrameBuffer: PMultiFrameBuffer;
begin
 // EnterCriticalsection(OPStackCriticalSection);
 // Link := FindLinkByNodeAlias(Node);
 // if Link <> nil then
  begin
    case AMessage^.Buffer^.DataArray[0] of
      TRACTION_PROXY_MANAGE :
          begin
            if AMessage^.Buffer^.DataArray[1] = TRACTION_PROXY_MANAGE_RESERVE then
            begin
               if AMessage^.Buffer^.DataArray[2] = 0 then
                 Node^.iUserStateMachine := STATE_USER_2         // Move to next state after reserving
               else
                 Node^.iUserStateMachine := STATE_USER_1         // Can't reserve now go back to normal polling
            end;
          end;
      TRACTION_PROXY_ALLOCATE :
          begin
            MultiFrameBuffer := PMultiFrameBuffer( PByte(AMessage^.Buffer));
  //          Link^.AllocatedNode.AliasID := (MultiFrameBuffer^.DataArray[11] shl 8) or (MultiFrameBuffer^.DataArray[12]);
            NMRAnetUtilities_Load48BitNodeIDWithSimpleData(Link^.AllocatedNode.ID, PSimpleDataArray( PByte( @MultiFrameBuffer^.DataArray[5]))^);
            Node^.iUserStateMachine := STATE_USER_3;    // Now need to allocate the Throttle to the Train Node
          end
    end; // case
  end;
 // LeaveCriticalsection(OPStackCriticalSection);
end;
{$ENDIF}

// *****************************************************************************
//  procedure AppCallBack_ProtocolSupportReply
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   Dest   : Full Node ID (and Alias if on CAN) of the dest node for the message
//                   DataBytes: pointer Raw data bytes, Byte 0 and 1 are the Alias
//     Returns     : None
//     Description : Called in response to a Protocol Support Request
// *****************************************************************************
procedure AppCallBack_ProtocolSupportReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
begin

end;

// *****************************************************************************
//  procedure AppCallback_ConsumerIdentified
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   Dest   : Full Node ID (and Alias if on CAN) of the dest node for the message
//                   MTI    : MTI of the message
//                   EventID: pointer to the Event ID for the message
//     Returns     : None
//     Description : This is called directly from the Hardware receive buffer.  Do
//                   not do anything here that stalls the call.  This is called
//                   Asyncronously from the Statemachine loop and the Statemachine loop
//                   is stalled until this returns.  Set a flag and move on is the
//                   best stratagy or store info in a buffer and process in the
//                   main statemachine.
// *****************************************************************************
procedure AppCallback_ConsumerIdentified(var Source: TNodeInfo; MTI: Word; EventID: PEventID);
begin

end;

// *****************************************************************************
//  procedure AppCallback_ProducerIdentified
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   Dest   : Full Node ID (and Alias if on CAN) of the dest node for the message
//                   MTI    : MTI of the message
//                   EventID: pointer to the Event ID for the message
//     Returns     : None
//     Description : This is called directly from the Hardware receive buffer.  Do
//                   not do anything here that stalls the call.  This is called
//                   Asyncronously from the Statemachine loop and the Statemachine loop
//                   is stalled until this returns.  Set a flag and move on is the
//                   best stratagy or store info in a buffer and process in the
//                   main statemachine.
// *****************************************************************************
procedure AppCallback_ProducerIdentified(var Source: TNodeInfo; MTI: Word; EventID: PEventID);
begin
  if NMRAnetUtilities_EqualEventID(EventID, @EVENT_IS_PROXY) then
    ProxyNode := Source;
end;

// *****************************************************************************
//  procedure AppCallback_LearnEvent
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   EventID: pointer to the Event ID for the message
//     Returns     : None
//     Description : This is called directly from the Hardware receive buffer.  Do
//                   not do anything here that stalls the call.  This is called
//                   Asyncronously from the Statemachine loop and the Statemachine loop
//                   is stalled until this returns.  Set a flag and move on is the
//                   best stratagy or store info in a buffer and process in the
//                   main statemachine.
// *****************************************************************************
procedure AppCallback_LearnEvent(var Source: TNodeInfo; EventID: PEventID);
begin

end;

// *****************************************************************************
//  procedure AppCallBack_PCEventReport
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   EventID: pointer to the Event ID for the message
//     Returns     : None
//     Description : This is called directly from the Hardware receive buffer.  Do
//                   not do anything here that stalls the call.  This is called
//                   Asyncronously from the Statemachine loop and the Statemachine loop
//                   is stalled until this returns.  Set a flag and move on is the
//                   best stratagy or store info in a buffer and process in the
//                   main statemachine.
// *****************************************************************************
procedure AppCallBack_PCEventReport(var Source: TNodeInfo; EventID: PEventID);
begin

end;

// *****************************************************************************
//  procedure AppCallback_RemoteButtonReply
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   Dest   : Full Node ID (and Alias if on CAN) of the dest node for the message
//                   DataBytes: pointer to the raw data bytes
//     Returns     : None
//     Description : Called in response to a Remote Button request
// *****************************************************************************
procedure AppCallback_RemoteButtonReply(Dest: PNMRAnetNode; var Source: TNodeInfo; DataBytes: PSimpleBuffer);
begin

end;

{$IFDEF SUPPORT_TRACTION}
// *****************************************************************************
//  procedure AppCallback_SimpleTrainNodeInfoReply
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   Dest   : Full Node ID (and Alias if on CAN) of the dest node for the message
//                   TrainNodeInfo: pointer to the null terminated strings
//     Returns     : None
//     Description : Called in response to a STNIP request
// *****************************************************************************
procedure AppCallback_SimpleTrainNodeInfoReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
begin

end;
{$ENDIF}

// *****************************************************************************
//  procedure AppCallback_Timer_100ms
//     Parameters: : None
//     Returns     : None
//     Description : Typcally called from another thread or interrupt, only use
//                   to update asyncronous flags
// *****************************************************************************
procedure AppCallback_Timer_100ms;
begin
  Inc(GlobalTimer);
  
   // Count up to the time out then freeze.  The Timer Count will be reset after the
  // main loop is done rediscovering
  if NceBridge.DiscoverTimer < REDISCOVERY_TIME then
    Inc(NceBridge.DiscoverTimer);

end;

// *****************************************************************************
//  procedure AppCallback_SimpleNodeInfoReply
//     Parameters: : Source   : Full Node ID (and Alias if on CAN) of the source node for the message
//                   Dest     : Full Node ID (and Alias if on CAN) of the dest node for the message
//                   NodeInfo : pointer to the null terminated strings
//     Returns     : None
//     Description : Called in response to a SNIP Request
// *****************************************************************************
procedure AppCallback_SimpleNodeInfoReply(Node: PNMRAnetNode; AMessage: POPStackMessage);
begin

end;

// *****************************************************************************
//  procedure AppCallback_VerifiedNodeID
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   EventID: pointer to the Event ID for the message
//     Returns     : None
//     Description : This is called directly from the Hardware receive buffer.  Do
//                   not do anything here that stalls the call.  This is called
//                   Asyncronously from the Statemachine loop and the Statemachine loop
//                   is stalled until this returns.  Set a flag and move on is the
//                   best stratagy or store info in a buffer and process in the
//                   main statemachine.
// *****************************************************************************
procedure AppCallback_VerifiedNodeID(var Source: TNodeInfo; NodeID: PNodeID);
begin

end;

// *****************************************************************************
//  procedure AppCallback_InitializationComplete
//     Parameters: : Source : Full Node ID (and Alias if on CAN) of the source node for the message
//                   EventID: pointer to the Event ID for the message
//     Returns     : None
//     Description : This is called directly from the Hardware receive buffer.  Do
//                   not do anything here that stalls the call.  This is called
//                   Asyncronously from the Statemachine loop and the Statemachine loop
//                   is stalled until this returns.  Set a flag and move on is the
//                   best stratagy or store info in a buffer and process in the
//                   main statemachine.
// *****************************************************************************
procedure AppCallback_InitializationComplete(var Source: TNodeInfo; NodeID: PNodeID);
begin

end;

end.