unit MCU_Setup_dsPIC33EPxxxGP8xx;

uses
  M25P80_Driver,
  PIC32MX_CAN_RawBuffers,
  template_hardware,
  PIC32MX_CAN;

{$I Options.inc}

const
  CAN_CHANNEL = 2;

const
  CAN_SWJ        = 1;               // Set up for 125Khz Baud Rate with a 8Mhz Crystal at 140Mhz
  CAN_BRP        = 19;               // Baud Rate Prescaler = 14 Quanta
  CAN_PHASESEG_1 = 2;               //
  CAN_PHASESEG_2 = 4;               //   PHASESEG_2 > SWJ
  CAN_PROP_SEG   = 4;               //   PROP_SEG + PHASESEG_1 >= PHASESEG_2
  
  procedure MCU_Setup_Initialize;
  procedure MCU_EnableCAN;
  procedure MCU_EnableSerialFlash;
  procedure MCU_EnableUARTA;
  procedure MCU_Enable100msTimer;
  
var
  LocalCAN_Channel: Byte;

implementation

type
  PByte = ^Byte;

procedure MCU_Enable100msTimer;
begin
  TCS_T2CON_bit := 0;       // internal cycle clock
  T2IP0_bit := 1;          // Timer 2 Interrupt Priority = 5   (1 means off)
  T2IP1_bit := 0;
  T2IP2_bit := 1;
  TCKPS0_T2CON_bit := 1;   // 256 Prescaler
  TCKPS1_T2CON_bit := 1;
  PR2 := 27344;             // Clock ticks every (1/140MHz * 2 * 256 * 27344 = 100.00091ms interrupts
  T2IF_bit := 0;            // Clear T2IF
  T2IE_bit := 1;            // Enable the Interrupt
  ON__T2CON_bit := 1;       // Turn on 100ms Timer
end;

procedure MCU_EnableUARTA;
begin
  UART2_Init(230400);                       // Initialize UART module a
  Delay_ms(100);                            // Wait for UART module to stabilize
end;

procedure MCU_EnableCAN;
var
  i: Integer;
  Ptr: ^DWord;
begin
  LocalCAN_Channel := CAN_CHANNEL;
  Hardware_SetCAN_Channel(CAN_CHANNEL);
  
  PIC32MX_CAN_EnterConfigMode(CAN_CHANNEL);
  
  Ptr := @C1RXF0;
  for i := 0 to 31 do
  begin
    Ptr^ := 0;
    Ptr := Ptr + 4
  end;
  Ptr := @C2RXF0;
  for i := 0 to 31 do
  begin
    Ptr^ := 0;
    Ptr := Ptr + 4
  end;
                                                   // Place the module in Configuration Mode
  // Setup the CAN Baud Rate
  PIC32MX_CAN_SetBaud(CAN_CHANNEL, CAN_SWJ, CAN_BRP, CAN_PHASESEG_2, CAN_PHASESEG_1, CAN_PROP_SEG, True); // Setup the Baud Rate for 125kHz

  // Setup the CAN Receive Filters, AN1249 says this should be done in Config Mode
  PIC32MX_CAN_SetMask(CAN_CHANNEL, 2, $08000000, True);                         // Only look at the 28th CAN header bit (bit 27)
  PIC32MX_CAN_EnableRXFilters(CAN_CHANNEL, 0, False);                           // Disable Filters 0
  PIC32MX_CAN_EnableRXFilters(CAN_CHANNEL, 1, False);                           // Disable Filters 1
  PIC32MX_CAN_SetFilter(CAN_CHANNEL, 0, $00000000, True);                       // Look for a 0 in bit 27  (CAN Layer Messsage)
  PIC32MX_CAN_SetFilter(CAN_CHANNEL, 1, $08000000, True);                       // Look for a 1 in bit 27  (NMRABus Layer Message)
  PIC32MX_CAN_AssociateFilterWithMask(CAN_CHANNEL, 0, 2, CAN_RX_0_FIFO);        // Link Filter 0 and Mask 2 which looks only at bit 27 = 0
  PIC32MX_CAN_AssociateFilterWithMask(CAN_CHANNEL, 1, 2, CAN_RX_0_FIFO);        // Link Filter 1 and Mask 2 which looks only at bit 27 = 1
  PIC32MX_CAN_EnableRXFilters(CAN_CHANNEL, 0, True);                            // Enable Filters 0
  PIC32MX_CAN_EnableRXFilters(CAN_CHANNEL, 1, True);                            // Enable Filters 1
  
  PIC32MX_CAN_SetFIFO(CAN_CHANNEL, CAN_TX_LO_PRIORITY_FIFO, 1, True, 0);        // FIFO 0: Buffer size of 1, Is_TX, Transmit priority of 0
  PIC32MX_CAN_SetFIFO(CAN_CHANNEL, CAN_TX_HI_PRIORITY_FIFO, 1, True, 1);        // FIFO 1: size = 1 Buffer size of 1, Is_TX, Transmit priority of 1
  PIC32MX_CAN_SetFIFO(CAN_CHANNEL, CAN_RX_0_FIFO,           1, False, 0);       // FIFO 2:  size = 1 Buffer size of 1, Is_RX,
  PIC32MX_CAN_SetFIFOBaseAddress(CAN_CHANNEL, PByte(@FIFOBufferArray[0]));
  
  // Set up the FIFO Level interrupts
  PIC32MX_CAN_EnableTxInterrupts(CAN_CHANNEL, CAN_TX_LO_PRIORITY_FIFO, False, False, True);    // Interrupt on Empty
  PIC32MX_CAN_EnableTxInterrupts(CAN_CHANNEL, CAN_TX_HI_PRIORITY_FIFO, False, False, True);    // Interrupt on Empty
  PIC32MX_CAN_EnableRxInterrupts(CAN_CHANNEL, CAN_RX_0_FIFO, True, True, False, False);        // Interrupt on overflow and Full; // If we don't enable Overflow and an interrupt occurs then it hangs the loop because you can't clear the Rx Interrupt until this is serviced
  // Setup the CAN Module Level interrupts
  PIC32MX_CAN_EnableInterrupts(CAN_CHANNEL, False, False, False, False, True, False, False, True, True);  // Interrupt on Rx Overflow and Tx/Rx events
  // Setup the MCU Level Interrupts
  PIC32MX_CAN_Enable(CAN_CHANNEL, True);
  
  PIC32MX_CAN_EnterNormalMode(CAN_CHANNEL);

end;

procedure MCU_EnableSerialFlash;
begin
  SPI3_Init_Advanced(_SPI_MASTER, _SPI_8_BIT, 80, _SPI_SS_DISABLE, _SPI_DATA_SAMPLE_MIDDLE, _SPI_CLK_IDLE_HIGH, _SPI_ACTIVE_2_IDLE);
  Delay_ms(100);
  SerialFlash_init();
  SerialFlash_WriteEnable();
  Delay_ms(100);
end;

procedure MCU_Setup_Initialize;
begin    

end;

end.